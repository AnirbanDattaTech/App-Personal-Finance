# instruction_code_details.txt
"""
Describes the functionality of each file...
"""

File: expense_metadata.json
Location: expense_metadata.json
Summary: The file outlines a financial transaction structure, detailing the date format, account holders, and various spending categories. Categories include Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, each with specific subcategories like SIP, House Rent, Day Trip, Dine-in, and more.
Code: """
{
    "Date": "Date of the transaction (format: YYYY-MM-DD)",
    "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],
	"categories": {
        "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
        "Rent": ["House Rent"],
        "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
        "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
        "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
        "Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ],
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
        "Waste": ["Smoke", "Alcohol"],
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
        "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare", "Salon"],
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
        "Entertainment": ["Movies", "Concerts", "Games"],
        "Education": ["Online Courses", "Books", "Workshops"]
	},
    "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
    "Type": "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
    "Amount": "INR value of the transaction"
}
"""

File: requirements-v2.0.txt
Location: requirements-v2.0.txt
Summary: This file lists dependencies for a core application, database, and GenAI & embeddings. It includes `streamlit`, `pandas`, `numpy`, `python-dateutil`, `python-dotenv`, `requests`, `aiosqlite`, `SQLAlchemy`, `langchain-google-genai`, `google-generativeai`, `tiktoken`, `langchain`, and `langchain-community`. Some packages are commented out, indicating they are not currently in use.
Code: """
# Core Application
streamlit
pandas
numpy # Removed specific version for now, let pip resolve
python-dateutil
python-dotenv==1.0.1 # Keep specific version
requests

# Database
aiosqlite==0.21.0         # async SQLite support
# faiss-cpu==1.10.0       # Can be commented out if not used for metadata similarity yet
SQLAlchemy==2.0.39 # Keep specific version

# GenAI & Embeddings
# openai==1.68.2          # Commented out as we focus on Gemini now
# cohere==5.14.0          # Commented out
langchain-google-genai   # ADDED for Gemini support
google-generativeai      # Often a dependency, good to list
# sentence-transformers==4.0.2 # Commented out if not used for embeddings yet
# huggingface-hub==0.30.1 # Commented out if not used
# transformers            # Commented out if not used
tiktoken # Often needed by LangChain tokenizers
# tokenizers==0.21.1      # Commented out if not used directly

# LangChain & LangGraph
langchain
# langchain-cohere        # Commented out
langchain-community
langchain-core
# langchain-milvus        # Commented out
# langchain-ollama        # Commented out
# langchain-openai        # Commented out
langchain-text-splitters
langchainhub
# langfuse                # Commented out if not using LangFuse specifically
langgraph                # REQUIRED
# langgraph-api           # Usually part of langgraph or langserve install
# langgraph-checkpoint    # Needed for persistence, maybe later
langgraph-cli            # REQUIRED
# langgraph-prebuilt      # Optional prebuilt graphs
# langgraph-sdk           # Usually part of langgraph install
langsmith                # Recommended for tracing

# LangServe (for LangGraph CLI Server)
langserve                # REQUIRED

# Data Science, ML and DL (Keep for potential future DSA use)
scikit-learn # Removed specific version
scipy        # Removed specific version
statsmodels  # Removed specific version
# keras==3.9.2 # Commented out if not used now
# xgboost==3.0.0 # Commented out if not used now
joblib       # Removed specific version
torch        # Keep if planning DL later

# Data Visualization
matplotlib # Removed specific version
plotly     # REQUIRED
seaborn    # Removed specific version

# Python
six # Removed specific version
pydantic-settings # Removed specific version
pydantic         # REQUIRED (Often v1 needed by LangChain, pip should handle)

# Utilities & Helpers
black # Removed specific version
cloudpickle # Removed specific version
click     # Removed specific version
pypdf
openpyxl # Removed specific version
tqdm

# Web Frameworks (for LangServe)
# Flask==3.1.0 # Commented out, LangServe uses FastAPI
fastapi    # REQUIRED
uvicorn    # REQUIRED (often needs [standard] extras)
# beautifulsoup4 # Commented out if not used
# boto3==1.36.26 # Commented out if not used
# botocore==1.36.26 # Commented out if not used
Jinja2 # Removed specific version
"""

File: .codespellignore
Location: assistant\finance-assistant\.codespellignore
Summary: Please provide the content of the file you would like summarized.
Code: """

"""

File: .env.example
Location: assistant\finance-assistant\.env.example
Summary: This file sets up environment variables for a project named "new-agent" to manage API keys for different language model providers, including Anthropic, Fireworks, and OpenAI.
Code: """
# To separate your traces from other application
LANGSMITH_PROJECT=new-agent

# The following depend on your selected configuration

## LLM choice:
ANTHROPIC_API_KEY=....
FIREWORKS_API_KEY=...
OPENAI_API_KEY=...

"""

File: langgraph.json
Location: assistant\finance-assistant\langgraph.json
Summary: This file specifies a configuration with dependencies, a graph, and an environment. It lists the current directory as a dependency, defines a graph located at `./src/agent/graph.py:graph`, and sets the environment configuration to be loaded from a `.env` file.
Code: """
{
  "dependencies": ["."],
  "graphs": {
    "agent": "./src/agent/graph.py:graph"
  },
  "env": ".env"
}

"""

File: LICENSE
Location: assistant\finance-assistant\LICENSE
Summary: The file is the MIT License for LangChain's software, granting free use, modification, and distribution rights, provided the copyright notice is included. It disclaims warranties and limits liability for any damages.
Code: """
MIT License

Copyright (c) 2024 LangChain

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

"""

File: Makefile
Location: assistant\finance-assistant\Makefile
Summary: This Makefile defines various targets for testing, linting, and formatting a Python project. It includes commands for running unit and integration tests, watching tests, profiling tests, and executing extended tests. Additionally, it sets up linting and formatting for Python files, with specific configurations for different file sets.
Code: """
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

# Default target executed when no arguments are given to make.
all: help

# Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
	python -m pytest $(TEST_FILE)

integration_tests:
	python -m pytest tests/integration_tests 

test_watch:
	python -m ptw --snapshot-update --now . -- -vv tests/unit_tests

test_profile:
	python -m pytest -vv tests/unit_tests/ --profile-svg

extended_tests:
	python -m pytest --only-extended $(TEST_FILE)


######################
# LINTING AND FORMATTING
######################

# Define a variable for Python and notebook files.
PYTHON_FILES=src/
MYPY_CACHE=.mypy_cache
lint format: PYTHON_FILES=.
lint_diff format_diff: PYTHON_FILES=$(shell git diff --name-only --diff-filter=d main | grep -E '\.py$$|\.ipynb$$')
lint_package: PYTHON_FILES=src
lint_tests: PYTHON_FILES=tests
lint_tests: MYPY_CACHE=.mypy_cache_test

lint lint_diff lint_package lint_tests:
	python -m ruff check .
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff format $(PYTHON_FILES) --diff
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff check --select I $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || python -m mypy --strict $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || mkdir -p $(MYPY_CACHE) && python -m mypy --strict $(PYTHON_FILES) --cache-dir $(MYPY_CACHE)

format format_diff:
	ruff format $(PYTHON_FILES)
	ruff check --select I --fix $(PYTHON_FILES)

spell_check:
	codespell --toml pyproject.toml

spell_fix:
	codespell --toml pyproject.toml -w

######################
# HELP
######################

help:
	@echo '----'
	@echo 'format                       - run code formatters'
	@echo 'lint                         - run linters'
	@echo 'test                         - run unit tests'
	@echo 'tests                        - run unit tests'
	@echo 'test TEST_FILE=<test_file>   - run all tests in file'
	@echo 'test_watch                   - run unit tests in watch mode'


"""

File: pyproject.toml
Location: assistant\finance-assistant\pyproject.toml
Summary: This file is a configuration for a Python project named "agent" version 0.0.1. It specifies metadata, dependencies, and build settings. The project requires Python 3.9 or higher and depends on "langgraph" and "python-dotenv". It includes optional development dependencies and uses "setuptools" for packaging. Linting rules are defined using "ruff".
Code: """
[project]
name = "agent"
version = "0.0.1"
description = "Starter template for making a new agent LangGraph."
authors = [
    { name = "William Fu-Hinthorn", email = "13333726+hinthornw@users.noreply.github.com" },
]
readme = "README.md"
license = { text = "MIT" }
requires-python = ">=3.9"
dependencies = [
    "langgraph>=0.2.6",
    "python-dotenv>=1.0.1",
]


[project.optional-dependencies]
dev = ["mypy>=1.11.1", "ruff>=0.6.1"]

[build-system]
requires = ["setuptools>=73.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
packages = ["langgraph.templates.agent", "agent"]
[tool.setuptools.package-dir]
"langgraph.templates.agent" = "src/agent"
"agent" = "src/agent"


[tool.setuptools.package-data]
"*" = ["py.typed"]

[tool.ruff]
lint.select = [
    "E",    # pycodestyle
    "F",    # pyflakes
    "I",    # isort
    "D",    # pydocstyle
    "D401", # First line should be in imperative mood
    "T201",
    "UP",
]
lint.ignore = [
    "UP006",
    "UP007",
    # We actually do want to import from typing_extensions
    "UP035",
    # Relax the convention by _not_ requiring documentation for every function parameter.
    "D417",
    "E501",
]
[tool.ruff.lint.per-file-ignores]
"tests/*" = ["D", "UP"]
[tool.ruff.lint.pydocstyle]
convention = "google"

"""

File: README.md
Location: assistant\finance-assistant\README.md
Summary: The "New LangGraph Project" repository includes badges for continuous integration (CI) and integration tests, indicating automated testing workflows. It also features a badge to open the project in LangGraph Studio, suggesting a focus on graph-based development or visualization. The project appears to be hosted on GitHub.
Code: """
# New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml)
[![Open in - LangGraph Studio](https://img.shields.io/badge/Open_in-LangGraph_Studio-00324d.svg?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4NS4zMzMiIGhlaWdodD0iODUuMzMzIiB2ZXJzaW9uPSIxLjAiIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZD0iTTEzIDcuOGMtNi4zIDMuMS03LjEgNi4zLTYuOCAyNS43LjQgMjQuNi4zIDI0LjUgMjUuOSAyNC41QzU3LjUgNTggNTggNTcuNSA1OCAzMi4zIDU4IDcuMyA1Ni43IDYgMzIgNmMtMTIuOCAwLTE2LjEuMy0xOSAxLjhtMzcuNiAxNi42YzIuOCAyLjggMy40IDQuMiAzLjQgNy42cy0uNiA0LjgtMy40IDcuNkw0Ny4yIDQzSDE2LjhsLTMuNC0zLjRjLTQuOC00LjgtNC44LTEwLjQgMC0xNS4ybDMuNC0zLjRoMzAuNHoiLz48cGF0aCBkPSJNMTguOSAyNS42Yy0xLjEgMS4zLTEgMS43LjQgMi41LjkuNiAxLjcgMS44IDEuNyAyLjcgMCAxIC43IDIuOCAxLjYgNC4xIDEuNCAxLjkgMS40IDIuNS4zIDMuMi0xIC42LS42LjkgMS40LjkgMS41IDAgMi43LS41IDIuNy0xIDAtLjYgMS4xLS44IDIuNi0uNGwyLjYuNy0xLjgtMi45Yy01LjktOS4zLTkuNC0xMi4zLTExLjUtOS44TTM5IDI2YzAgMS4xLS45IDIuNS0yIDMuMi0yLjQgMS41LTIuNiAzLjQtLjUgNC4yLjguMyAyIDEuNyAyLjUgMy4xLjYgMS41IDEuNCAyLjMgMiAyIDEuNS0uOSAxLjItMy41LS40LTMuNS0yLjEgMC0yLjgtMi44LS44LTMuMyAxLjYtLjQgMS42LS41IDAtLjYtMS4xLS4xLTEuNS0uNi0xLjItMS42LjctMS43IDMuMy0yLjEgMy41LS41LjEuNS4yIDEuNi4zIDIuMiAwIC43LjkgMS40IDEuOSAxLjYgMi4xLjQgMi4zLTIuMy4yLTMuMi0uOC0uMy0yLTEuNy0yLjUtMy4xLTEuMS0zLTMtMy4zLTMtLjUiLz48L3N2Zz4=)](https://langgraph-studio.vercel.app/templates/open?githubUrl=https://github.com/langchain-ai/new-langgraph-project)

This template demonstrates a simple chatbot implemented using [LangGraph](https://github.com/langchain-ai/langgraph), designed for [LangGraph Studio](https://github.com/langchain-ai/langgraph-studio). The chatbot maintains persistent chat memory, allowing for coherent conversations across multiple interactions.

![Graph view in LangGraph studio UI](./static/studio_ui.png)

The core logic, defined in `src/agent/graph.py`, showcases a straightforward chatbot that responds to user queries while maintaining context from previous messages.

## What it does

The simple chatbot:

1. Takes a user **message** as input
2. Maintains a history of the conversation
3. Generates a response based on the current message and conversation history
4. Updates the conversation history with the new interaction

This template provides a foundation that can be easily customized and extended to create more complex conversational agents.

## Getting Started

Assuming you have already [installed LangGraph Studio](https://github.com/langchain-ai/langgraph-studio?tab=readme-ov-file#download), to set up:

1. Create a `.env` file.

```bash
cp .env.example .env
```

2. Define required API keys in your `.env` file.

<!--
Setup instruction auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
-->



<!--
End setup instructions
-->

3. Customize the code as needed.
4. Open the folder in LangGraph Studio!

## How to customize

1. **Modify the system prompt**: The default system prompt is defined in [configuration.py](./src/agent/configuration.py). You can easily update this via configuration in the studio to change the chatbot's personality or behavior.
2. **Select a different model**: We default to Anthropic's Claude 3 Sonnet. You can select a compatible chat model using `provider/model-name` via configuration. Example: `openai/gpt-4-turbo-preview`.
3. **Extend the graph**: The core logic of the chatbot is defined in [graph.py](./src/agent/graph.py). You can modify this file to add new nodes, edges, or change the flow of the conversation.

You can also quickly extend this template by:

- Adding custom tools or functions to enhance the chatbot's capabilities.
- Implementing additional logic for handling specific types of user queries or tasks.
- Integrating external APIs or databases to provide more dynamic responses.

## Development

While iterating on your graph, you can edit past state and rerun your app from previous states to debug specific nodes. Local changes will be automatically applied via hot reload. Try experimenting with:

- Modifying the system prompt to give your chatbot a unique personality.
- Adding new nodes to the graph for more complex conversation flows.
- Implementing conditional logic to handle different types of user inputs.

Follow-up requests will be appended to the same thread. You can create an entirely new thread, clearing previous history, using the `+` button in the top right.

For more advanced features and examples, refer to the [LangGraph documentation](https://github.com/langchain-ai/langgraph). These resources can help you adapt this template for your specific use case and build more sophisticated conversational agents.

LangGraph Studio also integrates with [LangSmith](https://smith.langchain.com/) for more in-depth tracing and collaboration with teammates, allowing you to analyze and optimize your chatbot's performance.

<!--
Configuration auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
{
  "config_schemas": {
    "agent": {
      "type": "object",
      "properties": {}
    }
  }
}
-->
"""

File: configuration.py
Location: assistant\finance-assistant\src\agent\configuration.py
Summary: The file defines a `Configuration` dataclass for an agent, allowing for customizable parameters. It includes a method `from_runnable_config` to create a `Configuration` instance from a `RunnableConfig` object, filtering fields based on predefined configurations.
Code: """
"""Define the configurable parameters for the agent."""

from __future__ import annotations

from dataclasses import dataclass, fields
from typing import Optional

from langchain_core.runnables import RunnableConfig


@dataclass(kw_only=True)
class Configuration:
    """The configuration for the agent."""

    # Changeme: Add configurable values here!
    # these values can be pre-set when you
    # create assistants (https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/)
    # and when you invoke the graph
    my_configurable_param: str = "changeme"

    @classmethod
    def from_runnable_config(
        cls, config: Optional[RunnableConfig] = None
    ) -> Configuration:
        """Create a Configuration instance from a RunnableConfig object."""
        configurable = (config.get("configurable") or {}) if config else {}
        _fields = {f.name for f in fields(cls) if f.init}
        return cls(**{k: v for k, v in configurable.items() if k in _fields})

"""

File: graph.py
Location: assistant\finance-assistant\src\agent\graph.py
Summary: The `graph.py` file defines a workflow for a finance assistant agent using a state graph. It sets up logging, loads environment variables, connects to a SQLite database, and initializes a language model (Gemini) for natural language processing. The workflow includes nodes for classifying queries, generating SQL, executing SQL, generating charts, and creating responses. It handles errors and uses conditional logic to determine the flow, ultimately generating a natural language response based on the user's query.
Code: """
# assistant/finance-assistant/src/agent/graph.py
"""Define the graph for the finance assistant agent."""

import os
import json
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from langchain_google_genai import ChatGoogleGenerativeAI # Use Gemini
from langchain_core.prompts import ChatPromptTemplate
# from langchain_core.pydantic_v1 import BaseModel, Field # Not needed right now
from langgraph.graph import StateGraph, END
from sqlalchemy import create_engine, text           # For database interaction
from pathlib import Path
import logging
from dotenv import load_dotenv
import yaml # To load the metadata YAML

# Import the AgentState definition from the state.py file in the same directory
from .state import AgentState

# --- Basic Configuration ---
# Configure logging for better visibility
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__) # Use a specific logger for this module

# Load .env file from the *project root* (app-personal-finance/)
# Adjust the number of .parent calls based on the script's location
# src/agent/graph.py -> src/agent -> src -> finance-assistant -> assistant -> app-personal-finance
project_root = Path(__file__).resolve().parent.parent.parent.parent.parent
env_path = project_root / '.env'
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    logger.info(f"Loaded environment variables from: {env_path}")
else:
    logger.warning(f".env file not found at {env_path}. Relying on system environment variables.")

# --- Database Setup ---
# Construct the path relative to the project root
DB_PATH = project_root / "data" / "expenses.db"
if not DB_PATH.exists():
    logger.error(f"CRITICAL: DATABASE NOT FOUND at expected location: {DB_PATH}")
    raise FileNotFoundError(f"Database file not found at {DB_PATH}. Ensure data/expenses.db exists in the project root.")
DB_URI = f"sqlite:///{DB_PATH.resolve()}"
try:
    # connect_args might be needed for specific DB types or async operations later
    engine = create_engine(DB_URI) #, connect_args={"check_same_thread": False})
    logger.info(f"Database engine created for: {DB_URI}")
    # Simple connection test
    with engine.connect() as conn:
         logger.info("Database connection test successful.")
except Exception as e:
    logger.error(f"Failed to create database engine or connect: {e}", exc_info=True)
    raise # Stop execution if DB setup fails

# --- LLM Setup (Gemini) ---
google_api_key = os.getenv("GOOGLE_API_KEY")
if not google_api_key:
    logger.error("CRITICAL: GOOGLE_API_KEY not found in environment variables.")
    raise ValueError("GOOGLE_API_KEY environment variable must be set in the .env file.")

try:
    # Initialize Gemini LLM - Using flash for speed/cost
    LLM = ChatGoogleGenerativeAI(
        model="gemini-1.5-flash-latest",
        google_api_key=google_api_key,
        temperature=0.1, # Lower temperature for more deterministic tasks initially
        convert_system_message_to_human=True # Important for Gemini compatibility
    )
    logger.info("ChatGoogleGenerativeAI model initialized (gemini-1.5-flash-latest).")
except Exception as e:
    logger.error(f"Failed to initialize ChatGoogleGenerativeAI: {e}", exc_info=True)
    raise # Stop execution if LLM setup fails

# --- Metadata Loading ---
# Load the detailed metadata YAML file
metadata_path = project_root / "metadata" / "expenses_metadata_detailed.yaml"
SCHEMA_METADATA = "" # Initialize as empty string
try:
    if metadata_path.exists():
        with open(metadata_path, 'r', encoding='utf-8') as f:
            # Load the YAML content - consider formatting it for the prompt
            metadata_content = yaml.safe_load(f)
            # Basic string conversion - could be refined for better LLM digestion
            SCHEMA_METADATA = json.dumps(metadata_content, indent=2)
            logger.info(f"Successfully loaded metadata from {metadata_path}")
    else:
        logger.warning(f"Metadata file not found at {metadata_path}. SQL generation accuracy may be reduced.")
        # Provide a minimal fallback schema description if file is missing
        SCHEMA_METADATA = """
         Fallback Schema:
         Table: expenses
         Columns: id(TEXT PK), date(DATE 'YYYY-MM-DD'), year(INT), month(TEXT 'YYYY-MM'), week(TEXT 'YYYY-Www'), day_of_week(TEXT), account(TEXT), category(TEXT), sub_category(TEXT), type(TEXT), user(TEXT 'Anirban'|'Puspita'), amount(REAL INR).
         """
except Exception as e:
    logger.error(f"Failed to load or parse metadata YAML: {e}", exc_info=True)
    # Proceed with fallback schema or raise error depending on desired robustness
    SCHEMA_METADATA = """
     Fallback Schema: Table: expenses. Columns: id, date, year, month, week, day_of_week, account, category, sub_category, type, user, amount.
     """


# ==========================================================================
#                       NODE FUNCTIONS Will Go Here
# ==========================================================================
def classify_query_node(state: AgentState) -> dict:
    """
    Classifies the user's original query into 'simple', 'advanced', or 'irrelevant'.

    Args:
        state (AgentState): The current state of the graph. Must contain 'original_query'.

    Returns:
        dict: A dictionary containing the 'classification' key with the determined category,
              or an 'error' key if classification fails.
    """
    logger.info("--- Executing Node: classify_query_node ---")
    query = state.get('original_query') # Use .get() for safety

    if not query:
        logger.error("Original query is missing in state for classification.")
        # Return error and default classification
        return {"error": "Missing user query.", "classification": "irrelevant"}

    logger.debug(f"Classifying query: '{query}'")

    # Define the prompt for the classification task
    prompt = ChatPromptTemplate.from_messages([
        ("system", """Your primary task is to classify user questions about personal finance data into one of three categories. Respond ONLY with a single word: 'simple', 'advanced', or 'irrelevant'.

Definitions:
- simple: Directly answerable with a standard SQL query on the 'expenses' table. Examples: totals, averages, filtering by date/category/user, specific lookups like 'What was my total spend last month?', 'Show my grocery expenses in Jan 2024', 'List expenses over 1000 INR'.
- advanced: Requires complex analysis beyond direct SQL (e.g., forecasting, prediction, anomaly detection, clustering, complex multi-step calculations). Examples: 'Predict my spending next week', 'Cluster my spending habits', 'Find unusual spending patterns'. FOR THIS INITIAL IMPLEMENTATION, TREAT 'advanced' THE SAME AS 'simple' downstream (proceed to SQL generation).
- irrelevant: Unrelated to the user's personal finance data stored in the expenses table. Examples: 'What is the weather like?', 'Who won the game?', 'General knowledge questions'.
"""),
        # Explicitly tell the LLM what to do with the user's query
        ("user", f"Classify the following user query: {query}")
    ])

    # Create the chain: Prompt -> LLM
    chain = prompt | LLM

    try:
        # Invoke the LLM
        response = chain.invoke({}) # Provide empty input as context is in the prompt
        # Clean the LLM response: lower case, remove extra characters/whitespace
        classification = response.content.strip().lower().replace("'", "").replace('"', '').replace(".", "")
        logger.info(f"Gemini raw classification response: '{response.content}' -> Cleaned: '{classification}'")

        # Validate the classification output
        valid_classifications = ['simple', 'advanced', 'irrelevant']
        if classification not in valid_classifications:
            logger.warning(f"LLM returned an unexpected classification: '{classification}'. Defaulting to 'simple'.")
            # Fallback to a safe default if the LLM response is malformed
            classification = 'simple'

    except Exception as e:
        logger.error(f"LLM call failed during query classification for query '{query}': {e}", exc_info=True)
        # If the LLM call fails, set an error and default classification
        return {"error": f"Failed to classify query due to LLM error: {e}", "classification": "simple"}

    # Return the classification in the expected dictionary format to update the state
    return {"classification": classification}

def generate_sql_node(state: AgentState) -> dict:
    """
    Generates an SQLite query based on the user's original query and schema metadata.

    Args:
        state (AgentState): The current state graph. Must contain 'original_query'.
                           Uses the pre-loaded SCHEMA_METADATA constant.

    Returns:
        dict: A dictionary containing the 'sql_query' key with the generated query string,
              or an 'error' key if SQL generation fails.
    """
    logger.info("--- Executing Node: generate_sql_node ---")
    query = state.get('original_query')

    # Check if classification failed or query is missing
    if state.get('error'):
         logger.warning(f"Skipping SQL generation due to previous error: {state['error']}")
         # Don't overwrite the existing error, just pass through
         return {} # Return empty dict, error state persists
    if not query:
        logger.error("Original query is missing in state for SQL generation.")
        return {"error": "Missing user query."} # Set specific error for this node

    logger.debug(f"Generating SQL for query: '{query}'")

    # Ensure SCHEMA_METADATA is available (loaded during initial setup)
    if not SCHEMA_METADATA:
        logger.error("Schema metadata (SCHEMA_METADATA) is empty or was not loaded.")
        return {"error": "Database schema metadata is unavailable."}

    # Define the prompt for SQL generation, injecting the loaded metadata
    prompt = ChatPromptTemplate.from_messages([
         ("system", f"""You are an expert SQLite query generator. Your task is to generate a precise and syntactically correct SQLite query for the 'expenses' table based ONLY on the user's question and the provided schema metadata.

Schema Metadata:
------
{SCHEMA_METADATA}
------

Query Generation Instructions:
1.  Analyze the user's question and the detailed schema metadata.
2.  Identify the relevant columns, filters, aggregations (SUM, AVG, COUNT), and grouping clauses needed.
3.  Use the 'purpose_for_llm' descriptions in the metadata to understand column usage and handle potential ambiguities (e.g., prefer 'Household.Electricity Bill' for bill payments, consider context for 'Amazon').
4.  Construct a single, valid SQLite query.
5.  Interpret timeframes relative to a plausible current date (e.g., assume mid-2024 or later for 'last month', 'this year'). Use specific 'YYYY-MM-DD' date formats in WHERE clauses (e.g., `date BETWEEN '2024-01-01' AND '2024-01-31'`).
6.  Respond ONLY with the raw SQL query. Do NOT include any explanations, comments, or markdown formatting (like ```sql or ```).
7.  Ensure the query terminates correctly (no trailing semicolon needed typically for execution libraries).
"""),
        # Provide the user query clearly
         ("user", f"Generate the SQLite query for the following question: {query}")
    ])

    # Create the chain
    chain = prompt | LLM

    try:
        # Invoke the LLM
        response = chain.invoke({}) # Context is in the prompt
        # Clean the response: remove markdown, strip whitespace, remove trailing semicolon
        sql_query = response.content.strip().replace("```sql", "").replace("```", "").strip()
        if sql_query.endswith(';'):
            sql_query = sql_query[:-1].strip()

        logger.info(f"Gemini raw SQL response: '{response.content}' -> Cleaned: '{sql_query}'")

        # Basic validation: Check if it's non-empty and seems like a SELECT statement
        if not sql_query or not sql_query.lower().startswith("select"):
             logger.error(f"Generated query is empty or does not start with SELECT: '{sql_query}'")
             # Return the potentially faulty query along with the error
             return {"error": "Failed to generate a valid SELECT query.", "sql_query": sql_query or "Empty response"}

    except Exception as e:
        logger.error(f"LLM call failed during SQL generation for query '{query}': {e}", exc_info=True)
        return {"error": f"Failed to generate SQL query due to LLM error: {e}"}

    # Return the generated SQL query to update the state
    return {"sql_query": sql_query}

def execute_sql_node(state: AgentState) -> dict:
    """
    Executes the generated SQL query against the SQLite database using SQLAlchemy.

    Args:
        state (AgentState): The current graph state. Must contain 'sql_query' if no prior error.

    Returns:
        dict: A dictionary containing 'sql_results_df' (Pandas DataFrame) and
              'sql_results_str' (string representation), or an 'error' key if execution fails.
    """
    logger.info("--- Executing Node: execute_sql_node ---")
    sql_query = state.get('sql_query') # Safer access using .get()

    # Check if SQL generation failed or if there's a prior error
    if state.get('error'):
        logger.warning(f"Skipping SQL execution due to previous error: {state['error']}")
        # Ensure results state fields are appropriately empty/error-indicating
        return {"sql_results_df": pd.DataFrame(), "sql_results_str": f"Error: {state['error']}"}
    if not sql_query:
        logger.error("No SQL query found in state to execute.")
        return {"error": "SQL query generation failed or was missing.", "sql_results_df": pd.DataFrame(), "sql_results_str": "Error: No SQL query found."}

    logger.info(f"Attempting to execute SQL query: [{sql_query}]")
    try:
        # Use the globally defined SQLAlchemy engine
        with engine.connect() as connection:
            # Execute query using pandas for easy DataFrame conversion
            # Use text() for safe query execution with SQLAlchemy
            df = pd.read_sql(sql=text(sql_query), con=connection)
        logger.info(f"SQL query executed successfully. Number of rows returned: {len(df)}")

        # --- Post-execution Data Formatting (Optional but Recommended) ---
        if not df.empty:
            # Attempt to format common column types for better display/consistency
            for col in df.columns:
                # Format date-like columns
                if 'date' in col.lower(): # Check if 'date' is part of the column name
                    try:
                        # Convert to datetime if not already, then format
                        df[col] = pd.to_datetime(df[col]).dt.strftime('%Y-%m-%d')
                    except Exception as date_fmt_err:
                        logger.warning(f"Could not format date column '{col}': {date_fmt_err}")
                # Format amount-like columns (round to 2 decimals)
                elif 'amount' in col.lower() and pd.api.types.is_numeric_dtype(df[col]):
                    try:
                        df[col] = df[col].round(2)
                    except Exception as amount_fmt_err:
                        logger.warning(f"Could not format amount column '{col}': {amount_fmt_err}")

            # Create string representation for LLM prompt context / basic display
            # Use na_rep to show NULL for missing values clearly
            results_str = df.to_string(index=False, na_rep='<NA>')
        else:
            results_str = "Query returned no results." # Specific message for empty results

        # Return both the DataFrame and the string representation
        # Note: Passing DataFrames in state can sometimes cause serialization issues
        # depending on the checkpoint/backend used with LangGraph.
        # If issues arise, consider serializing df to dict/json: df.to_dict('records')
        return {"sql_results_df": df, "sql_results_str": results_str}

    except Exception as e:
        # Catch potential SQLAlchemy errors, pandas errors, etc.
        logger.error(f"SQL execution failed for query [{sql_query}]: {e}", exc_info=True)
        # Provide a detailed error message
        error_msg = f"Failed to execute SQL query. Error: {e}. Query Attempted: [{sql_query}]"
        # Ensure state consistency by returning empty df and error string
        return {"error": error_msg, "sql_results_df": pd.DataFrame(), "sql_results_str": f"Error executing SQL."}

def generate_chart_node(state: AgentState) -> dict:
    """
    Generates a Plotly chart JSON based on the SQL query results (DataFrame).
    Uses simple heuristics to determine the most appropriate chart type.

    Args:
        state (AgentState): The current graph state. Needs 'sql_results_df'.

    Returns:
        dict: A dictionary containing 'chart_json' (Plotly JSON string) if successful,
              otherwise None. Does not typically set the main 'error' state unless
              charting itself is critical and fails unexpectedly.
    """
    logger.info("--- Executing Node: generate_chart_node ---")
    # Use .get() for safe access to state elements
    df = state.get('sql_results_df')
    error = state.get('error')
    query = state.get('original_query', 'Unknown query') # For context if needed

    # --- Pre-checks ---
    # 1. Don't generate if there was a preceding error
    if error:
        logger.warning(f"Skipping chart generation due to previous error: {error}")
        return {"chart_json": None}
    # 2. Don't generate if the DataFrame is missing (shouldn't happen if execute_sql handles errors properly)
    if df is None:
        logger.warning("Skipping chart generation as DataFrame is None.")
        return {"chart_json": None}
    # 3. Don't generate if DataFrame is empty
    if df.empty:
        logger.info("Skipping chart generation as DataFrame is empty.")
        return {"chart_json": None}

    logger.info(f"Attempting chart generation with DataFrame shape: {df.shape}")
    logger.debug(f"DataFrame columns: {df.columns.tolist()}")
    # logger.debug(f"DataFrame dtypes:\n{df.dtypes}") # Uncomment for detailed debugging

    # --- Chart Generation Logic ---
    try:
        fig = None # Initialize figure object
        num_rows, num_cols = df.shape
        # Use lower case column names for case-insensitive matching
        col_names_lower = df.columns.str.lower()

        # Identify numeric columns suitable for plotting (exclude 'id', 'year')
        numeric_cols = [
            col for col in df.columns
            if pd.api.types.is_numeric_dtype(df[col])
            and col.lower() not in ['id', 'year'] # Exclude typical non-measure IDs/years
        ]
        logger.debug(f"Identified numeric columns for plotting: {numeric_cols}")

        # --- Heuristics for Chart Type Selection ---

        # Heuristic 1: Time Series Data (Date/Month vs. One Numeric Value) -> Line Chart
        # Check for common date/time column names
        date_col_present = 'date' in col_names_lower or 'month' in col_names_lower or 'yearmonth' in col_names_lower
        if date_col_present and len(numeric_cols) == 1:
            # Identify the date/time column
            if 'date' in col_names_lower:
                time_col = df.columns[col_names_lower.tolist().index('date')]
            elif 'month' in col_names_lower:
                 time_col = df.columns[col_names_lower.tolist().index('month')]
            else:
                 time_col = df.columns[col_names_lower.tolist().index('yearmonth')]

            value_col = numeric_cols[0]
            logger.info(f"Attempting Line Chart: X='{time_col}', Y='{value_col}'")
            try:
                # Ensure time column is sortable (convert to datetime if needed, handle errors)
                df_sorted = df.sort_values(by=time_col)
                fig = px.line(df_sorted, x=time_col, y=value_col, title=f"{value_col.capitalize()} Trend", markers=True)
                fig.update_layout(xaxis_title=time_col.capitalize(), yaxis_title=value_col.capitalize())
            except TypeError as sort_err:
                 logger.warning(f"TypeError during sorting/plotting line chart (column '{time_col}' might not be sortable): {sort_err}. Skipping line chart.")
            except Exception as line_err:
                 logger.warning(f"Could not generate line chart: {line_err}. Skipping line chart.")

        # Heuristic 2: Categorical vs. Single Numeric -> Bar Chart (Most Common)
        # Typically shape (N rows, 2 columns) where one is numeric
        elif num_cols == 2 and len(numeric_cols) == 1:
            value_col = numeric_cols[0]
            # Find the non-numeric column assumed to be categorical
            cat_col = next((col for col in df.columns if col != value_col), None)

            if cat_col:
                logger.info(f"Attempting Bar Chart: Category='{cat_col}', Value='{value_col}'")
                try:
                    # Limit number of bars for readability - Sort descending by value first
                    max_bars = 15
                    df_agg = df.sort_values(by=value_col, ascending=False)
                    df_chart = df_agg.head(max_bars)

                    title_suffix = f" (Top {max_bars})" if len(df_agg) > max_bars else ""
                    title = f"{value_col.capitalize()} by {cat_col.capitalize()}{title_suffix}"

                    fig = px.bar(df_chart, x=cat_col, y=value_col, title=title, text_auto='.2s')
                    # Improve layout for bar values
                    fig.update_traces(textangle=0, textposition="outside")
                    fig.update_layout(xaxis_title=cat_col.capitalize(), yaxis_title=value_col.capitalize())
                except Exception as bar_err:
                    logger.warning(f"Could not generate bar chart: {bar_err}. Skipping bar chart.")
            else:
                logger.warning("Bar chart condition met (2 cols, 1 numeric) but failed to identify categorical column.")

        # Heuristic 3: Single Value Result -> No graphical chart needed
        # Example: SELECT SUM(amount)... results in 1 row, 1 numeric col
        elif num_rows == 1 and len(numeric_cols) == 1:
            logger.info("Single numeric value result. Skipping graphical chart generation.")
            # The text summary node should handle displaying this value.
            return {"chart_json": None}

        # --- Fallback ---
        # If no specific heuristic matched
        if fig is None:
            logger.info("No specific chart type matched heuristics. Skipping chart generation.")
            return {"chart_json": None}

        # --- Finalize and Serialize Chart ---
        # Apply common layout settings
        fig.update_layout(
            margin=dict(l=40, r=20, t=60, b=40), # Adjust margins as needed
            title_x=0.5, # Center title
            legend_title_text=None # Hide legend title if legend exists
        )
        chart_json = fig.to_json()
        logger.info("Plotly chart JSON generated successfully.")
        return {"chart_json": chart_json}

    except Exception as e:
        # Catch any unexpected errors during the charting process
        logger.error(f"Unexpected error during chart generation: {e}", exc_info=True)
        # Don't set the main 'error' state here, just fail to produce a chart
        return {"chart_json": None}

# Import PromptTemplate if not already imported at the top
from langchain_core.prompts import PromptTemplate # Or keep ChatPromptTemplate

def generate_response_node(state: AgentState) -> dict:
    """
    Generates the final natural language response. Uses PromptTemplate but
    removes backticks around SQL data in the template to avoid rendering issues.

    Args:
        state (AgentState): The current graph state. Needs 'original_query'.
                           Uses 'sql_results_str', 'error', 'classification',
                           and checks for 'chart_json'.

    Returns:
        dict: A dictionary containing the 'final_response' string.
    """
    logger.info("--- Executing Node: generate_response_node ---")
    query = state.get('original_query', "An unspecified query")
    sql_results = state.get('sql_results_str', '')
    error = state.get('error')
    classification = state.get('classification')
    chart_available = state.get('chart_json') is not None

    final_response = ""

    # --- Response Generation Logic ---

    # 1. Prioritize responding to errors (Same as previous versions)
    if error:
        logger.warning(f"Generating response based on detected error: {error}")
        error_str = str(error)
        # ... (error handling logic remains the same) ...
        if "Failed to execute SQL" in error_str or "syntax error" in error_str.lower():
            final_response = f"I encountered an issue trying to retrieve the data ({error_str}). Perhaps try asking differently?"
        elif "Failed to generate SQL" in error_str:
             final_response = f"I had trouble understanding how to fetch the data ({error_str}). Could you please rephrase?"
        elif "Failed to classify query" in error_str:
             final_response = f"I had trouble understanding your request type ({error_str}). Could you clarify?"
        else: # Generic error
            final_response = f"I'm sorry, I encountered an issue: {error_str}. Please try again."


    # 2. Handle irrelevant classification (Same as previous versions)
    elif classification == 'irrelevant':
         final_response = "This question doesn't seem related to your financial expenses. Could you ask something about your spending?"
         logger.info("Generated response for 'irrelevant' classification.")

    # 3. Handle no results (Same as previous versions)
    elif not error and (not sql_results or sql_results == "Query returned no results."):
         final_response = "I looked through your expense records based on your query, but couldn't find any matching transactions."
         logger.info("Generated response for query with no results.")

    # 4. Generate a summary response based on successful SQL results
    elif not error and sql_results:
        logger.info("Generating summary response using PromptTemplate (no backticks).")
        chart_mention = "I've also prepared a chart to visualize this." if chart_available else ""

        # *** TEMPLATE WITHOUT BACKTICKS AROUND DATA ***
        # Define the template string with clear placeholders, omitting ```
        template_string = """System: You are a friendly financial assistant. Summarize the retrieved data based on the user's question.

Instructions:
*   Answer the user's question ({user_query}) using the key information from the data below.
*   Summarize findings/trends if data is tabular. State single numbers clearly. Do NOT just repeat the raw data.
*   {chart_mention_instruction} Mention the chart briefly if applicable.
*   Keep the tone conversational (use "You"/"Your"). Avoid jargon.

Retrieved Data:
{sql_data}

Assistant: """ 

        # Create the PromptTemplate object
        prompt = PromptTemplate(
            template=template_string,
            input_variables=["user_query", "sql_data", "chart_mention_instruction"]
        )
        # *** END OF TEMPLATE MODIFICATION ***

        # Create the chain
        chain = prompt | LLM

        try:
            if LLM is None: raise ValueError("LLM client is not initialized.")

            # Prepare the input dictionary
            input_dict = {
                "user_query": query,
                "sql_data": sql_results,
                "chart_mention_instruction": chart_mention
            }

            # Invoke the chain
            response = chain.invoke(input_dict)
            final_response = response.content.strip()
            logger.info("Successfully generated summary response from LLM.")

        except Exception as e:
            logger.error(f"LLM call failed during final response generation: {e}", exc_info=True)
            # Include raw results in fallback, even without backticks in prompt
            final_response = f"I retrieved the data:\n{sql_results}\nBut I had trouble summarizing it."

    # 5. Fallback (Same as previous versions)
    else:
        logger.error("Reached end of generate_response_node without generating a response. State: %s", state)
        final_response = "I'm sorry, I wasn't able to determine a response for your query."

    # Ensure final_response is always set (Same as previous versions)
    if not final_response:
        logger.warning("Final response was empty after processing, providing default.")
        final_response = "I'm sorry, I couldn't process that request properly."

    return {"final_response": final_response}

# ==========================================================================
#                       EDGE LOGIC FUNCTION
# ==========================================================================

def should_continue(state: AgentState) -> str:
    """
    Determines the next node to execute based on the current state,
    specifically the query classification or presence of errors.

    Args:
        state (AgentState): The current graph state.

    Returns:
        str: The name of the next node to call ('generate_sql', 'generate_response'),
             or potentially END (though current logic routes errors to response).
    """
    logger.info("--- Evaluating Edge: should_continue ---")
    classification = state.get('classification')
    error = state.get('error') # Check if ANY previous node set an error

    # Priority 1: Handle errors immediately by routing to final response generation
    # The generate_response_node is responsible for formatting the error message.
    if error:
        logger.warning(f"Error detected in state ('{error}'), routing directly to 'generate_response'.")
        return "generate_response"

    # Priority 2: Handle irrelevant classification
    elif classification == 'irrelevant':
        logger.info("Classification is 'irrelevant', routing to 'generate_response'.")
        return "generate_response"

    # Priority 3: Proceed with data retrieval for simple/advanced queries
    elif classification in ['simple', 'advanced']:
        logger.info(f"Classification is '{classification}', routing to 'generate_sql'.")
        return "generate_sql"

    # Fallback: This case indicates an issue, likely with the classification node.
    # Route to response node to report the internal issue.
    else:
        logger.error(f"Unknown or missing classification ('{classification}') in state. Routing to generate_response.")
        # We don't set the error here, let generate_response handle the lack of valid path.
        # Alternatively, could set state['error'] = "Internal classification error" here.
        return "generate_response"

# ==========================================================================
#                       GRAPH DEFINITION
# ==========================================================================

logger.info("Defining LangGraph workflow structure...")

# Initialize the state graph with our AgentState definition
workflow = StateGraph(AgentState)
logger.debug("StateGraph initialized.")

# Add the nodes to the graph, associating a name with each function
workflow.add_node("classify_query", classify_query_node)
workflow.add_node("generate_sql", generate_sql_node)
workflow.add_node("execute_sql", execute_sql_node)
workflow.add_node("generate_chart", generate_chart_node)
workflow.add_node("generate_response", generate_response_node)
logger.info("Nodes added to the graph: classify_query, generate_sql, execute_sql, generate_chart, generate_response")

# Define the entry point of the graph
workflow.set_entry_point("classify_query")
logger.info("Graph entry point set to 'classify_query'.")

# Define the conditional edge after the classification node.
# The 'should_continue' function will determine which node to go to next.
workflow.add_conditional_edges(
    start_node_name="classify_query", # The node where the decision is made
    condition=should_continue,        # The function that returns the next node's name
    # A dictionary mapping the possible return values of 'condition'
    # to the actual names of the next nodes to execute.
    conditional_edge_mapping={
        "generate_sql": "generate_sql",        # If should_continue returns "generate_sql"
        "generate_response": "generate_response" # If should_continue returns "generate_response" (for errors or irrelevant)
        # We don't map END here, as both paths lead to further processing nodes.
    }
)
logger.info("Conditional edge added from 'classify_query' based on 'should_continue' logic.")

# Define the linear flow for the main data processing path
# Connect nodes sequentially after the conditional split directs to 'generate_sql'
workflow.add_edge("generate_sql", "execute_sql")
workflow.add_edge("execute_sql", "generate_chart")
workflow.add_edge("generate_chart", "generate_response")
logger.info("Linear edges defined: generate_sql -> execute_sql -> generate_chart -> generate_response.")

# Define the final step: after generating the response, the graph ends.
workflow.add_edge("generate_response", END) # END is a special marker from langgraph.graph
logger.info("Final edge added from 'generate_response' to END.")

# ==========================================================================
#                       Compile & Assign Entry Point Variable ('graph')
# ==========================================================================

# Compile the workflow into a runnable application object
# The compiled object MUST be assigned to the variable name 'graph'
# as defined in langgraph.json
graph = workflow.compile()
logger.info("LangGraph workflow compiled successfully. Runnable 'graph' object created.")

# Optional: Add a simple test execution block (useful during development)
# This will only run if you execute graph.py directly (python src/agent/graph.py)
if __name__ == "__main__":
    logger.info("--- Running Direct Script Test ---")
    # Example test invocation (replace with relevant queries)
    test_queries = [
        "What was my total spend last month?",
        "Show my grocery expenses",
        "what is the weather?",
        "Compare spending between Anirban and Puspita for Rent",
        "Generate a query with syntax error deliberately" # Example for testing error path
    ]
    test_input = {"original_query": test_queries[0]} # Change index to test different queries

    logger.info(f"Test Input: {test_input}")
    try:
        # Use stream to see the steps
        for output_chunk in graph.stream(test_input, {"recursion_limit": 10}):
            # output is a dictionary where keys are node names, values are output dicts
            node_name = list(output_chunk.keys())[0]
            node_data = output_chunk[node_name]
            logger.info(f"--- Step Output: {node_name} ---")
            # Log relevant parts of the node output (avoid printing large dataframes directly)
            log_output = {k: (v[:100] + '...' if isinstance(v, str) and len(v) > 100 else v)
                          for k, v in node_data.items() if k != 'sql_results_df'} # Exclude df for brevity
            logger.info(f"{log_output}")

        # Optionally invoke again to get final state easily (can be large)
        # final_state = graph.invoke(test_input, {"recursion_limit": 10})
        # logger.info(f"--- Final State ---")
        # logger.info(json.dumps(final_state, indent=2, default=str)) # Use default=str for non-serializable like DataFrame

    except Exception as e:
        logger.error(f"Test execution failed: {e}", exc_info=True)

    logger.info("--- Direct Script Test Complete ---")
"""

File: state.py
Location: assistant\finance-assistant\src\agent\state.py
Summary: The file defines the `AgentState` class using `TypedDict` to represent the state shared across an agent graph. It includes fields for the user's original query, query classification, generated SQL query and results, chart data, final response, and error handling.
Code: """
# assistant/finance-assistant/src/agent/state.py
"""Define the state structures for the agent."""

from __future__ import annotations # Ensures compatibility with type hints

# Use typing.TypedDict for standard LangGraph state
from typing import TypedDict, Optional, List, Dict, Any
import pandas as pd

# Define the structure of the state that will be passed between nodes
class AgentState(TypedDict):
    """Represents the state shared across the agent graph."""
    original_query: str           # The initial question from the user
    classification: Optional[str]   # 'simple', 'advanced', 'irrelevant'
    sql_query: Optional[str]        # Generated SQL query
    sql_results_str: Optional[str]  # SQL results as a formatted string
    sql_results_df: Any             # SQL results as a Pandas DataFrame (use Any for now, handle serialization if needed)
    chart_json: Optional[str]       # Plotly figure JSON representation
    final_response: Optional[str]   # Final text response for the user
    error: Optional[str]            # To capture errors during execution
"""

File: __init__.py
Location: assistant\finance-assistant\src\agent\__init__.py
Summary: The file introduces a new module called "New LangGraph Agent," which defines a custom graph by importing the `graph` from `agent.graph`. The `__all__` list specifies that only `graph` is intended for public use from this module.
Code: """
"""New LangGraph Agent.

This module defines a custom graph.
"""

from agent.graph import graph

__all__ = ["graph"]

"""

File: studio_ui.png
Location: assistant\finance-assistant\static\studio_ui.png
Summary: I'm unable to access the contents of the file to provide a summary. Please try again by providing the text or key details from the file.
Code: """
Unable to read file.
"""

File: test_graph.py
Location: assistant\finance-assistant\tests\integration_tests\test_graph.py
Summary: This code is a test file using `pytest` and `langsmith` to test an asynchronous function `test_agent_simple_passthrough`. It invokes the `graph.ainvoke` function with a dictionary input and asserts that the result is not `None`.
Code: """
import pytest
from langsmith import unit

from agent import graph


@pytest.mark.asyncio
@unit
async def test_agent_simple_passthrough() -> None:
    res = await graph.ainvoke({"changeme": "some_val"})
    assert res is not None

"""

File: __init__.py
Location: assistant\finance-assistant\tests\integration_tests\__init__.py
Summary: This file is a placeholder or instruction indicating that integration tests should be defined within the specified directory.
Code: """
"""Define any integration tests you want in this directory."""

"""

File: test_configuration.py
Location: assistant\finance-assistant\tests\unit_tests\test_configuration.py
Summary: This code snippet imports the `Configuration` class from the `agent.configuration` module and defines a test function `test_configuration_empty`. The function tests the `Configuration.from_runnable_config` method with an empty dictionary as input, likely to verify handling of empty configurations.
Code: """
from agent.configuration import Configuration


def test_configuration_empty() -> None:
    Configuration.from_runnable_config({})

"""

File: __init__.py
Location: assistant\finance-assistant\tests\unit_tests\__init__.py
Summary: The file is a placeholder or instruction for defining unit tests within the directory, suggesting that developers should create and include any necessary unit tests for the code present in that location.
Code: """
"""Define any unit tests you may want in this directory."""

"""

File: expenses.csv
Location: data\expenses.csv
Summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes entries for rent, household, grocery, and restaurant expenses, categorized by account holder (Anirban or Puspita), with specific sub-categories and amounts for each transaction.
Code: """
      date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
2023-01-01  2023 2023-01 2023-W52      Sunday   Puspita-SBI  Household             Maid        Monthly Maid Salary Puspita  2500.00
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI    Grocery            Other         Meat/Fish Purchase Anirban   534.04
2023-01-01  2023 2023-01 2023-W52      Sunday   Puspita-SBI    Grocery Flipkart Grocery         FK Quick Groceries Puspita  2921.10
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI Restaurant         Takeaway               Lunch Parcel Anirban   848.85
"""

File: expenses_metadata_detailed.yaml
Location: metadata\expenses_metadata_detailed.yaml
Summary: The file describes the "expenses" table, which records financial transactions for users Anirban and Puspita. Each transaction is uniquely identified by a primary key "id". Relationships map accounts to users, aiding in tracking spending, budget adherence, and financial analysis. The "id" column is a unique, auto-generated identifier.
Code: """
table_name: expenses
description: "Stores all recorded financial transactions for users Anirban and Puspita. Each row represents a single expense event. Used to track spending patterns, budget adherence, and answer financial queries."
primary_key: id # Assuming 'id' is a UUID added during DB creation

# Explicit relationship mapping derived from expense_metadata.json
relationships:
  - type: derived
    from_column: account
    to_column: user
    mapping:
      "Anirban-SBI": "Anirban"
      "Anirban-ICICI": "Anirban"
      "Puspita-SBI": "Puspita"
      "Puspita-Bandhan": "Puspita"
    description: "The 'user' is strictly determined by the 'account' used in the transaction according to this fixed mapping."

columns:
  - name: id
    data_type: TEXT # Or UUID if supported natively
    description: "Unique identifier for each transaction record. Auto-generated, not typically used in user queries."
    constraints: "Primary Key, Not Null, Unique"
    purpose_for_llm: "Internal database identifier. Avoid using in filters unless a specific transaction ID is provided."

  - name: date
    data_type: DATE # Store as ISO 8601 string 'YYYY-MM-DD' or DATE type
    description: "The exact date the transaction occurred (format: YYYY-MM-DD)."
    example_values: ["2023-10-26", "2024-01-15"]
    constraints: "Not Null"
    purpose_for_llm: "Primary column for filtering by time. Use for specific dates, date ranges (e.g., 'last month', 'this year', 'between Jan 1 2024 and Mar 31 2024'), or time-based aggregations. Always use this column for date conditions."

  - name: year
    data_type: INTEGER
    description: "The year the transaction occurred (extracted from the 'date' column)."
    example_values: [2023, 2024]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for filtering or grouping expenses by calendar year (e.g., 'total spend in 2023', 'compare 2023 vs 2024'). Less granular than 'month' or 'date'."

  - name: month
    data_type: TEXT # Format 'YYYY-MM'
    description: "The year and month the transaction occurred (extracted from the 'date' column, format: YYYY-MM)."
    example_values: ["2023-10", "2024-01"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Primary column for monthly analysis. Use for filtering or grouping by specific month (e.g., 'spend in January 2024', 'monthly trends', 'compare spending across months'). Use this when the query specifies a month or asks for monthly patterns."

  - name: week
    data_type: TEXT # Format 'YYYY-Www' (ISO week date)
    description: "The ISO week number (W01-W53) within the year the transaction occurred (extracted from the 'date' column, format YYYY-Www)."
    example_values: ["2023-W43", "2024-W03"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for filtering or grouping expenses by week (e.g., 'last week's spend', 'weekly grocery total'). Useful for short-term pattern analysis."

  - name: day_of_week
    data_type: TEXT
    description: "The name of the day the transaction occurred (e.g., Sunday, Monday)."
    example_values: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for analyzing spending patterns based on the day of the week (e.g., 'weekend restaurant spending', 'average spend on weekdays vs weekends')."

  - name: account
    data_type: TEXT
    description: "The specific bank account used for the transaction. Belongs to either Anirban or Puspita. Each account maps deterministically to one user."
    unique_values: ["Anirban-SBI", "Anirban-ICICI", "Puspita-SBI", "Puspita-Bandhan"]
    constraints: "Not Null. Value must be one of the predefined accounts."
    purpose_for_llm: |
        Use for filtering expenses by the source account or comparing spending across accounts.
        This column directly determines the 'user'. Refer to the 'relationships' section or the 'user' column definition for the exact mapping:
        - 'Anirban-SBI' -> 'Anirban'
        - 'Anirban-ICICI' -> 'Anirban'
        - 'Puspita-SBI' -> 'Puspita'
        - 'Puspita-Bandhan' -> 'Puspita'
        If a query mentions a user AND an account, ensure they are consistent with this mapping.

  - name: category
    data_type: TEXT
    description: "Broad classification of the expense (e.g., Rent, Grocery, Travel). Provides a high-level view of spending areas. Each Category maps to specific Sub-categories defined below."
    unique_values: ["Investment", "Rent", "Travel", "Restaurant", "Insurance Premium", "Household", "Connectivity", "Waste", "Grocery", "Beauty", "Shopping", "Health", "Utilities", "Gifts & Donations", "Entertainment", "Education"]
    constraints: "Not Null. Value must be one of the predefined categories."
    mapping: # Explicit mapping from expense_metadata.json
        Investment: ["SIP", "Mutual Funds", "Stocks", "FD/RD"]
        Rent: ["House Rent"]
        Travel: ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"]
        Restaurant: ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"]
        Insurance Premium: ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"]
        Household: ["Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning", "Pest Control", "Bike Maintenance", "Car Maintenance", "Furniture", "Kitchen Tools", "Ironing", "Maid"]
        Connectivity: ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"]
        Waste: ["Smoke", "Alcohol"]
        Grocery: ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"]
        Beauty: ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare"] # Removed duplicate Salon
        Shopping: ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"]
        Health: ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"]
        Utilities: ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"]
        Gifts & Donations: ["Family", "Friends", "Charity", "Temple"]
        Entertainment: ["Movies", "Concerts", "Games"]
        Education: ["Online Courses", "Books", "Workshops"]
    purpose_for_llm: |
        Primary column for high-level expense analysis.
        Use this when the user asks about:
        - General spending types (e.g., 'How much on Travel?').
        - Broad overviews (e.g., 'Show my spending breakdown', 'Top spending categories').
        - Comparing major areas (e.g., 'Compare Grocery vs Restaurant spending').
        - Queries about 'main expenses' or 'overall spending'.
        - Use the 'mapping' above to know valid sub-categories for a given category.

  - name: sub_category
    data_type: TEXT
    description: "Detailed classification within a Category (e.g., within 'Travel', sub-categories are 'Cab', 'Flight'). Provides finer granularity. Value MUST belong to the list associated with the transaction's 'category' in the 'category' column mapping."
    example_values: ["SIP", "House Rent", "Cab", "Dine-in", "Life Insurance", "Electricity Bill", "Airtel WiFi", "Smoke", "BigBasket", "Amazon", "Salon", "Doctor Visit", "Gas Cylinder", "Family", "Movies", "Online Courses"]
    constraints: "Can be Null/Empty if a Category has no Sub-categories (e.g., Rent). Value must correspond to the selected Category based on the predefined mapping in the 'category' column."
    purpose_for_llm: |
        Use for detailed analysis *within* a category or when specific items are mentioned.
        Prioritize using this column when the query includes terms like:
        - Specific types: 'Flights', 'SIP', 'Maid Salary', 'BigBasket', 'Netflix', 'ULIP'.
        - More detail than category: 'How much did we spend on cabs?', 'Track mutual fund investments'.
        - Ambiguity Resolution:
            - For 'Electricity Bill' payments, always use `sub_category = 'Electricity Bill'` (under `category = 'Household'`). Avoid `Utilities.Electricity` for bill payments.
            - If query mentions 'Amazon', check context. If 'Amazon groceries', use `category = 'Grocery'` AND `sub_category = 'Amazon'`. If 'Amazon shopping', use `category = 'Shopping'` AND `sub_category = 'Amazon'`. If just 'Amazon', consider filtering `WHERE sub_category = 'Amazon'` across both categories or ask for clarification.
            - For investment details (SIP, Mutual Funds etc.), use the relevant sub_category under `category = 'Investment'`.
        - Confirm the `sub_category` queried is valid for the implied or stated `category` using the mapping in the 'category' column definition.

  - name: type
    data_type: TEXT
    description: "User-provided free-text description of the specific transaction item or purpose (e.g., 'Lunch with colleagues', 'Monthly SIP deduction', 'Groceries for the week', 'Flight tickets BLR-DEL'). Can be very specific but inconsistent."
    example_values: ["Monthly House Rent Payment", "Monthly Maid Salary", "Meat/Fish Purchase", "FK Quick Groceries", "Lunch Parcel", "IRCTC Booking - Home", "Mixer Grinder", "Uber to Airport"]
    constraints: "Free text, max length approx 60 chars. Can be Null/Empty."
    purpose_for_llm: |
        Use ONLY for identifying very specific purchases when category/sub-category are too broad OR when the user provides a specific description.
        Examples:
        - 'Find the transaction for the Mixer grinder purchase'. -> `WHERE type LIKE '%Mixer grinder%'`
        - 'What was that expense description containing "Airport"?' -> `WHERE type LIKE '%Airport%'`
        - Less reliable for aggregation (SUM, AVG) due to free-text nature. Use category/sub-category for aggregation whenever possible.

  - name: user
    data_type: TEXT
    description: "The person who owns the account used for the transaction. Automatically derived from the 'account' based on a fixed mapping."
    unique_values: ["Anirban", "Puspita"]
    constraints: "Not Null. Value is strictly determined by the 'account' used, according to the mapping defined in the 'relationships' section or the 'account' column definition."
    purpose_for_llm: |
        Use for filtering or comparing expenses made by Anirban vs. Puspita. Essential for user-specific queries (e.g., 'Show my spending', 'Who spent more last month?', 'Puspita's travel costs').
        This value is derived from the 'account' column via the following fixed mapping:
        - 'Anirban-SBI' -> 'Anirban'
        - 'Anirban-ICICI' -> 'Anirban'
        - 'Puspita-SBI' -> 'Puspita'
        - 'Puspita-Bandhan' -> 'Puspita'
        Queries filtering by both user and account must be consistent with this mapping.

  - name: amount
    data_type: REAL # Or NUMERIC, DECIMAL depending on SQLite specifics for currency
    description: "The monetary value of the transaction in Indian Rupees (INR)."
    example_values: [30000.00, 2500.0, 534.04, 1409.08, 100.0]
    constraints: "Not Null. Must be a positive number."
    purpose_for_llm: |
        The primary measure of spending value.
        Use for:
        - Calculating totals, averages, sums (e.g., 'Total spend', 'Average restaurant bill').
        - Finding minimum/maximum expenses (e.g., 'Largest expense this month').
        - Filtering by value (e.g., 'transactions over 1000 INR', 'show expenses less than 50 INR'). Use operators like >, <, >=, <=.
        - Answering queries about 'high value', 'low value', or 'expensive' items by applying appropriate amount filters.
"""

File: expense_metadata.json
Location: metadata\expense_metadata.json
Summary: The file outlines a transaction record format, including a date field and account options for Anirban and Puspita. It categorizes expenses into areas such as Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
Code: """
{
    "Date": "Date of the transaction (format: YYYY-MM-DD)",
    "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],
	"categories": {
        "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
        "Rent": ["House Rent"],
        "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
        "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
        "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
        "Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ],
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
        "Waste": ["Smoke", "Alcohol"],
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
        "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare"],
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
        "Entertainment": ["Movies", "Concerts", "Games"],
        "Education": ["Online Courses", "Books", "Workshops"]
	},
    "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
    "Type": "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
    "Amount": "INR value of the transaction"
}
"""

File: agentic_ds_app_prep.txt
Location: reference\agentic_ds_app_prep.txt
Summary: The file outlines a preliminary step for implementing agentic AI, which involves generating additional data similar to a sample CSV file. The data spans from January 1, 2023, to April 20, 2025, and includes specific columns such as date, account, category, transaction type, user, and amount, with detailed formatting and content guidelines.
Code: """
## THINGS TO DO BEFORE AGENTIC AI IMPLEMENTATION

STEP 1: GENERATE MORE DATA
 - Generate more data, similar to the sample dummy_expenses.csv, from 2023.01.01 - 2025.04.20 (current date). Important considerations for data generation:
	- SUPER IMPORTANT: columns: 
	1. date: dd-mm-yyyy	
	2. year: yyyy	
	3. month: yyyy-mm	
	4. week: 2021-W01 to latest, 2025-xxx	
	5. day_of_week: {Monday, Tuesday,... Sunday} according to date, refer calendar
	6. account: "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],	
	7. category: refer below and metadata
	8. sub_category: refer below and metadata	
	9. type: "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
	10. user:	 "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
	11. amount:"INR value of the transaction, max 50000"

	- IMPORTANT: Generate data accoording to day to day expenditure values in Bangalore, India for all categories to mimic real world scenario
	- Each month cannot have total spend amount more than inr 120000 and less than 60000
	- Each month cannot have more than 100 rows
	- Total rows -less than 2500 
	- IMPORTANT: Spends MUST adhere to the category-subcategory mapping:
		categories = {
    "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
    "Rent": ["House Rent"],
    "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
    "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
    "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
    "Household": [
        "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
        "Pest Control", "Bike Maintenance", "Car Maintenance", 
        "Furniture", "Kitchen Tools", "Ironing", "Maid"
    ],
    "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
    "Waste": ["Smoke", "Alcohol"],
    "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
    "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare", "Salon"],
    "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
    "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
    "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
    "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
    "Entertainment": ["Movies", "Concerts", "Games"],
    "Education": ["Online Courses", "Books", "Workshops"]
}
	- IMPORTANT: I have updated the categories and subcategories. Some additional information: there are only 2 users: 'Anirban' and 'Puspita'. Anirban has the following bank accouts: 'Anirban-SBI' and 'Anirban-ICICI'.  Puspita has the following bank accouts: 'Puspita-SBI' and 'Puspita-Bandhan'. I want to keep the app as simple as possible, so i am thinking of creating a database (sqlite3 / csv) with the following columns: 
	'Date': Date of transaction, 
	'Account': One of the 4 accounts for me and my wife mentioned above, 
	'Category': from the categories dictionary mentioned above, 
	'Sub-category': from the categories dictionary mentioned above, 
	'Type': Free text, we need to be able to enter it in the steamlit frontend, 
	'User': One of the 2 values: 'Anirban', "Puspita" 
	'Amount': amount of transaction.
	- IMPORTANT: "Currency Format: Just plain numbers, keep it simple!
		Frequency of Transactions: minimum: 2(atleat 1 transaction per user), maximum: 20
		Expense Bias: Should we simulate more transactions from a specific account or category (e.g., more grocery or restaurant spends)? - Grocery and household are the biggest ones, but they are less than rent. House rent: once a month, fixed, 30000 (Anirban-ICICI). Maid: once a month, fixed, 2500 (Puspita-SBI). I pay house rent, wife pays maid salary. Puspita uses Puspita-Bandhan only for Travel and beauty categories. For me, most of the daily expenses are from Anirban-ICICI, with some from Anirban-SBI.
		Include recurring transactions? Like SIPs, rent, etc. on specific days?SIP: once a month, 3000, fixed. ULIP: once a month, 4000. fixed I pay both from Anirban-ICICI.
		match the type to category and sub category. For example, if: Category - household, Subcategory - Ironing, then type has to be ironing. if the cat - Travel and subcat -train, the type has to be something like: bangalore-mysore vande bharat, type can't be 'lab test', In summary, the type has to make sense for category and subcategory. Also, Puspita uses her bandhan for travel and rarely something else. In travel also, she will mainly use it to book train / flight tickets, not pay  parking fees, I pay that. Please generate data accordingly.
		
	- IMPORTANT: Spend trends, fixed values and behaviour
		- Fixed spends: "Investment": ["SIP" - 3000, "Mutual Funds" - 0 (None for now), "Stocks" - 0 (None for now), "FD/RD"0 (None for now)],
        "Rent": ["House Rent" - inr 30000] - all once a month, with fixed values
		"Insurance Premium": ["Life Insurance" - 55000 twice a year on 20th march and 20th september, "ULIP" - 4000 every month between 20th - 25th, "Health Insurance" - lets say 1200 every month between 20th - 25th, "Vehicle Insurance" - once a year, 0 for now]
		"Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ], - many have 2 month (Electricity bill) or 1 month (Maid) cycles or ad hoc costs (everything else in "Household") 
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"], - many have 6 month (Airtel WiFi) or 3 month ( "Jio Recharge", "Airtel Mobile") cycles or ad hoc costs (everything else in "Connectivity") 
		- Category wise spends: 
		"Waste": ["Smoke", "Alcohol"], - ad hoc, a small percentage of total, variable weekly and monthly, alcohol max once a month
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"], - ad hoc, concentrated on the first week of the month (after salary, salary is not tracked in the data), smaller spends dotted throughout the month
        "Beauty": ["Nykaa", "Meesho", "Purplle", "Salon", "Makeup", "Skincare", "Salon"],- ad hoc, spends dotted throughout the month
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"], - ad hoc, concentrated on the first week of the month (after salary, salary is not tracked in the data), smaller spends dotted throughout the month
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],- ad hoc, spends dotted throughout the month
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],- electricity bill - 2 month cycle, gas cylinder - 2 month cycle, rest ad hoc, spends dotted throughout the month
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],ad hoc, small amounts, spends dotted throughout the month
        "Entertainment": ["Movies", "Concerts", "Games"],ad hoc, small amounts, spends dotted throughout the month
        "Education": ["Online Courses", "Books", "Workshops"] ad hoc, small amounts, spends dotted throughout the month
 

		
		
		
		
		
		
		
		
		

"""

File: data_analysis.ipynb
Location: reference\data_analysis.ipynb
Summary: The file outlines an Exploratory Data Analysis (EDA) process for personal finance data, focusing on validating the structure and realism of the dataset `dummy_expenses_generated.csv` for AI/ML tasks. It mentions data sources and references, and imports libraries like pandas, numpy, and plotly for analysis and visualization.
Code: """
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exploratory Data Analysis (EDA) for Personal Finance Data (v2)\n",
    "\n",
    "**Objective:** Analyze the generated expense data (`dummy_expenses_generated.csv`) to validate its structure, adherence to generation rules, realism, and suitability for downstream AI/ML tasks (Phase 2 Assistant). Plots will be displayed inline.\n",
    "\n",
    "**Data Source:** `../dummy_expenses_generated.csv` (Relative path from `reference/` to project root)\n",
    "**Ruleset Reference:** `../sample_data_generation.csv`\n",
    "**Metadata Reference:** `../expense_metadata.json`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "fcb1b6c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "import json\n",
    "from pathlib import Path\n",
    "import datetime\n",
    "import logging\n",
    "import os # Import os for directory creation\n",
    "from typing import Optional, Dict, Any # For type hints\n",
    "\n",
    "# Configure logging for analysis insights\n",
    "logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "86a4f331",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Setup Paths and Create Output Directory ---\n",
    "\n",
    "# Define file paths relative to the notebook location (reference/)\n",
    "NOTEBOOK_DIR = Path().resolve() # Should be the reference folder when running notebook there\n",
    "PROJECT_ROOT = NOTEBOOK_DIR.parent\n",
    "DATA_FILE = PROJECT_ROOT / \"dummy_expenses_generated.csv\"\n",
    "RULES_FILE = PROJECT_ROOT / \"sample_data_generation.csv\"\n",
    "METADATA_FILE = PROJECT_ROOT / \"expense_metadata.json\"\n",
    "\n",
    "# Define image output directory (though we won't save by default now)\n",
    "IMG_DIR = NOTEBOOK_DIR / \"img\"\n",
    "\n",
    "# Optionally ensure the image directory exists if you uncomment saving later\n",
    "# try:\n",
    "#     os.makedirs(IMG_DIR, exist_ok=True)\n",
    "#     logging.info(f\"Image output directory exists or created: {IMG_DIR}\")\n",
    "# except OSError as e:\n",
    "#     logging.error(f\"Could not create image directory {IMG_DIR}: {e}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f596d3c0",
   "metadata": {},
   "source": [
    "## Helper Function: Load Rules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "2a2675ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Helper Function: Load Rules (Moved here to be defined before use) ---\n",
    "def load_rules(filepath: Path) -> Optional[pd.DataFrame]:\n",
    "    \"\"\"Loads and preprocesses the ruleset CSV.\"\"\"\n",
    "    if not filepath.exists():\n",
    "        logging.error(f\"Rules file not found: {filepath}\")\n",
    "        return None\n",
    "    try:\n",
    "        df_rules = pd.read_csv(filepath)\n",
    "        # Clean column names if needed (assuming they are already clean based on previous step)\n",
    "        df_rules.columns = [col.strip() for col in df_rules.columns]\n",
    "        # Split the valid types string into a list\n",
    "        # Handle potential errors if the column doesn't exist or has NaNs\n",
    "        if 'Valid-expense-types' in df_rules.columns:\n",
    "             df_rules['Valid-expense-types'] = df_rules['Valid-expense-types'].fillna('').astype(str).str.split('|')\n",
    "        else:\n",
    "             logging.warning(\"'Valid-expense-types' column not found in rules file.\")\n",
    "             df_rules['Valid-expense-types'] = [[] for _ in range(len(df_rules))] # Add empty list\n",
    "\n",
    "        # Convert amount/count columns to numeric, coercing errors\n",
    "        for col in ['Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']:\n",
    "            if col in df_rules.columns:\n",
    "                df_rules[col] = pd.to_numeric(df_rules[col], errors='coerce')\n",
    "            else:\n",
    "                logging.warning(f\"Column '{col}' not found in rules file.\")\n",
    "                df_rules[col] = np.nan # Add column with NaN if missing\n",
    "\n",
    "        # Fill missing Max-times with a default (e.g., 5) or handle based on frequency\n",
    "        df_rules['Max-times-per-month'].fillna(5, inplace=True)\n",
    "        df_rules['Max-times-per-month'] = df_rules['Max-times-per-month'].astype(int)\n",
    "\n",
    "        # Define critical columns needed from rules file\n",
    "        critical_rule_cols = ['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency', 'Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']\n",
    "        missing_critical = [col for col in critical_rule_cols if col not in df_rules.columns]\n",
    "        if missing_critical:\n",
    "            logging.error(f\"Rules file is missing critical columns: {missing_critical}\")\n",
    "            return None\n",
    "\n",
    "        # Drop rows with missing critical numeric info after conversion attempts\n",
    "        df_rules.dropna(subset=['Min-expenses-amount', 'Max-expenses-amount'], inplace=True)\n",
    "        # Drop rows with missing critical categorical info\n",
    "        df_rules.dropna(subset=['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency'], inplace=True)\n",
    "\n",
    "        logging.info(f\"Loaded and preprocessed {len(df_rules)} rules from {filepath}\")\n",
    "        return df_rules\n",
    "    except Exception as e:\n",
    "        logging.error(f\"Error loading or processing rules file {filepath}: {e}\", exc_info=True)\n",
    "        return None"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e32c188",
   "metadata": {},
   "source": [
    "## 1. Load Data and Basic Checks\n",
    "\n",
    "Load the generated CSV, parse dates correctly using the 'dd-mm-yyyy' format, check basic info, data types, and null values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "55eae2b5",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Attempting to load data from: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\dummy_expenses_generated.csv\n",
      "INFO: Reference ruleset: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\sample_data_generation.csv\n",
      "INFO: Reference metadata: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\expense_metadata.json\n",
      "INFO: Successfully loaded E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\dummy_expenses_generated.csv. Shape: (951, 11)\n",
      "INFO: Successfully loaded metadata from E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\expense_metadata.json\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 951 rows.\n"
     ]
    }
   ],
   "source": [
    "logging.info(f\"Attempting to load data from: {DATA_FILE}\")\n",
    "logging.info(f\"Reference ruleset: {RULES_FILE}\")\n",
    "logging.info(f\"Reference metadata: {METADATA_FILE}\")\n",
    "\n",
    "# Load the generated data\n",
    "try:\n",
    "    df = pd.read_csv(DATA_FILE)\n",
    "    logging.info(f\"Successfully loaded {DATA_FILE}. Shape: {df.shape}\")\n",
    "    print(f\"Loaded {len(df)} rows.\")\n",
    "except FileNotFoundError:\n",
    "    logging.error(f\"Data file not found at {DATA_FILE}. Please ensure it's generated in the project root.\")\n",
    "    df = pd.DataFrame() # Create empty df to avoid downstream errors\n",
    "except Exception as e:\n",
    "    logging.error(f\"Error loading data CSV {DATA_FILE}: {e}\", exc_info=True)\n",
    "    df = pd.DataFrame()\n",
    "\n",
    "# Load metadata for validation checks\n",
    "try:\n",
    "    with open(METADATA_FILE, 'r') as f:\n",
    "        metadata = json.load(f)\n",
    "    logging.info(f\"Successfully loaded metadata from {METADATA_FILE}\")\n",
    "except Exception as e:\n",
    "    logging.error(f\"Could not load metadata file {METADATA_FILE}: {e}\")\n",
    "    metadata = {} # Assign empty dict if load fails"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "5d905392",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Converted 'date' column to datetime objects ('date_dt').\n",
      "INFO: All dates successfully parsed.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Data Info ---\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 951 entries, 0 to 950\n",
      "Data columns (total 11 columns):\n",
      " #   Column        Non-Null Count  Dtype  \n",
      "---  ------        --------------  -----  \n",
      " 0   date          951 non-null    object \n",
      " 1   year          951 non-null    int64  \n",
      " 2   month         951 non-null    object \n",
      " 3   week          951 non-null    object \n",
      " 4   day_of_week   951 non-null    object \n",
      " 5   account       951 non-null    object \n",
      " 6   category      951 non-null    object \n",
      " 7   sub_category  951 non-null    object \n",
      " 8   type          951 non-null    object \n",
      " 9   user          951 non-null    object \n",
      " 10  amount        951 non-null    float64\n",
      "dtypes: float64(1), int64(1), object(9)\n",
      "memory usage: 81.9+ KB\n",
      "\n",
      "--- Date Conversion ---\n"
     ]
    }
   ],
   "source": [
    "# Display basic information if data loaded\n",
    "if not df.empty:\n",
    "    print(\"\\n--- Data Info ---\")\n",
    "    df.info()\n",
    "\n",
    "    # Convert 'date' column from dd-mm-yyyy string to datetime objects for analysis\n",
    "    print(\"\\n--- Date Conversion ---\")\n",
    "    try:\n",
    "        # Explicitly use dayfirst=True or format='%d-%m-%Y'\n",
    "        df['date_dt'] = pd.to_datetime(df['date'], format='%d-%m-%Y', errors='coerce')\n",
    "        logging.info(\"Converted 'date' column to datetime objects ('date_dt').\")\n",
    "\n",
    "        # Check for any conversion errors\n",
    "        null_dates = df['date_dt'].isnull().sum()\n",
    "        if null_dates > 0:\n",
    "            logging.warning(f\"Found {null_dates} rows with invalid date formats that couldn't be parsed to 'dd-mm-yyyy'.\")\n",
    "            # Optional: Display problematic rows\n",
    "            # print(\"\\nRows with date parsing errors:\")\n",
    "            # print(df[df['date_dt'].isnull()]['date'])\n",
    "            df.dropna(subset=['date_dt'], inplace=True) # Remove rows with invalid dates for analysis\n",
    "            logging.info(f\"Removed rows with invalid dates. New shape: {df.shape}\")\n",
    "        else:\n",
    "            logging.info(\"All dates successfully parsed.\")\n",
    "\n",
    "    except KeyError:\n",
    "        logging.error(\"Column 'date' not found in the CSV.\")\n",
    "    except Exception as e:\n",
    "        logging.error(f\"Error during date conversion: {e}\", exc_info=True)\n",
    "\n",
    "else:\n",
    "    print(\"DataFrame is empty. Cannot perform further analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2692605",
   "metadata": {},
   "source": [
    "## 2. Data Range and Null Value Check\n",
    "\n",
    "Verify the date range covers the expected period and check for unexpected missing values in core columns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "77c097ac",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: Data ends earlier (2025-04-15) than expected (2025-04-20).\n",
      "INFO: No unexpected null values found in critical columns (sub_category/type might have blanks/nulls).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Date Range Check ---\n",
      "Data spans from: 2023-01-01 to 2025-04-15\n",
      "\n",
      "--- Null Value Check ---\n",
      "Columns with Null/NaN values:\n",
      "Series([], dtype: int64)\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns:\n",
    "    min_date = df['date_dt'].min()\n",
    "    max_date = df['date_dt'].max()\n",
    "    print(f\"\\n--- Date Range Check ---\")\n",
    "    print(f\"Data spans from: {min_date.strftime('%Y-%m-%d')} to {max_date.strftime('%Y-%m-%d')}\")\n",
    "\n",
    "    expected_start = datetime.datetime(2023, 1, 1)\n",
    "    expected_end = datetime.datetime(2025, 4, 20)\n",
    "\n",
    "    if min_date.date() > expected_start.date():\n",
    "        logging.warning(f\"Data starts later ({min_date.date()}) than expected ({expected_start.date()}).\")\n",
    "    if max_date.date() < expected_end.date():\n",
    "        logging.warning(f\"Data ends earlier ({max_date.date()}) than expected ({expected_end.date()}).\")\n",
    "\n",
    "    print(\"\\n--- Null Value Check ---\")\n",
    "    null_counts = df.isnull().sum()\n",
    "    print(\"Columns with Null/NaN values:\")\n",
    "    print(null_counts[null_counts > 0]) # Only show columns with nulls\n",
    "\n",
    "    # Check critical columns - adjust if 'sub_category' or 'type' can legitimately be empty strings instead of NaN\n",
    "    critical_cols = ['date', 'year', 'month', 'week', 'day_of_week', 'account', 'category', 'user', 'amount', 'date_dt']\n",
    "    unexpected_nulls = null_counts.reindex(critical_cols, fill_value=0).sum() > 0 # Use reindex to handle missing cols safely\n",
    "\n",
    "    if unexpected_nulls:\n",
    "        logging.error(\"UNEXPECTED null values found in critical columns! Review data generation.\")\n",
    "    else:\n",
    "        logging.info(\"No unexpected null values found in critical columns (sub_category/type might have blanks/nulls).\")\n",
    "else:\n",
    "     print(\"Skipping range/null checks as DataFrame is empty or date conversion failed.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cff3bca3",
   "metadata": {},
   "source": [
    "## 3. Constraint Validation: Row Counts\n",
    "\n",
    "Check if the number of transactions per month adheres to the `MONTHLY_MAX_ROWS = 100` limit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "fac25dab",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (YYYY-MM)=%{x}<br>Number of Transactions=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "LyUjGyMaHScpJx8iHhwgGh0iIhwmJiElHigrHw==",
          "dtype": "i1"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "annotations": [
         {
          "showarrow": false,
          "text": "Max Limit (100)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 100,
          "yanchor": "bottom",
          "yref": "y"
         }
        ],
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "shapes": [
         {
          "line": {
           "color": "red",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 100,
          "y1": 100,
          "yref": "y"
         }
        ],
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Number of Transactions per Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Number of Transactions"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Monthly row counts are within the limit (<= 100).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Row Count Validation ---\n",
      "Maximum rows found in a single month: 47\n",
      "Total rows generated: 951\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    monthly_row_counts = df.groupby('month').size().reset_index(name='transaction_count')\n",
    "\n",
    "    fig_row_counts = px.bar(monthly_row_counts, x='month', y='transaction_count',\n",
    "                            title='Number of Transactions per Month',\n",
    "                            labels={'month': 'Month (YYYY-MM)', 'transaction_count': 'Number of Transactions'},\n",
    "                            height=400)\n",
    "    fig_row_counts.add_hline(y=100, line_dash=\"dash\", line_color=\"red\", annotation_text=\"Max Limit (100)\")\n",
    "    fig_row_counts.update_layout(xaxis_tickangle=-45)\n",
    "    fig_row_counts.show() # Display inline\n",
    "\n",
    "    # Save image (Commented out)\n",
    "    # try:\n",
    "    #     img_path = IMG_DIR / \"monthly_transaction_counts.png\"\n",
    "    #     fig_row_counts.write_image(img_path)\n",
    "    #     logging.info(f\"Saved monthly row counts plot to {img_path}\")\n",
    "    # except Exception as e:\n",
    "    #     logging.error(f\"Failed to save monthly row counts plot: {e}\")\n",
    "\n",
    "\n",
    "    # Discrepancy Check\n",
    "    max_rows_in_month = monthly_row_counts['transaction_count'].max()\n",
    "    print(f\"\\n--- Row Count Validation ---\")\n",
    "    print(f\"Maximum rows found in a single month: {max_rows_in_month}\")\n",
    "    if max_rows_in_month > 100:\n",
    "        exceeding_months = monthly_row_counts[monthly_row_counts['transaction_count'] > 100]['month'].tolist()\n",
    "        logging.error(f\"Monthly row count limit (>100) EXCEEDED! Max found: {max_rows_in_month}. Check months: {exceeding_months}\")\n",
    "    else:\n",
    "        logging.info(\"Monthly row counts are within the limit (<= 100).\")\n",
    "\n",
    "    total_rows = df.shape[0]\n",
    "    print(f\"Total rows generated: {total_rows}\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping row count validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e3fde44",
   "metadata": {},
   "source": [
    "## 4. Constraint Validation: Monthly Totals\n",
    "\n",
    "Verify if the total spending per month falls within the target range of ₹60,000 - ₹120,000."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "48fd2dc7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (YYYY-MM)=%{x}<br>Total Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "16NwPVrD/kCkcD0KD/j+QM3MzMxcKgZBCtejcLkA/0D2KFyPsrH+QPYoXI/+Wv9ASOF6FD4m/0CamZmZ2V7/QFK4HoUzHgZBhetRuE4C/0CamZmZTTb/QIXrUbhWxf5A61G4HksjAEHsUbgeFU7/QD4K16MyYQZBzczMzDzO/0AfhetRWNz+QNejcD22GP9AH4XrURwg/0DhehSuI7P9QBSuR+EaTQZB9ihcj96d/UAfhetRhCj/QOtRuB4ZPf5AAAAAABQV/0BxPQrXJxb+QEjhehTiCwZBj8L1KKS0/kA=",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "annotations": [
         {
          "showarrow": false,
          "text": "Min Target (60k)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 60000,
          "yanchor": "bottom",
          "yref": "y"
         },
         {
          "showarrow": false,
          "text": "Max Target (120k)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 120000,
          "yanchor": "bottom",
          "yref": "y"
         }
        ],
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "shapes": [
         {
          "line": {
           "color": "orange",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 60000,
          "y1": 60000,
          "yref": "y"
         },
         {
          "line": {
           "color": "red",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 120000,
          "y1": 120000,
          "yref": "y"
         }
        ],
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Total Spending per Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "tickprefix": "₹",
         "title": {
          "text": "Total Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: All monthly totals meet or exceed the minimum target (₹60,000).\n",
      "ERROR: 22 months found SIGNIFICANTLY ABOVE ₹120,000 target (>5% overshoot): ['2023-01', '2023-02', '2023-03', '2023-04', '2023-06', '2023-07', '2023-08', '2023-09', '2023-10', '2023-11', '2023-12', '2024-01', '2024-02', '2024-03', '2024-04', '2024-05', '2024-06', '2024-07', '2024-09', '2024-11', '2025-01', '2025-03']\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Monthly Total Validation ---\n",
      "Minimum monthly total found: ₹121,309.91\n",
      "Maximum monthly total found: ₹183,334.33\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns and 'amount' in df.columns:\n",
    "    monthly_totals = df.groupby('month')['amount'].sum().reset_index(name='total_amount')\n",
    "\n",
    "    fig_monthly_totals = px.bar(monthly_totals, x='month', y='total_amount',\n",
    "                                title='Total Spending per Month',\n",
    "                                labels={'month': 'Month (YYYY-MM)', 'total_amount': 'Total Amount (INR)'},\n",
    "                                height=400)\n",
    "    fig_monthly_totals.add_hline(y=60000, line_dash=\"dash\", line_color=\"orange\", annotation_text=\"Min Target (60k)\")\n",
    "    fig_monthly_totals.add_hline(y=120000, line_dash=\"dash\", line_color=\"red\", annotation_text=\"Max Target (120k)\")\n",
    "    fig_monthly_totals.update_layout(yaxis_tickprefix=\"₹\", xaxis_tickangle=-45)\n",
    "    fig_monthly_totals.show() # Display inline\n",
    "\n",
    "    # Save image (Commented out)\n",
    "    # try:\n",
    "    #     img_path = IMG_DIR / \"monthly_total_spending.png\"\n",
    "    #     fig_monthly_totals.write_image(img_path)\n",
    "    #     logging.info(f\"Saved monthly total spending plot to {img_path}\")\n",
    "    # except Exception as e:\n",
    "    #     logging.error(f\"Failed to save monthly total spending plot: {e}\")\n",
    "\n",
    "    # Discrepancy Check\n",
    "    min_monthly_total = monthly_totals['total_amount'].min()\n",
    "    max_monthly_total = monthly_totals['total_amount'].max()\n",
    "    months_below_min = monthly_totals[monthly_totals['total_amount'] < 60000]\n",
    "    months_above_max = monthly_totals[monthly_totals['total_amount'] > 120000]\n",
    "\n",
    "    print(f\"\\n--- Monthly Total Validation ---\")\n",
    "    print(f\"Minimum monthly total found: ₹{min_monthly_total:,.2f}\")\n",
    "    print(f\"Maximum monthly total found: ₹{max_monthly_total:,.2f}\")\n",
    "\n",
    "    if not months_below_min.empty:\n",
    "        logging.warning(f\"{len(months_below_min)} months found BELOW ₹60,000 target: {months_below_min['month'].tolist()}\")\n",
    "    else:\n",
    "        logging.info(\"All monthly totals meet or exceed the minimum target (₹60,000).\")\n",
    "\n",
    "    if not months_above_max.empty:\n",
    "        # Allow slightly above (e.g. 5%) due to fixed costs potentially pushing it over\n",
    "        months_significantly_above_max = monthly_totals[monthly_totals['total_amount'] > 120000 * 1.05]\n",
    "        if not months_significantly_above_max.empty:\n",
    "            logging.error(f\"{len(months_significantly_above_max)} months found SIGNIFICANTLY ABOVE ₹120,000 target (>5% overshoot): {months_significantly_above_max['month'].tolist()}\")\n",
    "        else:\n",
    "            logging.warning(f\"{len(months_above_max)} months found slightly above ₹120,000 target (<=5% overshoot - check if acceptable): {months_above_max['month'].tolist()}\")\n",
    "    else:\n",
    "        logging.info(\"All monthly totals are within or acceptably close to the maximum target (<= ₹120,000).\")\n",
    "else:\n",
    "    print(\"Skipping monthly total validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83bfb2b9",
   "metadata": {},
   "source": [
    "## 5. Mapping Validation: User vs. Account\n",
    "\n",
    "Ensure that the `user` column correctly corresponds to the `account` column based on the metadata rules."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "3965f380",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- User-Account Mapping Validation ---\n",
      "Observed User-Account Combinations (Transaction Counts):\n",
      "account  Anirban-ICICI  Anirban-SBI  Puspita-Bandhan  Puspita-SBI\n",
      "user                                                             \n",
      "Anirban            412          101                0            0\n",
      "Puspita              0            0               62          376\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0d0d09cefa9a4d088150bc1871e4b369",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Checking User-Account:   0%|          | 0/951 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: User-Account mapping appears consistent with metadata for all transactions.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and metadata and 'User' in metadata:\n",
    "    print(\"\\n--- User-Account Mapping Validation ---\")\n",
    "    # Display counts of each combination\n",
    "    user_account_crosstab = pd.crosstab(df['user'], df['account'])\n",
    "    print(\"Observed User-Account Combinations (Transaction Counts):\")\n",
    "    print(user_account_crosstab)\n",
    "\n",
    "    # Discrepancy Check against metadata\n",
    "    valid_map = metadata.get(\"User\", {})\n",
    "    invalid_combos_found = False\n",
    "    checked_accounts = set()\n",
    "\n",
    "    # Use tqdm if iterating over many rows, otherwise direct iteration is fine\n",
    "    from tqdm.notebook import tqdm # Use notebook version\n",
    "    for index, row in tqdm(df.iterrows(), total=df.shape[0], desc=\"Checking User-Account\"):\n",
    "    # for index, row in df.iterrows(): # Direct iteration for <2500 rows is okay\n",
    "        account = row['account']\n",
    "        user = row['user']\n",
    "        # Avoid re-checking same account if metadata is missing\n",
    "        if account in checked_accounts: continue\n",
    "\n",
    "        expected_user = valid_map.get(account)\n",
    "\n",
    "        if expected_user is None:\n",
    "            logging.error(f\"FATAL: Account '{account}' found in data but MISSING in metadata User map! Cannot validate.\")\n",
    "            invalid_combos_found = True\n",
    "            checked_accounts.add(account) # Mark as checked to avoid repeating error\n",
    "        elif user != expected_user:\n",
    "            logging.error(f\"User-Account MISMATCH! Account: '{account}', Expected User: '{expected_user}', Found User: '{user}'. Row index: {index}\")\n",
    "            invalid_combos_found = True\n",
    "            # Don't add to checked_accounts here, allow finding more mismatches for same account if they exist\n",
    "\n",
    "    if not invalid_combos_found:\n",
    "        logging.info(\"User-Account mapping appears consistent with metadata for all transactions.\")\n",
    "    else:\n",
    "        logging.error(\"CRITICAL User-Account mapping inconsistencies detected! Review generation logic or metadata.\")\n",
    "else:\n",
    "    print(\"Skipping User-Account validation (Data or Metadata missing/incomplete).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dddcbe0c",
   "metadata": {},
   "source": [
    "## 6. Mapping Validation: Category vs. Sub-Category\n",
    "\n",
    "Check if all non-blank `sub_category` values are valid for their corresponding `category` based on the metadata."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "19e899df",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Category-SubCategory Mapping Validation ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "08c39562969e4463b6d692023b8d59c3",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Checking Cat-SubCat:   0%|          | 0/951 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Category-SubCategory mapping appears consistent with metadata for all non-blank sub-categories.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and metadata and 'categories' in metadata:\n",
    "    print(\"\\n--- Category-SubCategory Mapping Validation ---\")\n",
    "    category_map = metadata.get(\"categories\", {})\n",
    "    invalid_subcats_found = False\n",
    "    invalid_details = [] # Store details of invalid rows\n",
    "\n",
    "    from tqdm.notebook import tqdm\n",
    "    for index, row in tqdm(df.iterrows(), total=df.shape[0], desc=\"Checking Cat-SubCat\"):\n",
    "    # for index, row in df.iterrows():\n",
    "        category = row['category']\n",
    "        sub_category = row['sub_category']\n",
    "\n",
    "        # Only validate if sub_category is present (not NaN or empty string)\n",
    "        if pd.notna(sub_category) and sub_category != \"\":\n",
    "            valid_subcats = category_map.get(category)\n",
    "\n",
    "            if valid_subcats is None:\n",
    "                detail = f\"Category '{category}' (Row {index}) not found in metadata map.\"\n",
    "                if detail not in [d[0] for d in invalid_details]: # Log category error once\n",
    "                    logging.error(detail)\n",
    "                    invalid_details.append((detail, index))\n",
    "                invalid_subcats_found = True\n",
    "            elif sub_category not in valid_subcats:\n",
    "                detail = f\"Invalid Sub-category! Category: '{category}', Found Sub-cat: '{sub_category}'. Valid: {valid_subcats}. Row Index: {index}\"\n",
    "                logging.error(detail)\n",
    "                invalid_details.append((detail, index))\n",
    "                invalid_subcats_found = True\n",
    "\n",
    "    if not invalid_subcats_found:\n",
    "        logging.info(\"Category-SubCategory mapping appears consistent with metadata for all non-blank sub-categories.\")\n",
    "    else:\n",
    "        logging.error(f\"CRITICAL Category-SubCategory mapping inconsistencies detected! Found {len(invalid_details)} issues.\")\n",
    "        # print(\"\\nSample Invalid Details:\")\n",
    "        # for detail, idx in invalid_details[:min(5, len(invalid_details))]:\n",
    "        #     print(f\"- {detail}\")\n",
    "else:\n",
    "    print(\"Skipping Category-SubCategory validation (Data or Metadata missing/incomplete).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1624e291",
   "metadata": {},
   "source": [
    "## 7. Fixed Expense Validation: Rent\n",
    "\n",
    "Check frequency (1/month), amount (30k), payer (Anirban/ICICI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "409a5dfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Rent Validation ---\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Rent transactions appear correct (Amount, Payer, Frequency).\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "month=%{x}<br>count=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQ==",
          "dtype": "i1"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 300,
        "legend": {
         "tracegroupgap": 0
        },
        "showlegend": false,
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Monthly Rent Transaction Count"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "dtick": 1,
         "tickmode": "linear",
         "title": {
          "text": "Count"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Rent Validation ---\")\n",
    "    rent_df = df[(df['category'] == 'Rent') & (df['sub_category'] == 'House Rent')].copy()\n",
    "\n",
    "    if rent_df.empty:\n",
    "        logging.warning(\"No Rent transactions found!\")\n",
    "    else:\n",
    "        valid = True\n",
    "        # Check Amount\n",
    "        if not (rent_df['amount'] == 30000).all():\n",
    "            logging.error(f\"Rent amount incorrect! Found values != 30000: {rent_df[rent_df['amount'] != 30000]['amount'].unique()}\")\n",
    "            valid = False\n",
    "        # Check User/Account\n",
    "        if not ((rent_df['user'] == 'Anirban') & (rent_df['account'] == 'Anirban-ICICI')).all():\n",
    "            logging.error(f\"Rent payer incorrect! Found instances not paid by Anirban/Anirban-ICICI.\")\n",
    "            valid = False\n",
    "        # Check Frequency\n",
    "        rent_monthly_counts = rent_df.groupby('month').size()\n",
    "        if (rent_monthly_counts != 1).any():\n",
    "            logging.error(f\"Rent frequency incorrect! Months with counts != 1: {rent_monthly_counts[rent_monthly_counts != 1].index.tolist()}\")\n",
    "            valid = False\n",
    "\n",
    "        if valid:\n",
    "            logging.info(\"Rent transactions appear correct (Amount, Payer, Frequency).\")\n",
    "\n",
    "        # Visualize counts even if correct\n",
    "        fig_rent_counts = px.bar(rent_monthly_counts.reset_index(name='count'), x='month', y='count', title='Monthly Rent Transaction Count', height=300)\n",
    "        fig_rent_counts.update_layout(yaxis_title='Count', xaxis_title='Month (YYYY-MM)', showlegend=False, yaxis=dict(tickmode='linear', dtick=1))\n",
    "        fig_rent_counts.show() # Display inline\n",
    "        # try: fig_rent_counts.write_image(IMG_DIR / \"rent_monthly_counts.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save rent counts plot: {e}\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping Rent validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "094e3696",
   "metadata": {},
   "source": [
    "## 8. Fixed Expense Validation: SIP & ULIP\n",
    "\n",
    "Check monthly frequency, amounts (SIP=3k, ULIP=4k), and payer (Anirban-ICICI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "e631899a",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: SIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\n",
      "INFO: ULIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- SIP & ULIP Validation ---\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- SIP & ULIP Validation ---\")\n",
    "    sip_df = df[(df['category'] == 'Investment') & (df['sub_category'] == 'SIP')].copy()\n",
    "    ulip_df = df[(df['category'] == 'Insurance Premium') & (df['sub_category'] == 'ULIP')].copy()\n",
    "    valid_sip = True; valid_ulip = True\n",
    "\n",
    "    # --- SIP ---\n",
    "    if sip_df.empty: logging.warning(\"No SIP transactions found!\")\n",
    "    else:\n",
    "        if not (sip_df['amount'] == 3000).all(): logging.error(f\"SIP amount incorrect! Found values != 3000.\"); valid_sip = False\n",
    "        if not ((sip_df['user'] == 'Anirban') & (sip_df['account'] == 'Anirban-ICICI')).all(): logging.error(\"SIP payer incorrect!\"); valid_sip = False\n",
    "        sip_counts = sip_df.groupby('month').size()\n",
    "        if (sip_counts > 1).any(): logging.error(f\"SIP frequency incorrect (>1 per month)!\"); valid_sip = False\n",
    "        # Check for missing months more accurately\n",
    "        all_months_in_data = set(df['month'].unique()) # Get all unique months from the main dataframe\n",
    "        sip_months_found = set(sip_df['month'].unique())\n",
    "        missing_sip_months = all_months_in_data - sip_months_found\n",
    "        if missing_sip_months and valid_sip: logging.warning(f\"SIP seems missing in {len(missing_sip_months)} months: {sorted(list(missing_sip_months))[:5]}...\")\n",
    "\n",
    "        if valid_sip: logging.info(\"SIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\")\n",
    "\n",
    "    # --- ULIP ---\n",
    "    if ulip_df.empty: logging.warning(\"No ULIP transactions found!\")\n",
    "    else:\n",
    "        if not (ulip_df['amount'] == 4000).all(): logging.error(f\"ULIP amount incorrect! Found values != 4000.\"); valid_ulip = False\n",
    "        if not ((ulip_df['user'] == 'Anirban') & (ulip_df['account'] == 'Anirban-ICICI')).all(): logging.error(\"ULIP payer incorrect!\"); valid_ulip = False\n",
    "        ulip_counts = ulip_df.groupby('month').size()\n",
    "        if (ulip_counts > 1).any(): logging.error(f\"ULIP frequency incorrect (>1 per month)!\"); valid_ulip = False\n",
    "        ulip_months_found = set(ulip_df['month'].unique())\n",
    "        missing_ulip_months = all_months_in_data - ulip_months_found\n",
    "        if missing_ulip_months and valid_ulip: logging.warning(f\"ULIP seems missing in {len(missing_ulip_months)} months: {sorted(list(missing_ulip_months))[:5]}...\")\n",
    "\n",
    "        if valid_ulip: logging.info(\"ULIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping SIP/ULIP validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c01f665e",
   "metadata": {},
   "source": [
    "## 9. Fixed Expense Validation: Maid Salary\n",
    "\n",
    "Check monthly frequency (once), amount (₹2500), and payer (Puspita-SBI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "e335ad6d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Maid Salary transactions appear correct.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Maid Salary Validation ---\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Maid Salary Validation ---\")\n",
    "    maid_df = df[(df['category'] == 'Household') & (df['sub_category'] == 'Maid')].copy()\n",
    "    valid_maid = True\n",
    "\n",
    "    if maid_df.empty: logging.warning(\"No Maid transactions found!\")\n",
    "    else:\n",
    "        if not (maid_df['amount'] == 2500).all(): logging.error(f\"Maid amount incorrect!\"); valid_maid = False\n",
    "        if not ((maid_df['user'] == 'Puspita') & (maid_df['account'] == 'Puspita-SBI')).all(): logging.error(\"Maid payer incorrect!\"); valid_maid = False\n",
    "        maid_counts = maid_df.groupby('month').size()\n",
    "        if (maid_counts != 1).any(): logging.error(f\"Maid frequency incorrect (!=1 per month)!\"); valid_maid = False\n",
    "        if valid_maid: logging.info(\"Maid Salary transactions appear correct.\")\n",
    "else:\n",
    "    print(\"Skipping Maid Salary validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4cedf86b",
   "metadata": {},
   "source": [
    "## 10. Ad-hoc Amount Distribution: Key Categories (Box Plot)\n",
    "\n",
    "Visualize amount distributions for major variable spending areas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "68829a91",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Ad-hoc Amount Distributions (Box Plots) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "boxpoints": "outliers",
         "hovertemplate": "Category=%{x}<br>Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa"
         },
         "name": "",
         "notched": false,
         "offsetgroup": "",
         "orientation": "v",
         "showlegend": false,
         "type": "box",
         "x": [
          "Grocery",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Travel",
          "Household",
          "Grocery",
          "Grocery",
          "Grocery",
          "Household",
          "Shopping",
          "Shopping",
          "Travel",
          "Travel",
          "Shopping",
          "Household",
          "Travel",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Entertainment",
          "Shopping",
          "Household",
          "Restaurant",
          "Household",
          "Grocery",
          "Restaurant",
          "Restaurant",
          "Grocery",
          "Household",
          "Health",
          "Entertainment",
          "Shopping",
          "Travel",
          "Restaurant",
          "Entertainment",
          "Travel",
          "Household",
          "Grocery",
          "Health",
          "Travel",
          "Restaurant",
          "Grocery",
          "Entertainment",
          "Grocery",
          "Travel",
          "Entertainment",
          "Travel",
          "Health",
          "Restaurant",
          "Grocery",
          "Household",
          "Household",
          "Health",
          "Travel",
          "Shopping",
          "Travel",
          "Grocery",
          "Grocery",
          "Shopping",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Travel",
          "Household",
          "Shopping",
          "Grocery",
          "Grocery",
          "Health",
          "Shopping",
          "Household",
          "Travel",
          "Grocery",
          "Household",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Grocery",
          "Health",
          "Household",
          "Travel",
          "Health",
          "Shopping",
          "Grocery",
          "Shopping",
          "Household",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Health",
          "Household",
          "Shopping",
          "Travel",
          "Entertainment",
          "Household",
          "Shopping",
          "Health",
          "Travel",
          "Restaurant",
          "Household",
          "Health",
          "Household",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Restaurant",
          "Grocery",
          "Travel",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Entertainment",
          "Household",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Shopping",
          "Shopping",
          "Household",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Grocery",
          "Travel",
          "Grocery",
          "Household",
          "Travel",
          "Health",
          "Grocery",
          "Shopping",
          "Household",
          "Household",
          "Entertainment",
          "Travel",
          "Travel",
          "Health",
          "Entertainment",
          "Household",
          "Travel",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Grocery",
          "Health",
          "Health",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Shopping",
          "Household",
          "Shopping",
          "Restaurant",
          "Household",
          "Health",
          "Travel",
          "Travel",
          "Household",
          "Grocery",
          "Restaurant",
          "Travel",
          "Health",
          "Grocery",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Grocery",
          "Grocery",
          "Grocery",
          "Entertainment",
          "Shopping",
          "Travel",
          "Household",
          "Travel",
          "Health",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Grocery",
          "Restaurant",
          "Travel",
          "Household",
          "Shopping",
          "Restaurant",
          "Health",
          "Household",
          "Shopping",
          "Household",
          "Travel",
          "Restaurant",
          "Health",
          "Travel",
          "Household",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Health",
          "Grocery",
          "Restaurant",
          "Travel",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Grocery",
          "Restaurant",
          "Household",
          "Restaurant",
          "Travel",
          "Shopping",
          "Grocery",
          "Entertainment",
          "Household",
          "Grocery",
          "Shopping",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Shopping",
          "Shopping",
          "Travel",
          "Grocery",
          "Grocery",
          "Shopping",
          "Health",
          "Shopping",
          "Health",
          "Shopping",
          "Household",
          "Shopping",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Shopping",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Travel",
          "Grocery",
          "Shopping",
          "Shopping",
          "Health",
          "Household",
          "Entertainment",
          "Restaurant",
          "Household",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Grocery",
          "Household",
          "Grocery",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Health",
          "Household",
          "Household",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Health",
          "Travel",
          "Household",
          "Shopping",
          "Household",
          "Shopping",
          "Grocery",
          "Grocery",
          "Travel",
          "Shopping",
          "Travel",
          "Shopping",
          "Travel",
          "Household",
          "Grocery",
          "Travel",
          "Household",
          "Shopping",
          "Restaurant",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Health",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Household",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Household",
          "Restaurant",
          "Household",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Health",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Shopping",
          "Grocery",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Grocery",
          "Shopping",
          "Travel",
          "Shopping",
          "Travel",
          "Grocery",
          "Shopping",
          "Entertainment",
          "Restaurant",
          "Travel",
          "Shopping",
          "Household",
          "Household",
          "Restaurant",
          "Entertainment",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Travel",
          "Grocery",
          "Grocery",
          "Grocery",
          "Health",
          "Shopping",
          "Household",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Entertainment",
          "Household",
          "Shopping",
          "Grocery",
          "Household",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Travel",
          "Grocery",
          "Household",
          "Entertainment",
          "Travel",
          "Household",
          "Health",
          "Travel",
          "Restaurant",
          "Shopping",
          "Health",
          "Shopping",
          "Shopping",
          "Travel",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Health",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Household",
          "Household",
          "Shopping",
          "Shopping",
          "Shopping",
          "Household",
          "Health",
          "Restaurant",
          "Household",
          "Travel",
          "Household",
          "Household",
          "Grocery",
          "Shopping",
          "Restaurant",
          "Household",
          "Travel",
          "Household",
          "Household",
          "Shopping",
          "Household",
          "Restaurant",
          "Household",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Shopping",
          "Travel",
          "Entertainment",
          "Shopping",
          "Shopping",
          "Household",
          "Grocery",
          "Shopping",
          "Entertainment",
          "Household",
          "Grocery",
          "Household",
          "Restaurant",
          "Shopping",
          "Grocery",
          "Health",
          "Grocery",
          "Entertainment",
          "Restaurant",
          "Health",
          "Grocery",
          "Restaurant",
          "Household",
          "Grocery",
          "Health",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Grocery",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Health",
          "Travel",
          "Health",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Household",
          "Health",
          "Restaurant",
          "Household",
          "Entertainment",
          "Travel",
          "Household",
          "Shopping",
          "Entertainment",
          "Travel",
          "Health",
          "Shopping",
          "Entertainment",
          "Entertainment",
          "Shopping",
          "Restaurant",
          "Household",
          "Health",
          "Entertainment",
          "Grocery",
          "Shopping",
          "Health",
          "Household",
          "Shopping",
          "Health",
          "Shopping",
          "Grocery",
          "Household",
          "Household",
          "Travel",
          "Household",
          "Travel",
          "Travel",
          "Entertainment",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Travel",
          "Health",
          "Travel",
          "Grocery",
          "Grocery",
          "Travel",
          "Travel",
          "Entertainment",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Travel",
          "Health",
          "Health",
          "Shopping",
          "Health",
          "Shopping",
          "Shopping",
          "Health",
          "Household",
          "Household",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Travel",
          "Grocery",
          "Shopping",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Health",
          "Household",
          "Restaurant",
          "Shopping",
          "Restaurant",
          "Travel",
          "Household",
          "Health",
          "Shopping",
          "Grocery",
          "Household",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Household",
          "Household",
          "Household",
          "Travel",
          "Household",
          "Grocery",
          "Shopping",
          "Travel",
          "Grocery",
          "Household",
          "Restaurant",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Restaurant",
          "Grocery",
          "Shopping",
          "Travel",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Household",
          "Shopping",
          "Entertainment",
          "Travel",
          "Travel",
          "Restaurant",
          "Entertainment",
          "Restaurant",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Shopping",
          "Travel",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Household",
          "Travel",
          "Grocery",
          "Entertainment",
          "Shopping",
          "Entertainment",
          "Shopping",
          "Restaurant",
          "Grocery",
          "Restaurant",
          "Household",
          "Entertainment",
          "Grocery",
          "Restaurant",
          "Travel"
         ],
         "x0": " ",
         "xaxis": "x",
         "y": {
          "bdata": "uB6F61GwgEAzMzMzM9KmQM3MzMzMhopAuB6F61EElkApXI/C9VabQIXrUbge5VBAZmZmZmZUhEDsUbgehVGKQPYoXI9CCK9APQrXo3A3h0AzMzMzsy2hQFyPwvUotbJA7FG4HkUHsUApXI/C9QR6QKRwPQoXUbJApHA9ChddsUCamZmZmSuRQAAAAAAAMG5ASOF6FK53bEBxPQrXo+6OQB+F61G4EIRA4XoUrkdHlUDNzMzMjOqyQLgehevRMqVAXI/C9SgYekBI4XoULuenQK5H4XoUYaNAAAAAAAC/lECF61G4HsWIQMP1KFxPWLdA16NwPQpfckDNzMzMzN+aQHE9CtejOoFApHA9Ctc5i0ApXI/C9W2QQOxRuB6F44BAPQrXo3CDpECuR+F61G63QFyPwvWo9bBArkfhehTslkDhehSux5qmQB+F61G4cntA9ihcj8JcmUBcj8L1KNSEQClcj8L1DbFAuB6F61H0ckAzMzMzM9dyQNejcD0Kj45AH4XrUbhDk0DsUbgehWanQBSuR+H6DcZAhetRuJ7LrkCkcD0KV1auQBSuR+G6xbZAKVyPwvVwfEAUrkfheiilQArXo3C93qRAFK5H4XosZUB7FK5HYfa1QOxRuB6FlpdAPQrXo3B7g0A9Ctej8BSqQHE9CtejDaNAuB6F61G4lEAK16Nw/e+/QIXrUbgeTWNAZmZmZmZSeEBI4XoUrnytQFyPwvVoFLBAPQrXo3Abr0C4HoXrUZhhQOF6FK5HXK9A4XoUrkcKk0AUrkfhejyhQClcj8I14bFA9ihcj8JOlkDD9ShcD/GgQOxRuB7FhLhAMzMzMzPffECuR+F6FJaUQD0K16NwTJdACtejcD3EgkBSuB6Fy2LLQHE9CtejGH5AAAAAAAAce0B7FK5H4TJxQDMzMzOzYKZACtejcD0JlUC4HoXrkYDGQB+F61G4TJZAAAAAAOD6xUCF61G4nvKkQFyPwvUo5o1ArkfhetTMsEAAAAAAAH+XQOF6FK5H3KpAXI/C9QiQwUBcj8L1KMmSQDMzMzMzmaRAZmZmZmazmEBSuB6Fa8quQMP1KFyPSmVA4XoUrkclmEAzMzMzM39/QIXrUbhemMRAZmZmZmanlUApXI/C9XhjQNejcD0KV6FAPQrXo3DriEAK16Nw/cm7QM3MzMzM3aBAhetRuF7EvkBI4XoUrludQNejcD2K671ArkfhehRuT0DXo3A9Ch9oQArXo3A9ml1AmpmZmZn2k0CF61G4nlGyQGZmZmZm7IRASOF6FK4RnED2KFyPwhKVQLgehetRPLJAAAAAAIB7w0DXo3A9CgmMQPYoXI/Cka9AMzMzM7M0p0DsUbgehamhQJqZmZmZCVVAMzMzM3O2t0DXo3A9CmimQFyPwvXo58JAw/UoXI/qbUDhehSuRzVzQArXo3C9Da9A9ihcj4KRsEBI4XoUrtqZQNejcD0Kr2tAH4XrUfhVykCkcD0K1zmMQClcj8L1jI1AZmZmZnY72ECPwvUoPC7AQDMzMzMz239AzczMzMxBlEBxPQrXo6OSQI/C9ShcZ25Aw/UoXI/8p0CamZmZOYzBQClcj8IVkcNAcT0K16NQjkAfhetRuKKPQK5H4Xp0Z8BAPQrXo3A9TkDhehSuh5uwQKRwPQpX1a5ArkfhehSqhkBmZmZmZsZjQOxRuB6Fa5FAZmZmZiZIwEAzMzMzM6KRQK5H4XoUuqlAw/UoXI9MkUCF61G43jm1QHsUrkfh+lNAMzMzMxMNwkDhehSuR7WfQGZmZmbmjK9ApHA9ClfmpEDsUbgehTifQFK4HoVrXaRApHA9CtcvkkDXo3A9CqygQKRwPQrXFJRA16NwPQqHe0DNzMzMzKyTQBSuR+F6ypVAw/UoXI9KjUBmZmZm5lirQMP1KFyPUnlAzczMzAxzwUBcj8L1KIiDQArXo3A91q1AKVyPwvU5kkDsUbgeBVygQGZmZmZmuZ1AMzMzMzOKoEBI4XoULiC2QB+F61G4FMRAcT0K16NGk0DNzMzMzAKGQKRwPQrX/aVApHA9CteOrECPwvUoXCGKQMP1KFyPiptA4XoUrketjUC4HoXrUUeSQHE9CtejYGRAmpmZmZkZd0CPwvUoXFidQBSuR+F6/q5APQrXo3CHlUD2KFyPwtVgQD0K16NwWJBAKVyPwvUKrECkcD0K18OeQClcj8L1cIJAuB6F61HEcECuR+F6lLW9QDMzMzMzk31A7FG4HgV3o0A9CtejcC1nQMP1KFwP+rxAhetRuB4InkCamZmZmU16QGZmZmZm3mBAUrgehes4okDD9Shcj/OlQFyPwvXo/tFAmpmZmZkBfUD2KFyPwnadQOF6FK5HfXxASOF6FK6ti0B7FK5H4S2qQOxRuB7FGcBArkfhehSSeEAK16NwfT+5QKRwPQrXk3ZAH4XrUbjnoUBmZmZmZnCWQHsUrkfhwmxA7FG4HoXzYEB7FK5H4aJwQK5H4XoUSnxAj8L1KFzGpUCamZmZmTucQArXo3A9wIJAAAAAAAB+gUDD9Shcjw56QDMzMzNT8NBAAAAAAIDsskBcj8L1KIGlQOF6FK5HLYtAj8L1KFx9lkBxPQrXIxywQHsUrkdhTapAw/UoXI+KjkDD9ShcD9anQMP1KFwPo6hAmpmZmZlBpkCkcD0KF8GxQI/C9Sic/LBAzczMzEzBpkDhehSuRzl5QNejcD0KH6dAw/UoXA9vvkCuR+F6FB6NQFK4HoXrKpxArkfhehQ8j0DNzMzMDA27QHsUrkdhvqVAexSuRyFlw0A9CtejcHCqQHE9Ctej6HpA16NwPQrPm0BI4XoUrh9wQOxRuB5lRMhApHA9CtcNmUBI4XoUTuzGQFyPwvUoRG9AXI/C9ShfokAfhetROHaiQGZmZmZmQqJAcT0K16PNlUCamZmZmZKQQMP1KFyPkq1A4XoUrkdEpkApXI/C9Rm1QClcj8L10KBA4XoUrkchn0AK16NwvYCjQHsUrkfhyZlAPQrXo3ADj0AUrkfhekR9QBSuR+F6VHlAAAAAAGCMwkAfhetRuOZvQD0K16Nw94ZAj8L1KNx3pUBI4XoUrlKjQNejcD0KD3BApHA9ClcTpUBSuB6FazCjQBSuR+G6eshAXI/C9SgAq0Bcj8L1KLWRQEjhehSuUp1A4XoUrkcDkkCPwvUoXLGZQOxRuB6Fs3xAmpmZmZn5i0AK16NwvR3HQBSuR+F6FLBAcT0K16OllUAK16NwvdStQB+F61G4T5JAj8L1KJyssUD2KFyPQtypQHsUrkdh3a5AcT0K1yNCpkCF61G4HoChQJqZmZmZfJ9AhetRuB4ZkEAAAAAAAGKGQFK4HoXrqrhAexSuR+HibEDD9Shczxy6QLgehetxUsJA16NwPQqSoEBxPQrXo5iCQFK4HoXr8dVAZmZmZmagqEBmZmZm5p+vQClcj8L1TH9A9ihcj8LNZUCPwvUoXBeYQOxRuB4lesFAhetRuB5bwEAzMzMzM9CaQMP1KFyPW55AZmZmZmb6nkDD9Shcj85zQD0K16NwMZRAH4XrUbgItkBSuB6F61CmQFK4HoXrTZRAH4XrUbgSfUCuR+F6FAZuQB+F61E48qJA16NwPYrLvECkcD0K1+NxQClcj8L1K59AZmZmZmY8g0DsUbgeBRitQB+F61G43k9A4XoUrqdTxUCPwvUoXImVQEjhehQOMsVAexSuR+GlrUAzMzMzs3enQDMzMzMzNYlA16NwPQp5tEAK16NwPfKJQD0K16OwVLtAPQrXo3AJcEBSuB6F68+fQBSuR+F6DbpAmpmZmZn/lkC4HoXrUSKtQEjhehTujMBAhetRuB7OvEAAAAAAAGB6QGZmZmZm7nNAzczMzKyCxEAzMzMzszijQM3MzMzM9HpA16NwPYqx2UAUrkfh+t6pQAAAAAAAXpdAj8L1KFygkkApXI/C9cmbQB+F61G4K5JA4XoUrkcqokDhehSuR+mBQFyPwvW45dBAAAAAAACIk0DD9Shcj6OrQNejcD0KuYhAcT0K16MPo0CamZmZmXmhQMP1KFyPRoVAFK5H4fqKtkAK16NwvXemQDMzMzMz/6xApHA9CtdKwUDXo3A9CreIQAAAAAAAwHNAZmZmZmaimEDhehSuR860QArXo3A9DpJAUrgehesxdEDXo3A9Cr9xQKRwPQrX62JA9ihcj8I9qUCPwvUoXGWtQI/C9ShcqplAKVyPwvUPnECkcD0Kd5LWQFyPwvUolHhAzczMzMw4fkCamZmZmQmLQKRwPQrXVYdAzczMzOylwkAfhetRuDSOQDMzMzMz42pA9ihcj8Jhc0CPwvUoHKu6QLgehetReZpAzczMzEyvqUDNzMzMDGaxQK5H4XoUvmxAMzMzM7NJtkB7FK5H4QZ7QAAAAADAm7JA16NwPco2sUDD9Shcj5W2QClcj8L1GFhApHA9CtdRlEAfhetR+B3GQKRwPQrX55lAmpmZmRlptkDXo3A9CqWxQArXo3A9Wq1AFK5H4XrYlkAzMzMzEzrAQNejcD0K1ZZASOF6FK6AnUBI4XoUrgN1QEjhehSuypNAj8L1KFwvc0DsUbgeBWCjQEjhehSurJZAuB6F61FQeUCPwvUoXL9RQK5H4XoUO5lAzczMzMwojECamZmZmZmaQHE9Ctej2K1ASOF6FK6dkUBcj8L1KKRoQOxRuB6FlplAFK5H4XqDqUCkcD0KF1S4QM3MzMzMar9AKVyPwnV3ukCamZmZGZagQKRwPQrXQsRAmpmZmZlKlUAUrkfheiSDQClcj8JVw8RAuB6F61H4SkCkcD0K1yCkQHsUrkdh16VA7FG4HoVHlEDsUbgehbyeQArXo3D9zbVAFK5H4bpWv0CF61G4HkWBQHE9CtejsHxAH4XrUbhIskCF61G4HkV+QD0K16Nw7JpAj8L1KFxBgkCuR+F6FHmcQClcj8L1WGlAZmZmZoYKxUCkcD0K18uFQPYoXI/CA7JACtejcD3aZ0CPwvUoXHKYQBSuR+F69IlAexSuR2HEqkBxPQrXIxKkQOxRuB6FG15AcT0K16Mpk0CPwvUoXK2EQOF6FK5H2pNAPQrXo3DWn0AfhetROFPAQOxRuB6FCYNAH4XrUbgeS0BmZmZmZr5jQOF6FK5H34NA16NwPQp3fkAUrkfheqetQM3MzMzM5JFASOF6FK7HmkCamZmZmalYQAAAAAAAzZVAFK5H4Xp1n0DsUbgexTqwQMP1KFyP4qVAmpmZmZk9cUCamZmZGSWrQI/C9ShcH5JApHA9CtcxkkCPwvUoXHacQPYoXI/CTpdA7FG4HoVFjEA9CtejcICYQBSuR+G6WLxAAAAAAADgf0B7FK5HEbDXQI/C9SjceK9AAAAAAMCGskApXI/C9c6CQMP1KFyPcq1A4XoUrkc9tkBI4XoUrht+QEjhehSutJ5AcT0K1wO+wUBI4XoUrn+RQGZmZmZmvIJAKVyPwvUmjkCamZmZGVumQKRwPQrXS5RAUrgehetfsUBmZmZmZqmXQOxRuB4FpKBAUrgehetpg0CPwvUoXIiUQOF6FK5H0YBAuB6F61F4VkApXI/C9ax/QB+F61G4R75AFK5H4XrajkDhehSuR42WQNejcD1KCbdAuB6F65G5u0B7FK5H4beUQFyPwvUoNpJAj8L1KFwvWkAK16NwPU6BQArXo3A9EZ1AexSuR+HKa0AzMzMzMytqQBSuR+F6xHlAFK5H4Xp0aECPwvUo3BKiQIXrUbieKKtAH4XrUThEs0BSuB6F687FQOF6FK7H7aBAMzMzM5PJwECPwvUoXHyUQOF6FK7HcLNAmpmZmZkXqkCuR+F6FCSmQJqZmZmZCL5ApHA9Ctc7k0C4HoXrUbSqQGZmZmZm6JpAZmZmZuamokDD9Shcj/5xQI/C9ShcVqFASOF6FK6Nk0BI4XoUrn9xQPYoXI9C9r1Aj8L1KJxpvECkcD0K10+VQHsUrkfhULtAFK5H4Xr2iUAfhetR+MG+QKRwPQrXKJ9AZmZmZmbMiUBcj8L1KDahQB+F61G4vmNACtejcD2KTkBmZmZmZsCLQKRwPQrXB55AZmZmZuavqkBI4XoUrreTQK5H4XoU1pRApHA9CteEkkAUrkfhelGQQPYoXI/C5VBAH4XrUTjOqkCPwvUoXGmCQDMzMzOzdrpAzczMzExBpkBxPQrXoyy9QOxRuB6Fe3RAH4XrUbjcgkCPwvUoXBikQAAAAAAAMFpASOF6FK6nWEAfhetROA6gQHE9Ctcja69A4XoUrscfwEB7FK5H4aOWQClcj8L14GxAhetRuP4swUA9CtejcJmPQHsUrkfhw6tAMzMzMzNrmEBcj8L1KCxyQBSuR+F67p1AmpmZmZlLlEA9CtejcBV0QK5H4XoUBaJAFK5H4foEo0BSuB6F61lkQHE9CtejAKpA7FG4HoUBnECF61G4HheNQDMzMzMzy4ZAZmZmZmYieUCkcD0KVyauQFyPwvVo/sNAmpmZmZlXtEAfhetRuI6XQAAAAAAAIFNA16NwPQpjfECuR+F6FHiEQBSuR+F60ItA4XoUrkfBgUC4HoXr0f2uQKRwPQrXo41AXI/C9Si8dkBmZmZmJqm5QPYoXI/C/aNA4XoUrkdZqUAUrkfhegKAQD0K16PwK7ZACtejcD3ov0A9Ctej8MbCQOF6FK5HEWJApHA9CtdDWkB7FK5H4fJzQClcj8L16E9AzczMzMzsmkCuR+F6FJiPQClcj8L11KlAj8L1KFy4o0CuR+F6FF22QFyPwvUoRJlAAAAAAADDmkBmZmZmZvqHQGZmZmZm8I9Aw/UoXI+9okAAAAAAADRwQJqZmZmZE45AcT0K1yO4xkA=",
          "dtype": "f8"
         },
         "y0": " ",
         "yaxis": "y"
        }
       ],
       "layout": {
        "boxmode": "group",
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Amount Distribution by Major Variable Category (Log Scale, Excl. Maid/Large Furniture/Vacation)"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Category"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         },
         "type": "log"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Review box plot/stats: Do medians/ranges seem realistic for Bangalore daily/weekly expenses in these categories?\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "               count         mean          std     min        25%       50%  \\\n",
      "category                                                                      \n",
      "Entertainment   34.0  1858.921176  1037.274908  484.32  1039.2350  1554.955   \n",
      "Grocery         83.0  1317.318313  1086.638861  118.41   398.4200   903.230   \n",
      "Health          52.0  3298.279808  2711.537050  540.44  1153.2025  2264.335   \n",
      "Household      120.0  2051.820250  2157.755727   70.99   781.8050  1444.155   \n",
      "Restaurant      79.0   945.827595   831.638598   63.74   336.9350   573.160   \n",
      "Shopping       122.0  4939.460984  2925.484306  307.33  2913.7725  4402.180   \n",
      "Travel         153.0  4067.852810  5407.537065   53.94   439.1700  1878.090   \n",
      "\n",
      "                     75%       max  \n",
      "category                            \n",
      "Entertainment  2444.9575   4763.75  \n",
      "Grocery        2221.5200   4124.14  \n",
      "Health         4809.3100   9084.03  \n",
      "Household      2317.8000  11323.94  \n",
      "Restaurant     1542.0300   3476.31  \n",
      "Shopping       6655.8950  14021.59  \n",
      "Travel         4689.6200  26310.16  \n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'amount' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Ad-hoc Amount Distributions (Box Plots) ---\")\n",
    "    major_variable_cats = ['Grocery', 'Restaurant', 'Shopping', 'Travel', 'Household', 'Health', 'Entertainment']\n",
    "    plot_df = df[df['category'].isin(major_variable_cats)].copy() # Make a copy\n",
    "    # Exclude known large fixed costs from Household/Travel for better visualization of variable costs\n",
    "    plot_df = plot_df[~((plot_df['category'] == 'Household') & (plot_df['sub_category'] == 'Maid'))]\n",
    "    # Exclude potential large vacation sums if they skew too much\n",
    "    # plot_df = plot_df[~((plot_df['category'] == 'Travel') & (plot_df['sub_category'] == 'Vacation') & (plot_df['amount'] > 15000))] \n",
    "    # Exclude large furniture costs\n",
    "    plot_df = plot_df[~((plot_df['category'] == 'Household') & (plot_df['sub_category'] == 'Furniture') & (plot_df['amount'] > 10000))]\n",
    "\n",
    "    if not plot_df.empty:\n",
    "        fig_box_cat = px.box(plot_df, x='category', y='amount', points=\"outliers\",\n",
    "                             title='Amount Distribution by Major Variable Category (Log Scale, Excl. Maid/Large Furniture/Vacation)',\n",
    "                             labels={'category': 'Category', 'amount': 'Amount (INR)'},\n",
    "                             log_y=True, height=500)\n",
    "        fig_box_cat.update_layout(xaxis_tickangle=-45)\n",
    "        fig_box_cat.show() # Display inline\n",
    "        # try: fig_box_cat.write_image(IMG_DIR / \"category_amount_boxplot.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save category box plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check:\n",
    "        print(plot_df.groupby('category')['amount'].describe())\n",
    "        logging.info(\"Review box plot/stats: Do medians/ranges seem realistic for Bangalore daily/weekly expenses in these categories?\")\n",
    "    else:\n",
    "        logging.info(\"No data for major variable categories found after filtering fixed/large items.\")\n",
    "else:\n",
    "    print(\"Skipping amount distribution analysis (missing columns).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9944b89",
   "metadata": {},
   "source": [
    "## 11. Ad-hoc Amount Distribution: Grocery Sub-Categories (Box Plot)\n",
    "\n",
    "Compare spending ranges for different grocery platforms/stores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "0a574c09",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Grocery Sub-Category Amount Distributions ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "boxpoints": "outliers",
         "hovertemplate": "Store/Platform=%{x}<br>Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa"
         },
         "name": "",
         "notched": false,
         "offsetgroup": "",
         "orientation": "v",
         "showlegend": false,
         "type": "box",
         "x": [
          "Flipkart Grocery",
          "Local Store",
          "Amazon",
          "BigBasket",
          "Zepto",
          "Local Store",
          "Flipkart Grocery",
          "Flipkart Grocery",
          "Local Store",
          "Amazon",
          "BigBasket",
          "Amazon",
          "BigBasket",
          "Zepto",
          "Amazon",
          "Flipkart Grocery",
          "Local Store",
          "Flipkart Grocery",
          "Amazon",
          "Local Store",
          "Zepto",
          "Amazon",
          "Zepto",
          "Amazon",
          "Amazon",
          "Amazon",
          "Flipkart Grocery",
          "Zepto",
          "BigBasket",
          "Flipkart Grocery",
          "BigBasket",
          "Local Store",
          "BigBasket",
          "Zepto",
          "Zepto",
          "Flipkart Grocery",
          "Local Store",
          "BigBasket",
          "BigBasket",
          "Local Store",
          "Amazon",
          "Local Store",
          "Flipkart Grocery",
          "Zepto",
          "Flipkart Grocery",
          "Flipkart Grocery",
          "Amazon",
          "BigBasket",
          "Local Store",
          "Zepto",
          "BigBasket",
          "Zepto",
          "Zepto",
          "Amazon",
          "Zepto",
          "Zepto",
          "Local Store",
          "Zepto",
          "Zepto",
          "Zepto",
          "BigBasket",
          "Zepto",
          "Local Store",
          "Amazon",
          "Amazon"
         ],
         "x0": " ",
         "xaxis": "x",
         "y": {
          "bdata": "MzMzMzPSpkApXI/C9VabQPYoXI9CCK9APQrXo3A3h0BI4XoUrndsQOF6FK5HR5VAuB6F69EypUBcj8L1KNSEQNejcD0Kj45A7FG4HoVmp0AUrkfheiilQHE9CtejDaNAuB6F61G4lEDhehSuRwqTQBSuR+F6PKFAMzMzMzPffEBxPQrXoxh+QIXrUbie8qRApHA9Ctc5jECuR+F6FKqGQOxRuB6Fa5FAZmZmZuZYq0ApXI/C9TmSQOxRuB4FXKBAZmZmZma5nUAUrkfhev6uQFK4HoXrOKJApHA9CteTdkCamZmZmTucQFyPwvUogaVAcT0K1yMcsEDhehSuRzl5QNejcD0KH6dAmpmZmZmSkEAfhetRuOZvQI/C9Sjcd6VA16NwPQoPcEBSuB6FazCjQJqZmZmZfJ9AhetRuB4ZkEBxPQrXo5iCQArXo3A98olAmpmZmZn/lkBmZmZmZu5zQOF6FK5HKqJAAAAAAACIk0BxPQrXow+jQJqZmZmZeaFAUrgehesxdEBcj8L1KJR4QOxRuB4FYKNApHA9CtfLhUAK16NwPdpnQHE9CtcjEqRAj8L1KFythEBmZmZmZryCQFK4HoXraYNAexSuR+HKa0CkcD0K10+VQEjhehSut5NAexSuR+HDq0A9CtejcBV0QOF6FK5HEWJAzczMzMzsmkAAAAAAAMOaQA==",
          "dtype": "f8"
         },
         "y0": " ",
         "yaxis": "y"
        }
       ],
       "layout": {
        "boxmode": "group",
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Grocery Amount Distribution by Store/Platform (Log Scale)"
        },
        "xaxis": {
         "anchor": "y",
         "categoryarray": [
          "BigBasket",
          "Zepto",
          "Local Store",
          "Amazon",
          "Flipkart Grocery"
         ],
         "categoryorder": "array",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Store/Platform"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         },
         "type": "log"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check if distributions align with expectations (e.g., BigBasket/Amazon generally higher median/IQR than Zepto/Local Store).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                  count         mean          std     min        25%      50%  \\\n",
      "sub_category                                                                    \n",
      "Amazon             14.0  2358.546429  1011.778104  595.08  1767.9875  2322.53   \n",
      "BigBasket          11.0  2400.901818   956.428750  742.93  1911.0250  2456.21   \n",
      "Flipkart Grocery   11.0  2029.481818   902.174004  461.95  1360.9500  2332.46   \n",
      "Local Store        12.0   742.185000   477.796766  144.54   383.4650   673.25   \n",
      "Zepto              17.0   672.707059   429.387667  190.82   318.9000   599.55   \n",
      "\n",
      "                        75%      max  \n",
      "sub_category                          \n",
      "Amazon            2888.7125  3972.13  \n",
      "BigBasket         2833.8800  4124.14  \n",
      "Flipkart Grocery  2730.6700  2921.10  \n",
      "Local Store        990.9800  1749.74  \n",
      "Zepto             1114.8800  1363.96  \n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'sub_category' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Grocery Sub-Category Amount Distributions ---\")\n",
    "    grocery_subs = ['BigBasket', 'Zepto', 'Local Store', 'Amazon', 'Flipkart Grocery']\n",
    "    plot_df_grocery = df[(df['category'] == 'Grocery') & (df['sub_category'].isin(grocery_subs))]\n",
    "\n",
    "    if not plot_df_grocery.empty:\n",
    "        fig_box_grocery = px.box(plot_df_grocery, x='sub_category', y='amount', points=\"outliers\",\n",
    "                                 title='Grocery Amount Distribution by Store/Platform (Log Scale)',\n",
    "                                 labels={'sub_category': 'Store/Platform', 'amount': 'Amount (INR)'},\n",
    "                                 category_orders={\"sub_category\": grocery_subs}, # Control order\n",
    "                                 log_y=True, height=500)\n",
    "        fig_box_grocery.show() # Display inline\n",
    "        # try: fig_box_grocery.write_image(IMG_DIR / \"grocery_subcat_boxplot.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save grocery box plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check\n",
    "        print(plot_df_grocery.groupby('sub_category')['amount'].describe())\n",
    "        logging.info(\"Check if distributions align with expectations (e.g., BigBasket/Amazon generally higher median/IQR than Zepto/Local Store).\")\n",
    "    else:\n",
    "        logging.info(\"No data found for specified Grocery sub-categories.\")\n",
    "else:\n",
    "    print(\"Skipping grocery sub-category analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57335010",
   "metadata": {},
   "source": [
    "## 12. Frequency Validation: Ad-hoc Monthly Counts\n",
    "\n",
    "Check adherence to `Max-times-per-month` for specific ad-hoc rules (Waste, Gifts, Entertainment)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "e2a56823",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Ad-hoc Monthly Frequency Validation (Waste/Gifts/Ent) ---\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Teertha's PC\\AppData\\Local\\Temp\\ipykernel_11796\\1882847337.py:28: FutureWarning:\n",
      "\n",
      "A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\n",
      "The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n",
      "\n",
      "For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n",
      "\n",
      "\n",
      "\n",
      "INFO: Loaded and preprocessed 177 rules from E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\sample_data_generation.csv\n",
      "INFO: Ad-hoc frequency constraints (Max-times-per-month) for Waste/Gifts/Entertainment appear satisfied.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Ad-hoc Monthly Frequency Validation (Waste/Gifts/Ent) ---\")\n",
    "    df_rules_loaded = load_rules(RULES_FILE) # Use the function defined earlier\n",
    "\n",
    "    if df_rules_loaded is not None:\n",
    "        # Define the rules we want to check explicitly based on the constraints given\n",
    "        rules_to_check_criteria = (\n",
    "            (df_rules_loaded['Expense-Frequency'] == 'ad-hoc') &\n",
    "            (\n",
    "                (df_rules_loaded['Category'] == 'Waste') |\n",
    "                (df_rules_loaded['Category'] == 'Gifts & Donations') |\n",
    "                (df_rules_loaded['Category'] == 'Entertainment')\n",
    "            )\n",
    "        )\n",
    "        rules_to_check_df = df_rules_loaded[rules_to_check_criteria].copy()\n",
    "\n",
    "        if not rules_to_check_df.empty:\n",
    "            # Create a unique key combining relevant fields from BOTH data and rules\n",
    "            # Use lowercase for robust matching if casing differs slightly\n",
    "            df['rule_match_key'] = df.apply(lambda r: f\"{r['category'].lower()}|{r['sub_category'].lower()}|{r['user'].lower()}|{r['account'].lower()}\", axis=1)\n",
    "            rules_to_check_df['rule_match_key'] = rules_to_check_df.apply(lambda r: f\"{r['Category'].lower()}|{r['Sub-category'].lower()}|{r['User'].lower()}|{r['Account'].lower()}\", axis=1)\n",
    "\n",
    "            # Group transactions by month and rule_key to count actual occurrences\n",
    "            monthly_actual_counts = df[df['rule_match_key'].isin(rules_to_check_df['rule_match_key'])].groupby(['month', 'rule_match_key']).size().reset_index(name='actual_count')\n",
    "\n",
    "            # Merge actual counts with the limits from the rules file\n",
    "            merged_counts = pd.merge(\n",
    "                monthly_actual_counts,\n",
    "                rules_to_check_df[['rule_match_key', 'Max-times-per-month']],\n",
    "                on='rule_match_key',\n",
    "                how='left' # Keep all actual counts, match rules where possible\n",
    "            )\n",
    "            # Drop rows where the rule couldn't be matched (shouldn't happen if keys are correct)\n",
    "            merged_counts.dropna(subset=['Max-times-per-month'], inplace=True)\n",
    "            merged_counts['Max-times-per-month'] = merged_counts['Max-times-per-month'].astype(int) # Ensure integer comparison\n",
    "\n",
    "            # Find violations\n",
    "            merged_counts['exceeded'] = merged_counts['actual_count'] > merged_counts['Max-times-per-month']\n",
    "            exceeded_df = merged_counts[merged_counts['exceeded']]\n",
    "\n",
    "            if not exceeded_df.empty:\n",
    "                logging.error(\"Max-times-per-month constraint VIOLATED for some ad-hoc rules!\")\n",
    "                print(\"Violations Found (Rule Key | Month | Actual Count | Max Allowed):\")\n",
    "                # Improve display for readability\n",
    "                exceeded_df_display = exceeded_df[['rule_match_key', 'month', 'actual_count', 'Max-times-per-month']].copy()\n",
    "                exceeded_df_display['Rule_Info'] = exceeded_df_display['rule_match_key'].str.replace('|', ' | ', regex=False)\n",
    "                print(exceeded_df_display[['Rule_Info', 'month', 'actual_count', 'Max-times-per-month']].to_string(index=False))\n",
    "            else:\n",
    "                logging.info(\"Ad-hoc frequency constraints (Max-times-per-month) for Waste/Gifts/Entertainment appear satisfied.\")\n",
    "\n",
    "            # Clean up added column from main df\n",
    "            if 'rule_match_key' in df.columns: df.drop(columns=['rule_match_key'], inplace=True, errors='ignore')\n",
    "        else:\n",
    "            logging.info(\"No specific Waste/Gifts/Entertainment ad-hoc rules found in the rules file for frequency validation.\")\n",
    "    else:\n",
    "        logging.warning(\"Could not load rules file, skipping ad-hoc frequency validation.\")\n",
    "else:\n",
    "    print(\"Skipping ad-hoc frequency validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 13. Account Usage Bias Check\n",
    "\n",
    "Verify Puspita-Bandhan use for Travel/Beauty and Anirban-ICICI dominance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Account Usage Validation ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "domain": {
          "x": [
           0,
           1
          ],
          "y": [
           0,
           1
          ]
         },
         "hole": 0.3,
         "hovertemplate": "<b>%{label}</b><br>Total: ₹%{value:,.0f}<br>(%{percent})<extra></extra>",
         "labels": [
          "Anirban-ICICI",
          "Anirban-SBI",
          "Puspita-Bandhan",
          "Puspita-SBI"
         ],
         "legendgroup": "",
         "name": "",
         "showlegend": true,
         "textinfo": "percent+label",
         "type": "pie",
         "values": {
          "bdata": "pHA9Ss15PEG4HoXrCpsjQetRuB6FtBFBSOF6FBZDL0E=",
          "dtype": "f8"
         }
        }
       ],
       "layout": {
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Overall Spending Proportion by Account"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Puspita-Bandhan usage appears focused on Travel/Beauty.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Puspita-Bandhan Category Distribution (% of transactions):\n",
      "category\n",
      "Travel    58.1\n",
      "Beauty    41.9\n",
      "Name: proportion, dtype: float64\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "domain": {
          "x": [
           0,
           1
          ],
          "y": [
           0,
           1
          ]
         },
         "hole": 0.3,
         "hovertemplate": "category=%{label}<extra></extra>",
         "labels": [
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel"
         ],
         "legendgroup": "",
         "name": "",
         "showlegend": true,
         "textinfo": "percent+label",
         "type": "pie"
        }
       ],
       "layout": {
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Puspita-Bandhan Spending by Category"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Anirban-ICICI appears dominant for Anirban's spending (>=60%).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Anirban-ICICI accounts for 74.4% of Anirban's total spending amount.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'account' in df.columns and 'user' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Account Usage Validation ---\")\n",
    "\n",
    "    # Overall Spend per Account (Pie Chart)\n",
    "    account_totals = df.groupby('account')['amount'].sum().reset_index()\n",
    "    fig_acc_pie = px.pie(account_totals, values='amount', names='account',\n",
    "                         title='Overall Spending Proportion by Account', hole=0.3)\n",
    "    fig_acc_pie.update_traces(textinfo='percent+label', hovertemplate=\"<b>%{label}</b><br>Total: ₹%{value:,.0f}<br>(%{percent})<extra></extra>\")\n",
    "    fig_acc_pie.show() # Display inline\n",
    "    # try: fig_acc_pie.write_image(IMG_DIR / \"account_spending_pie.png\") # Commented out\n",
    "    # except Exception as e: logging.error(f\"Failed to save account pie plot: {e}\")\n",
    "\n",
    "    # Puspita-Bandhan: Travel & Beauty focus?\n",
    "    puspita_bandhan_df = df[df['account'] == 'Puspita-Bandhan']\n",
    "    if not puspita_bandhan_df.empty:\n",
    "        pb_cat_dist = puspita_bandhan_df['category'].value_counts(normalize=True) * 100\n",
    "        print(\"\\nPuspita-Bandhan Category Distribution (% of transactions):\")\n",
    "        print(pb_cat_dist.round(1))\n",
    "        allowed_cats = ['Travel', 'Beauty']\n",
    "        other_cats_used = [cat for cat in pb_cat_dist.index if cat not in allowed_cats]\n",
    "        if other_cats_used:\n",
    "            logging.warning(f\"Puspita-Bandhan account used for categories other than Travel/Beauty: {other_cats_used}\")\n",
    "        else:\n",
    "             logging.info(\"Puspita-Bandhan usage appears focused on Travel/Beauty.\")\n",
    "        # Pie chart for Puspita-Bandhan\n",
    "        fig_pb_cat = px.pie(puspita_bandhan_df, names='category', title='Puspita-Bandhan Spending by Category', hole=0.3)\n",
    "        fig_pb_cat.update_traces(textinfo='percent+label')\n",
    "        fig_pb_cat.show() # Display inline\n",
    "        # try: fig_pb_cat.write_image(IMG_DIR / \"puspita_bandhan_category_pie.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save Puspita-Bandhan pie plot: {e}\")\n",
    "    else:\n",
    "        logging.info(\"No transactions found for Puspita-Bandhan.\")\n",
    "\n",
    "    # Anirban-ICICI Dominance Check\n",
    "    anirban_df = df[df['user'] == 'Anirban']\n",
    "    if not anirban_df.empty:\n",
    "         total_anirban_spend = anirban_df['amount'].sum()\n",
    "         if total_anirban_spend > 0:\n",
    "              icici_spend = anirban_df[anirban_df['account'] == 'Anirban-ICICI']['amount'].sum()\n",
    "              icici_share = (icici_spend / total_anirban_spend) * 100\n",
    "              print(f\"\\nAnirban-ICICI accounts for {icici_share:.1f}% of Anirban's total spending amount.\")\n",
    "              if icici_share < 60: # Arbitrary threshold\n",
    "                   logging.warning(\"Anirban-ICICI share of Anirban's spending seems lower than expected (<60%).\")\n",
    "              else:\n",
    "                   logging.info(\"Anirban-ICICI appears dominant for Anirban's spending (>=60%).\")\n",
    "         else:\n",
    "              logging.info(\"Anirban has zero total spending.\")\n",
    "    else:\n",
    "         logging.info(\"No transactions found for Anirban.\")\n",
    "else:\n",
    "    print(\"Skipping account usage validation (missing columns).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 14. Temporal Pattern: Spending Over Month Day\n",
    "\n",
    "Check if Grocery/Shopping spending is concentrated early in the month."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Intra-Month Spending Pattern (Grocery/Shopping) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Day of Month=%{x}<br>Total Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": {
          "bdata": "AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAA",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "7FG4HmWQ9EDNzMzMPDL5QD0K16Po3fFAZmZmZnSsAEGuR+F68LH5QD4K16NIS+dAXI/C9eA14EAK16NwBffrQClcj8LlCdJArkfheuSq20DiehSuZ1bHQArXo3D9i8hA",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Total Grocery/Shopping Spend by Day of Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "dtick": 1,
         "tickmode": "linear",
         "title": {
          "text": "Day of Month"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Total Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check bar chart: Is spending clearly higher in the first ~10 days?\n",
      "INFO: Spending concentration early in the month observed (First 10 days: ~₹687,435 vs Last 10 days: ~₹0).\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Intra-Month Spending Pattern (Grocery/Shopping) ---\")\n",
    "    df['day_of_month'] = df['date_dt'].dt.day\n",
    "    # Filter for relevant categories AND non-fixed amounts (exclude large monthly rent etc. if miscategorized)\n",
    "    monthly_pattern_df = df[\n",
    "        df['category'].isin(['Grocery', 'Shopping']) & (df['amount'] < 20000) # Avoid huge one-offs like Furniture if in Shopping\n",
    "    ]\n",
    "\n",
    "    if not monthly_pattern_df.empty:\n",
    "        daily_total = monthly_pattern_df.groupby('day_of_month')['amount'].sum().reset_index() # Look at SUM not mean per day\n",
    "\n",
    "        fig_month_day = px.bar(daily_total, x='day_of_month', y='amount',\n",
    "                               title='Total Grocery/Shopping Spend by Day of Month',\n",
    "                               labels={'day_of_month': 'Day of Month', 'amount': 'Total Amount (INR)'},\n",
    "                               height=400)\n",
    "        fig_month_day.update_layout(xaxis=dict(tickmode='linear', dtick=1)) # Ensure all days are shown\n",
    "        fig_month_day.show() # Display inline\n",
    "        # try: fig_month_day.write_image(IMG_DIR / \"monthly_day_spend_pattern.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save monthly pattern plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection + Quantitative)\n",
    "        logging.info(\"Check bar chart: Is spending clearly higher in the first ~10 days?\")\n",
    "        total_first_10 = daily_total[daily_total['day_of_month'] <= 10]['amount'].sum()\n",
    "        total_last_10 = daily_total[daily_total['day_of_month'] >= 22]['amount'].sum()\n",
    "        total_overall = daily_total['amount'].sum()\n",
    "\n",
    "        if total_overall > 0 and total_first_10 > total_last_10 * 1.3: # Check if first 10 days sum is >30% higher than last 10\n",
    "             logging.info(f\"Spending concentration early in the month observed (First 10 days: ~₹{total_first_10:,.0f} vs Last 10 days: ~₹{total_last_10:,.0f}).\")\n",
    "        elif total_overall > 0:\n",
    "             logging.warning(f\"Grocery/Shopping spending doesn't seem strongly concentrated early in the month (First 10: ~₹{total_first_10:,.0f} vs Last 10: ~₹{total_last_10:,.0f}).\")\n",
    "        else:\n",
    "            logging.info(\"Not enough spending data to assess intra-month pattern.\")\n",
    "\n",
    "    else:\n",
    "        logging.info(\"No relevant Grocery or Shopping data found for monthly pattern analysis.\")\n",
    "    # Clean up added column\n",
    "    if 'day_of_month' in df.columns: df.drop(columns=['day_of_month'], inplace=True)\n",
    "else:\n",
    "    print(\"Skipping intra-month pattern analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 15. ML Suitability Check: Regression Potential (Flight Cost vs Month)\n",
    "\n",
    "Explore potential relationship for regression model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Regression Potential (Flight Cost vs Month) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (1-12)=%{x}<br>Flight Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "markers",
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "AgAAAAMAAAADAAAABQAAAAUAAAAFAAAABwAAAAcAAAAIAAAACAAAAAsAAAAMAAAADAAAAAEAAAACAAAAAwAAAAMAAAAFAAAABgAAAAwAAAACAAAAAwAAAA==",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "FK5H4foNxkBI4XoUrnytQLgeheuRgMZAhetRuF7EvkDXo3A9iuu9QDMzMzNztrdAKVyPwhWRw0CF61G43jm1QArXo3A91q1AH4XrUbgUxEDsUbgeZUTIQBSuR+G6eshAXI/C9SgAq0AK16NwvR3HQLgehetxUsJA16NwPYrLvEBI4XoUDjLFQFyPwvW45dBAMzMzMzP/rEAfhetRuEe+QHE9CtejLL1A4XoUrscfwEA=",
          "dtype": "f8"
         },
         "yaxis": "y"
        },
        {
         "hovertemplate": "<b>OLS trendline</b><br>amount = -103.772 * month_num + 9230.12<br>R<sup>2</sup>=0.010861<br><br>Month (1-12)=%{x}<br>Flight Amount (INR)=%{y} <b>(trend)</b><extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "lines",
         "name": "",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "AQAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAADAAAABQAAAAUAAAAFAAAABQAAAAYAAAAHAAAABwAAAAgAAAAIAAAACwAAAAwAAAAMAAAADAAAAA==",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "h+uCrSzTwUDbw6nbSZ/BQNvDqdtJn8FA28Op20mfwUAwnNAJZ2vBQDCc0Alna8FAMJzQCWdrwUAwnNAJZ2vBQDCc0Alna8FA2UweZqEDwUDZTB5moQPBQNlMHmahA8FA2UweZqEDwUAuJUWUvs/AQIP9a8Lbm8BAg/1rwtubwEDX1ZLw+GfAQNfVkvD4Z8BAqr0O9qCYv0BUblxS2zC/QFRuXFLbML9AVG5cUtswv0A=",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Flight Cost vs. Month of Booking"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickmode": "array",
         "tickvals": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12
         ],
         "title": {
          "text": "Month (1-12)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Flight Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check scatter plot: Is there a visible trend (even slight)? Are outliers plausible flight costs?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns and 'sub_category' in df.columns:\n",
    "    print(\"\\n--- ML Check: Regression Potential (Flight Cost vs Month) ---\")\n",
    "    flight_df = df[df['sub_category'] == 'Flight'].copy()\n",
    "\n",
    "    if not flight_df.empty:\n",
    "        flight_df['month_num'] = flight_df['date_dt'].dt.month\n",
    "        fig_scatter_flight = px.scatter(flight_df, x='month_num', y='amount',\n",
    "                                        title='Flight Cost vs. Month of Booking',\n",
    "                                        labels={'month_num': 'Month (1-12)', 'amount': 'Flight Amount (INR)'},\n",
    "                                        trendline='ols', # Ordinary Least Squares trendline\n",
    "                                        height=400)\n",
    "        fig_scatter_flight.update_layout(xaxis = dict(tickmode = 'array', tickvals = list(range(1,13)))) # Show all months 1-12\n",
    "        fig_scatter_flight.show() # Display inline\n",
    "        # try: fig_scatter_flight.write_image(IMG_DIR / \"flight_cost_vs_month_scatter.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save flight scatter plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check scatter plot: Is there a visible trend (even slight)? Are outliers plausible flight costs?\")\n",
    "    else:\n",
    "        logging.info(\"No flight data found for regression check.\")\n",
    "else:\n",
    "    print(\"Skipping regression potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 16. ML Suitability Check: Classification Potential (Restaurant Spend Dist.)\n",
    "\n",
    "Look for potential thresholds to classify meals vs. snacks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Classification Potential (Restaurant Spend Distribution) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "bingroup": "x",
         "hovertemplate": "Amount (INR)=%{x}<br>count=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "nbinsx": 50,
         "orientation": "v",
         "showlegend": false,
         "type": "histogram",
         "x": {
          "bdata": "zczMzMyGikBxPQrXo+6OQFyPwvUoGHpAhetRuB7FiEDNzMzMzN+aQHE9CtejOoFArkfhehTslkAzMzMzM9dyQClcj8L1cHxACtejcD3EgkAAAAAAABx7QNejcD0KV6FASOF6FK5bnUDXo3A9Ch9oQOxRuB6FqaFAmpmZmZkJVUCkcD0KV+akQM3MzMzMrJNAcT0K16NgZECamZmZmRl3QD0K16Nwh5VApHA9CtfDnkA9CtejcC1nQJqZmZmZAX1A9ihcj8J2nUAfhetRuOehQOxRuB6F82BAexSuR+GicECuR+F6FEp8QArXo3A9wIJAw/UoXI8OekBxPQrXo+h6QNejcD0Kz5tACtejcL2Ao0A9CtejcAOPQOxRuB6Fs3xAcT0K16OllUApXI/C9Ux/QPYoXI/CzWVAMzMzMzPQmkCuR+F6FAZuQClcj8L1K59AH4XrUbjeT0BSuB6F68+fQM3MzMzM9HpAKVyPwvXJm0DhehSuR+mBQKRwPQrX62JAj8L1KFyqmUD2KFyPwmFzQHsUrkfhBntAKVyPwvUYWEDXo3A9CtWWQLgehetRUHlAXI/C9SikaEAUrkfheiSDQClcj8L1WGlAFK5H4Xr0iUDsUbgehRteQKRwPQrXMZJASOF6FK4bfkCF61G4niirQMP1KFyP/nFAZmZmZmbMiUAfhetRuL5jQI/C9ShcaYJAj8L1KFwYpEBcj8L1KCxyQBSuR+H6BKNAZmZmZmYieUCuR+F6FHiEQOF6FK5HwYFAXI/C9Si8dkDhehSuR1mpQBSuR+F6AoBApHA9CtdDWkBcj8L1KESZQGZmZmZm+odAmpmZmZkTjkA=",
          "dtype": "f8"
         },
         "xaxis": "x",
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Distribution of Restaurant Transaction Amounts"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "count"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check histogram: Is there a clear separation or multiple peaks suggesting distinct groups (e.g., snacks vs meals)? Or is it one large peak skewed right?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'category' in df.columns and 'amount' in df.columns:\n",
    "    print(\"\\n--- ML Check: Classification Potential (Restaurant Spend Distribution) ---\")\n",
    "    resto_df = df[df['category'] == 'Restaurant']\n",
    "\n",
    "    if not resto_df.empty:\n",
    "        fig_hist_resto = px.histogram(resto_df, x='amount', nbins=50, # More bins might show detail\n",
    "                                     title='Distribution of Restaurant Transaction Amounts',\n",
    "                                     labels={'amount': 'Amount (INR)'}, height=400)\n",
    "        fig_hist_resto.show() # Display inline\n",
    "        # try: fig_hist_resto.write_image(IMG_DIR / \"restaurant_amount_histogram.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save restaurant histogram: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check histogram: Is there a clear separation or multiple peaks suggesting distinct groups (e.g., snacks vs meals)? Or is it one large peak skewed right?\")\n",
    "    else:\n",
    "        logging.info(\"No Restaurant data found for classification check.\")\n",
    "else:\n",
    "    print(\"Skipping classification potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 17. ML Suitability Check: Segmentation Potential (Weekday vs Weekend)\n",
    "\n",
    "Compare spending profiles across predefined day type segments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Segmentation Potential (Weekday vs Weekend Profiles) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "hovertemplate": "day_type=Weekday<br>Category=%{x}<br>% of Segment Total Spend=%{y}<extra></extra>",
         "legendgroup": "Weekday",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "Weekday",
         "offsetgroup": "Weekday",
         "orientation": "v",
         "showlegend": true,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "Beauty",
          "Connectivity",
          "Education",
          "Entertainment",
          "Gifts & Donations",
          "Grocery",
          "Health",
          "Household",
          "Insurance Premium",
          "Investment",
          "Rent",
          "Restaurant",
          "Shopping",
          "Travel",
          "Waste"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "goQGR+vxEEAtumvUOvW7P4Iv4KHr+PU//WykTU1R+z9CwrZ5uPv5P2llXDgG1ARAynD1AcRCEkCsHyyt72UpQHiBOd/40CtAB1k7t0B8AUC4eZbZjMM0QJN54Aopmvw/LBiyWbaLMEAf8gAvvKEvQMwZBrzcPrM/",
          "dtype": "f8"
         },
         "yaxis": "y"
        },
        {
         "alignmentgroup": "True",
         "hovertemplate": "day_type=Weekend<br>Category=%{x}<br>% of Segment Total Spend=%{y}<extra></extra>",
         "legendgroup": "Weekend",
         "marker": {
          "color": "#EF553B",
          "pattern": {
           "shape": ""
          }
         },
         "name": "Weekend",
         "offsetgroup": "Weekend",
         "orientation": "v",
         "showlegend": true,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "Beauty",
          "Connectivity",
          "Education",
          "Entertainment",
          "Gifts & Donations",
          "Grocery",
          "Health",
          "Household",
          "Insurance Premium",
          "Investment",
          "Rent",
          "Restaurant",
          "Shopping",
          "Travel",
          "Waste"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "TW00Mo8rCkDIx10ruszBP175tRdjkfs/LIxVb5c++D8L0dcRip0BQENTOVdJGgxArSwV/rUjEUBxNmhN3oMyQAH2+5ifywxAZyGhXsTPAUD5lhIlLAw5QOoPCdiuCANAGDTRNwWJK0AW7jz5yHUxQGQQXa0rzdY/",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "group",
        "height": 500,
        "legend": {
         "title": {
          "text": "Day Type"
         },
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Category Spending %: Weekday vs. Weekend"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -90,
         "title": {
          "text": "Category"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "% of Segment Spending"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check grouped bar chart: Are % allocations significantly different (e.g., higher Restaurant/Entertainment % on Weekends)?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'day_of_week' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- ML Check: Segmentation Potential (Weekday vs Weekend Profiles) ---\")\n",
    "    df['day_type'] = df['day_of_week'].apply(lambda x: 'Weekend' if x in ['Saturday', 'Sunday'] else 'Weekday')\n",
    "\n",
    "    # Compare category distribution using normalized values within each segment\n",
    "    segment_cat_dist = df.groupby(['day_type', 'category'])['amount'].sum().unstack(fill_value=0)\n",
    "    segment_cat_dist_perc = segment_cat_dist.apply(lambda x: x / x.sum() * 100, axis=1).stack().reset_index(name='percentage')\n",
    "\n",
    "    fig_segment_bar = px.bar(segment_cat_dist_perc, x='category', y='percentage', color='day_type',\n",
    "                             barmode='group',\n",
    "                             title='Category Spending %: Weekday vs. Weekend',\n",
    "                             labels={'category': 'Category', 'percentage': '% of Segment Total Spend'},\n",
    "                             height=500)\n",
    "    fig_segment_bar.update_layout(xaxis_tickangle=-90, yaxis_title='% of Segment Spending', legend_title=\"Day Type\")\n",
    "    fig_segment_bar.show() # Display inline\n",
    "    # try: fig_segment_bar.write_image(IMG_DIR / \"weekday_weekend_segment_compare.png\") # Commented out\n",
    "    # except Exception as e: logging.error(f\"Failed to save segmentation comparison plot: {e}\")\n",
    "\n",
    "\n",
    "    # Discrepancy Check (Visual Inspection)\n",
    "    logging.info(\"Check grouped bar chart: Are % allocations significantly different (e.g., higher Restaurant/Entertainment % on Weekends)?\")\n",
    "\n",
    "    # Clean up added column\n",
    "    if 'day_type' in df.columns: df.drop(columns=['day_type'], inplace=True)\n",
    "\n",
    "else:\n",
    "    print(\"Skipping segmentation potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 18. ML Suitability Check: Clustering Potential (Daily Spend/Activity)\n",
    "\n",
    "Visualize daily aggregates to see if natural clusters appear."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Clustering Potential (Daily Spend vs. Activity) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "customdata": [
          [
           "2023-01-01"
          ],
          [
           "2023-01-02"
          ],
          [
           "2023-01-03"
          ],
          [
           "2023-01-04"
          ],
          [
           "2023-01-05"
          ],
          [
           "2023-01-06"
          ],
          [
           "2023-01-07"
          ],
          [
           "2023-01-08"
          ],
          [
           "2023-01-09"
          ],
          [
           "2023-01-10"
          ],
          [
           "2023-01-11"
          ],
          [
           "2023-01-12"
          ],
          [
           "2023-01-15"
          ],
          [
           "2023-02-01"
          ],
          [
           "2023-02-02"
          ],
          [
           "2023-02-03"
          ],
          [
           "2023-02-04"
          ],
          [
           "2023-02-05"
          ],
          [
           "2023-02-06"
          ],
          [
           "2023-02-07"
          ],
          [
           "2023-02-08"
          ],
          [
           "2023-02-10"
          ],
          [
           "2023-02-15"
          ],
          [
           "2023-03-01"
          ],
          [
           "2023-03-02"
          ],
          [
           "2023-03-03"
          ],
          [
           "2023-03-04"
          ],
          [
           "2023-03-05"
          ],
          [
           "2023-03-06"
          ],
          [
           "2023-03-10"
          ],
          [
           "2023-03-15"
          ],
          [
           "2023-03-20"
          ],
          [
           "2023-04-01"
          ],
          [
           "2023-04-02"
          ],
          [
           "2023-04-03"
          ],
          [
           "2023-04-04"
          ],
          [
           "2023-04-05"
          ],
          [
           "2023-04-10"
          ],
          [
           "2023-04-15"
          ],
          [
           "2023-05-01"
          ],
          [
           "2023-05-02"
          ],
          [
           "2023-05-03"
          ],
          [
           "2023-05-04"
          ],
          [
           "2023-05-05"
          ],
          [
           "2023-05-06"
          ],
          [
           "2023-05-07"
          ],
          [
           "2023-05-10"
          ],
          [
           "2023-05-15"
          ],
          [
           "2023-06-01"
          ],
          [
           "2023-06-02"
          ],
          [
           "2023-06-03"
          ],
          [
           "2023-06-04"
          ],
          [
           "2023-06-05"
          ],
          [
           "2023-06-06"
          ],
          [
           "2023-06-10"
          ],
          [
           "2023-06-15"
          ],
          [
           "2023-07-01"
          ],
          [
           "2023-07-02"
          ],
          [
           "2023-07-03"
          ],
          [
           "2023-07-04"
          ],
          [
           "2023-07-05"
          ],
          [
           "2023-07-10"
          ],
          [
           "2023-07-15"
          ],
          [
           "2023-08-01"
          ],
          [
           "2023-08-02"
          ],
          [
           "2023-08-03"
          ],
          [
           "2023-08-04"
          ],
          [
           "2023-08-05"
          ],
          [
           "2023-08-06"
          ],
          [
           "2023-08-07"
          ],
          [
           "2023-08-08"
          ],
          [
           "2023-08-09"
          ],
          [
           "2023-08-10"
          ],
          [
           "2023-08-15"
          ],
          [
           "2023-09-01"
          ],
          [
           "2023-09-02"
          ],
          [
           "2023-09-03"
          ],
          [
           "2023-09-04"
          ],
          [
           "2023-09-05"
          ],
          [
           "2023-09-06"
          ],
          [
           "2023-09-07"
          ],
          [
           "2023-09-08"
          ],
          [
           "2023-09-09"
          ],
          [
           "2023-09-10"
          ],
          [
           "2023-09-11"
          ],
          [
           "2023-09-15"
          ],
          [
           "2023-09-20"
          ],
          [
           "2023-10-01"
          ],
          [
           "2023-10-02"
          ],
          [
           "2023-10-03"
          ],
          [
           "2023-10-04"
          ],
          [
           "2023-10-05"
          ],
          [
           "2023-10-06"
          ],
          [
           "2023-10-07"
          ],
          [
           "2023-10-08"
          ],
          [
           "2023-10-09"
          ],
          [
           "2023-10-10"
          ],
          [
           "2023-10-15"
          ],
          [
           "2023-11-01"
          ],
          [
           "2023-11-02"
          ],
          [
           "2023-11-03"
          ],
          [
           "2023-11-04"
          ],
          [
           "2023-11-05"
          ],
          [
           "2023-11-06"
          ],
          [
           "2023-11-07"
          ],
          [
           "2023-11-08"
          ],
          [
           "2023-11-09"
          ],
          [
           "2023-11-10"
          ],
          [
           "2023-11-15"
          ],
          [
           "2023-12-01"
          ],
          [
           "2023-12-02"
          ],
          [
           "2023-12-03"
          ],
          [
           "2023-12-04"
          ],
          [
           "2023-12-05"
          ],
          [
           "2023-12-06"
          ],
          [
           "2023-12-10"
          ],
          [
           "2023-12-15"
          ],
          [
           "2024-01-01"
          ],
          [
           "2024-01-02"
          ],
          [
           "2024-01-03"
          ],
          [
           "2024-01-04"
          ],
          [
           "2024-01-05"
          ],
          [
           "2024-01-06"
          ],
          [
           "2024-01-07"
          ],
          [
           "2024-01-08"
          ],
          [
           "2024-01-09"
          ],
          [
           "2024-01-10"
          ],
          [
           "2024-01-15"
          ],
          [
           "2024-02-01"
          ],
          [
           "2024-02-02"
          ],
          [
           "2024-02-03"
          ],
          [
           "2024-02-04"
          ],
          [
           "2024-02-05"
          ],
          [
           "2024-02-10"
          ],
          [
           "2024-02-15"
          ],
          [
           "2024-03-01"
          ],
          [
           "2024-03-02"
          ],
          [
           "2024-03-03"
          ],
          [
           "2024-03-04"
          ],
          [
           "2024-03-05"
          ],
          [
           "2024-03-06"
          ],
          [
           "2024-03-07"
          ],
          [
           "2024-03-08"
          ],
          [
           "2024-03-10"
          ],
          [
           "2024-03-15"
          ],
          [
           "2024-03-20"
          ],
          [
           "2024-04-01"
          ],
          [
           "2024-04-02"
          ],
          [
           "2024-04-03"
          ],
          [
           "2024-04-04"
          ],
          [
           "2024-04-05"
          ],
          [
           "2024-04-10"
          ],
          [
           "2024-04-15"
          ],
          [
           "2024-05-01"
          ],
          [
           "2024-05-02"
          ],
          [
           "2024-05-03"
          ],
          [
           "2024-05-04"
          ],
          [
           "2024-05-05"
          ],
          [
           "2024-05-10"
          ],
          [
           "2024-05-15"
          ],
          [
           "2024-06-01"
          ],
          [
           "2024-06-02"
          ],
          [
           "2024-06-03"
          ],
          [
           "2024-06-04"
          ],
          [
           "2024-06-05"
          ],
          [
           "2024-06-06"
          ],
          [
           "2024-06-07"
          ],
          [
           "2024-06-10"
          ],
          [
           "2024-06-15"
          ],
          [
           "2024-07-01"
          ],
          [
           "2024-07-02"
          ],
          [
           "2024-07-03"
          ],
          [
           "2024-07-04"
          ],
          [
           "2024-07-05"
          ],
          [
           "2024-07-06"
          ],
          [
           "2024-07-10"
          ],
          [
           "2024-07-15"
          ],
          [
           "2024-08-01"
          ],
          [
           "2024-08-02"
          ],
          [
           "2024-08-03"
          ],
          [
           "2024-08-04"
          ],
          [
           "2024-08-05"
          ],
          [
           "2024-08-06"
          ],
          [
           "2024-08-07"
          ],
          [
           "2024-08-08"
          ],
          [
           "2024-08-09"
          ],
          [
           "2024-08-10"
          ],
          [
           "2024-08-15"
          ],
          [
           "2024-09-01"
          ],
          [
           "2024-09-02"
          ],
          [
           "2024-09-03"
          ],
          [
           "2024-09-04"
          ],
          [
           "2024-09-05"
          ],
          [
           "2024-09-06"
          ],
          [
           "2024-09-07"
          ],
          [
           "2024-09-08"
          ],
          [
           "2024-09-09"
          ],
          [
           "2024-09-10"
          ],
          [
           "2024-09-15"
          ],
          [
           "2024-09-20"
          ],
          [
           "2024-10-01"
          ],
          [
           "2024-10-02"
          ],
          [
           "2024-10-03"
          ],
          [
           "2024-10-04"
          ],
          [
           "2024-10-05"
          ],
          [
           "2024-10-06"
          ],
          [
           "2024-10-07"
          ],
          [
           "2024-10-08"
          ],
          [
           "2024-10-09"
          ],
          [
           "2024-10-10"
          ],
          [
           "2024-10-15"
          ],
          [
           "2024-11-01"
          ],
          [
           "2024-11-02"
          ],
          [
           "2024-11-03"
          ],
          [
           "2024-11-04"
          ],
          [
           "2024-11-05"
          ],
          [
           "2024-11-06"
          ],
          [
           "2024-11-07"
          ],
          [
           "2024-11-10"
          ],
          [
           "2024-11-15"
          ],
          [
           "2024-12-01"
          ],
          [
           "2024-12-02"
          ],
          [
           "2024-12-03"
          ],
          [
           "2024-12-04"
          ],
          [
           "2024-12-05"
          ],
          [
           "2024-12-06"
          ],
          [
           "2024-12-07"
          ],
          [
           "2024-12-08"
          ],
          [
           "2024-12-09"
          ],
          [
           "2024-12-10"
          ],
          [
           "2024-12-11"
          ],
          [
           "2024-12-15"
          ],
          [
           "2025-01-01"
          ],
          [
           "2025-01-02"
          ],
          [
           "2025-01-03"
          ],
          [
           "2025-01-04"
          ],
          [
           "2025-01-05"
          ],
          [
           "2025-01-06"
          ],
          [
           "2025-01-10"
          ],
          [
           "2025-01-15"
          ],
          [
           "2025-02-01"
          ],
          [
           "2025-02-02"
          ],
          [
           "2025-02-03"
          ],
          [
           "2025-02-04"
          ],
          [
           "2025-02-05"
          ],
          [
           "2025-02-06"
          ],
          [
           "2025-02-07"
          ],
          [
           "2025-02-08"
          ],
          [
           "2025-02-09"
          ],
          [
           "2025-02-10"
          ],
          [
           "2025-02-15"
          ],
          [
           "2025-03-01"
          ],
          [
           "2025-03-02"
          ],
          [
           "2025-03-03"
          ],
          [
           "2025-03-04"
          ],
          [
           "2025-03-05"
          ],
          [
           "2025-03-06"
          ],
          [
           "2025-03-07"
          ],
          [
           "2025-03-08"
          ],
          [
           "2025-03-09"
          ],
          [
           "2025-03-10"
          ],
          [
           "2025-03-11"
          ],
          [
           "2025-03-12"
          ],
          [
           "2025-03-15"
          ],
          [
           "2025-03-20"
          ],
          [
           "2025-04-01"
          ],
          [
           "2025-04-02"
          ],
          [
           "2025-04-03"
          ],
          [
           "2025-04-04"
          ],
          [
           "2025-04-05"
          ],
          [
           "2025-04-06"
          ],
          [
           "2025-04-10"
          ],
          [
           "2025-04-15"
          ]
         ],
         "hovertemplate": "Number of Transactions=%{x}<br>Total Amount Spent (INR)=%{y}<br>date=%{customdata[0]}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "markers",
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "BQQHBQUCAwQBAgUCAgUBBwMGBwUBAQEGBgUGBgMBAQEDBgcHAgEBBwcBBgUDBAEBBgUBBAUDAQEJBgQFAwEBCAYFBQQDBAEBAQEEBwYBBwMDAgMCAQEBBgIHAwUEBAUBAQEGBAEEBAYCAQEBAQkFBAIIBAEBBQEHBQQBAgEBAQIHBQYGAgEBBAQBAQcBBAcBAQEGBgQEBAEBBwQGAwcBAQMEBgcGAwMBAQkEBQQIAgEBBAECAQICBAICBwEDBAEEAwcCBwQBAQEFAgIGBgEFAQYDAQkFAwIFBgEBAQQCBAEDAwICBQgCAQQCBwUFBAECBQIGBwQBBAMFAgEJAwIBBAIDAwIDAwYBAQUFBwUGAQEB",
          "dtype": "i1"
         },
         "xaxis": "x",
         "y": {
          "bdata": "4XoUrn/44UBmZmZm5kmuQClcj8I16tBAXI/C9SjnxEDsUbgeJSrFQClcj8L11rNAcT0K16NFt0C4HoXrUWPAQM3MzMzM35pArkfhelTHsUAK16NwPS++QIXrUbg+MsRAAAAAAAAWpUAUrkfhMmrhQOF6FK7HmqZAzczMzIzzxUC4HoXrEVa0QIXrUbhuvNtAXI/C9Si30UCkcD0KN0vHQArXo3D9779AAAAAAABAr0AAAAAAAMCSQLgehevJ/ONAuB6F61GFz0AVrkfhOsLGQM3MzMxs6dBAAAAAABD70kCF61G4Hg7PQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQLgeheupLeFAZmZmZnbq00CZmZmZKWXbQHE9CtdzE9FASOF6FH4w1EAAAAAAAECvQAAAAAAAwJJAhetRuI7U6ED2KFyPIi3SQArXo3A9ml1A16NwPeoPyEBcj8L1SGzTQGZmZmZmF71APQrXo7AJxkAAAAAAAECvQAAAAAAAwJJA4XoUroev5UDXo3A96hrFQB+F61H4VcpA16NwPRpL20BwPQrXw+XLQBWuR+H6BMhAAAAAAABAr0AAAAAAAMCSQLgeheshg+pACtejcM3I2kBwPQrXgxTLQArXo3A9r9BAwvUoXM/4wkAAAAAAAECvQAAAAAAAwJJASOF6FPZ05EDXo3A9iojDQKRwPQqnG9dAXI/C9YitxUBcj8L1CF3TQHA9Ctdjd7ZA4noUrkfpsUCkcD0K1/2lQKRwPQrXjqxAAAAAAABAr0AAAAAAAMCSQLgehetZI+FAZmZmZiZlxkCuR+F61GDDQClcj8L1cIJAkML1KPyczUAfhetReBDDQD4K16MwnbRAwvUoXO9y0kApXI/CdTapQD4K16PwtrxA7FG4HsUZwEAAAAAAAMCSQAAAAAAA2+pApHA9CjeD5EBmZmZm5r2gQMP1KFyvuMBAuB6F69Gap0D2KFyP0rHbQNejcD3qI8NApHA9CleXw0AzMzMzEyjNQNejcD0KH6dAAAAAAABAr0AAAAAAAMCSQFK4HoWrh+ZAPgrXo3BOyUB7FK5HIWXDQAAAAACA3LZApHA9CjcX3EB7FK5HwVnDQIbrUbgeMKNAw/UoXI+SrUDhehSuR0SmQAAAAAAAQK9AAAAAAADAkkAK16NwNTzpQB6F61H4Zc1AmZmZmalF0EDsUbgeRWW0QClcj8JlItpAzczMzExStUAAAAAAAECvQAAAAAAAwJJAH4XrUVhV4UAK16NwvR3HQNejcD3qqs5AH4XrUTjEzkDiehSuZzzDQBSuR+G61dpAkML1KNzKp0AAAAAAAGKGQB+F61F4+LVAAAAAAABAr0AAAAAAABalQFyPwvVYOutAZmZmZnbB2UCPwvUofM7GQMP1KFxvKtZAFK5H4fpxuUAAAAAAAECvQAAAAAAAwJJAj8L1KOTf4kD2KFyPwsXAQFK4HoXrUKZAUrgehetNlECamZmZmQDQQPYoXI9izs9AuB6F65EkvkAAAAAAAJ3eQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQKRwPQr/g+NAXI/C9eDp4UD1KFyPQinLQLgehesBzNNAAAAAACDRy0AAAAAAAECvQAAAAAAAwJJAw/UoXDdA70C4HoXrkWG+QJmZmZn5idlA4noUrsciokBSuB6FO3bUQAAAAAAAQK9AAAAAAADAkkAzMzMzc67hQK5H4XqUiMZApHA9Chc2w0AfhetRaJ/hQGZmZmbGIdFANDMzMzNPl0DsUbgeJXrCQAAAAAAAQK9AAAAAAADAkkA9CtejULnnQIXrUbg+ZM1AkML1KOxe1UA+CtejMGzIQEjhehTu+dRAPgrXo/DFpUAAAAAAAECvQAAAAAAAwJJASOF6FIbG4EAK16NwPTypQNejcD0KV5pAzczMzMwojECPwvUoHEywQB+F61G4krVA9ihcj8L7sUAehetR+P+xQLgehetx38tAUrgehXP/5kAAAAAAAMCSQJqZmZkhU+BAcT0K1+Nw1kDNzMzMzHx6QEjhehTuQ7pAwvUoXI+axECF61G4bnXSQI/C9SjcPqFA7FG4HpVw0kCuR+F6NGPAQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQB+F61GQ2eBAUrgehasW1kCPwvUoXNipQClcj8KVH8RAMzMzM1PlxkAAAAAAAM2VQDQzMzNz4slAmpmZmRklq0BI4XoULi26QFK4HoVrDMlAAAAAAADAkkDhehSuz0/xQArXo3DNI9FAhetRuB6PukBmZmZmZraVQIXrUbj+Uc5AFK5H4bo/uEDhehSuR5evQAAAAAAAQK9AAAAAAADAkkDXo3A9ekzgQB6F61E48KdAKVyPwtWCyEDXo3A9Sgm3QOF6FK5HCsZAAAAAAIBIpEC4HoXrUXOTQM3MzMxMRaBA9ihcjwLPuUB7FK5HMXLiQKRwPQrXHbhAAAAAAADAkkC4HoXrcTnkQPYoXI9CFLRAhetRuL59z0DC9ShcjyLKQKRwPQp3Qc9AXI/C9bjg20AAAAAAAECvQAAAAAAAFqVAXI/C9YiL6kDsUbgehQemQHE9CtejRrlAZmZmZoZtwUD2KFyPgm/BQI/C9ShcaYJACtejcO0C0UAAAAAAwKC5QNijcD2KAr9AuB6F65FVv0AAAAAAAMCSQKRwPQqvAexAcT0K12P+u0ApXI/C9VCZQK5H4XoUBaJAwvUoXM9uwUDXo3A9ikalQJDC9ShchaVAKVyPwuXZ0kA+CtejcGKiQD0K16OwsrFAXI/C9SgumkB6FK5HgbvKQAAAAAAAwJJAAAAAAADb6kD2KFyP+vPiQIXrUbhuoddAPQrXo3C02EDXo3A9atzHQNejcD3qbMBAcT0K1yO4xkAAAAAAAECvQAAAAAAAwJJA",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Daily Spending vs. Number of Transactions"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Number of Transactions"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Total Amount Spent (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check scatter plot: Do distinct visual groups (clusters) appear based on density? (e.g., low-count/low-spend corner, high-spend outliers, high-activity band).\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns:\n",
    "    print(\"\\n--- ML Check: Clustering Potential (Daily Spend vs. Activity) ---\")\n",
    "    # Aggregate total amount and count transactions per day\n",
    "    # Need a unique identifier per row if 'id' isn't reliably generated/present; using index as fallback.\n",
    "    if 'id' not in df.columns: df['id_temp'] = df.index # Temporary ID if needed\n",
    "    else: df['id_temp'] = df['id'] # Use existing id if present\n",
    "\n",
    "    daily_summary = df.groupby(df['date_dt'].dt.date).agg(\n",
    "        total_amount=('amount', 'sum'),\n",
    "        transaction_count=('id_temp', 'nunique') # Count unique transactions per day\n",
    "    ).reset_index().rename(columns={'date_dt': 'date'})\n",
    "\n",
    "\n",
    "    # Clean up temp id column\n",
    "    if 'id_temp' in df.columns: df.drop(columns=['id_temp'], inplace=True)\n",
    "\n",
    "    if not daily_summary.empty:\n",
    "        fig_scatter_cluster = px.scatter(daily_summary, x='transaction_count', y='total_amount',\n",
    "                                        title='Daily Spending vs. Number of Transactions',\n",
    "                                        labels={'transaction_count': 'Number of Transactions', 'total_amount': 'Total Amount Spent (INR)'},\n",
    "                                        hover_data=['date'],\n",
    "                                        height=500)\n",
    "        fig_scatter_cluster.show() # Display inline\n",
    "        # try: fig_scatter_cluster.write_image(IMG_DIR / \"daily_spend_activity_scatter.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save daily cluster scatter plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check scatter plot: Do distinct visual groups (clusters) appear based on density? (e.g., low-count/low-spend corner, high-spend outliers, high-activity band).\")\n",
    "    else:\n",
    "        logging.info(\"Could not generate daily summary for clustering check.\")\n",
    "else:\n",
    "    print(\"Skipping clustering potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 19. Overall Summary & Conclusion\n",
    "\n",
    "Final assessment based on the EDA checks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Review the logs and plots above for ERRORs or WARNINGs indicating discrepancies.\n",
      "INFO: Key areas checked: Data loading, date range/formats, nulls, row/amount constraints, User/Account mapping, Category/SubCat mapping, fixed expense accuracy, variable amount distributions, ad-hoc frequencies, account usage bias, temporal patterns, and basic visual checks for ML suitability.\n",
      "INFO: Address critical ERRORs (e.g., mapping inconsistencies, constraint violations) by refining data generation script/rules and regenerating.\n",
      "INFO: Consider if WARNINGs (e.g., slight constraint overshoot, weaker-than-expected patterns) are acceptable or require tuning.\n",
      "INFO: Overall assessment: [MANUALLY ADD ASSESSMENT HERE - e.g., 'Data generated successfully and largely adheres to rules. Minor warnings noted for monthly totals. Suitable for Phase 2 development.', OR 'Critical errors found in mappings and frequencies; regeneration required.']\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- EDA Summary ---\n"
     ]
    }
   ],
   "source": [
    "print(\"\\n--- EDA Summary ---\")\n",
    "logging.info(\"Review the logs and plots above for ERRORs or WARNINGs indicating discrepancies.\")\n",
    "logging.info(\"Key areas checked: Data loading, date range/formats, nulls, row/amount constraints, User/Account mapping, Category/SubCat mapping, fixed expense accuracy, variable amount distributions, ad-hoc frequencies, account usage bias, temporal patterns, and basic visual checks for ML suitability.\")\n",
    "logging.info(\"Address critical ERRORs (e.g., mapping inconsistencies, constraint violations) by refining data generation script/rules and regenerating.\")\n",
    "logging.info(\"Consider if WARNINGs (e.g., slight constraint overshoot, weaker-than-expected patterns) are acceptable or require tuning.\")\n",
    "logging.info(\"Overall assessment: [MANUALLY ADD ASSESSMENT HERE - e.g., 'Data generated successfully and largely adheres to rules. Minor warnings noted for monthly totals. Suitable for Phase 2 development.', OR 'Critical errors found in mappings and frequencies; regeneration required.']\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "genai",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

"""

File: expenses_sample.csv
Location: reference\expenses_sample.csv
Summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes payments for house rent, maid salary, groceries, and a restaurant takeaway. The transactions are categorized by account, category, sub-category, type, user, and amount.
Code: """
      date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
01-01-2023  2023 2023-01 2023-W52      Sunday   Puspita-SBI  Household             Maid        Monthly Maid Salary Puspita  2500.00
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI    Grocery            Other         Meat/Fish Purchase Anirban   534.04
01-01-2023  2023 2023-01 2023-W52      Sunday   Puspita-SBI    Grocery Flipkart Grocery         FK Quick Groceries Puspita  2921.10
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI Restaurant         Takeaway               Lunch Parcel Anirban   848.85
"""

File: generate_data.py
Location: reference\generate_data.py
Summary: The script generates realistic expense data using predefined rules from 'sample_data_generation.csv' and outputs transactions to 'dummy_expenses_generated.csv' for the period 2023-01-01 to 2025-04-20. It handles fixed and ad-hoc transactions, ensuring monthly constraints are met, and logs progress and results.
Code: """
# reference/create_file_data.py
"""
Generates realistic expense data based on predefined rules and constraints.

Reads rules from 'sample_data_generation.csv' (in project root) and
outputs transactions to 'dummy_expenses_generated.csv' (in project root)
covering the period from 2023-01-01 to 2025-04-20.
"""

import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
from pathlib import Path
import logging
from tqdm import tqdm # For progress bar
from typing import List, Dict, Any, Optional

# --- Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- File Paths (CRITICAL CHANGE) ---
# Get the directory where THIS script lives (reference/)
SCRIPT_DIR = Path(__file__).parent
# Get the parent directory (project root: app-personal-finance/)
PROJECT_ROOT = SCRIPT_DIR.parent

# Define paths relative to the PROJECT_ROOT
RULES_FILE = PROJECT_ROOT / "sample_data_generation.csv"
OUTPUT_FILE = PROJECT_ROOT / "dummy_expenses_generated.csv"
METADATA_FILE = PROJECT_ROOT / "expense_metadata.json" # Optional, for validation/reference

# Date Range
START_DATE = datetime(2023, 1, 1)
END_DATE = datetime(2025, 4, 20)

# Constraints
MONTHLY_MIN_TOTAL = 60000
MONTHLY_MAX_TOTAL = 120000
MONTHLY_MAX_ROWS = 100

# Ad-hoc Transaction Generation Parameters
AVG_ADHOC_PER_DAY = 4 # Average number of ad-hoc transactions per day
ADHOC_RANGE = (1, 7) # Min/Max ad-hoc transactions per day (adjust as needed)

# --- Helper Functions (No changes needed inside functions) ---

def load_rules(filepath: Path) -> Optional[pd.DataFrame]:
    """Loads and preprocesses the ruleset CSV."""
    if not filepath.exists():
        logging.error(f"Rules file not found: {filepath}")
        return None
    try:
        df_rules = pd.read_csv(filepath)
        df_rules.columns = [col.strip() for col in df_rules.columns]
        df_rules['Valid-expense-types'] = df_rules['Valid-expense-types'].str.split('|')
        for col in ['Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']:
            df_rules[col] = pd.to_numeric(df_rules[col], errors='coerce')
        df_rules['Max-times-per-month'].fillna(5, inplace=True)
        df_rules['Max-times-per-month'] = df_rules['Max-times-per-month'].astype(int)
        df_rules.dropna(subset=['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency', 'Min-expenses-amount', 'Max-expenses-amount'], inplace=True)
        logging.info(f"Loaded {len(df_rules)} rules from {filepath}")
        return df_rules
    except Exception as e:
        logging.error(f"Error loading or processing rules file {filepath}: {e}", exc_info=True)
        return None

def get_date_parts(date_obj: datetime) -> Dict[str, Any]:
    """Calculates derived date columns."""
    return {
        "date_dt": date_obj,
        "date": date_obj.strftime('%d-%m-%Y'),
        "year": date_obj.year,
        "month": date_obj.strftime('%Y-%m'),
        "week": date_obj.strftime('%Y-W%V'),
        "day_of_week": date_obj.strftime('%A')
    }

def generate_fixed_transaction(rule: pd.Series, date_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Generates a dictionary for a fixed transaction based on a rule."""
    if rule['Min-expenses-amount'] != rule['Max-expenses-amount']:
        logging.warning(f"Rule marked as fixed frequency but Min!=Max: {rule.to_dict()}")
        return None
    amount = rule['Min-expenses-amount']
    valid_types = rule['Valid-expense-types']
    selected_type = valid_types[0] if isinstance(valid_types, list) and valid_types else "Fixed Expense"
    return {
        **date_info, "account": rule['Account'], "category": rule['Category'],
        "sub_category": rule['Sub-category'], "type": selected_type,
        "user": rule['User'], "amount": amount
    }

def generate_adhoc_transaction(rule: pd.Series, date_info: Dict[str, Any]) -> Dict[str, Any]:
    """Generates a dictionary for an ad-hoc transaction based on a rule."""
    amount = round(random.uniform(rule['Min-expenses-amount'], rule['Max-expenses-amount']), 2)
    selected_type = random.choice(rule['Valid-expense-types']) if isinstance(rule['Valid-expense-types'], list) and rule['Valid-expense-types'] else "Ad-hoc Expense"
    return {
        **date_info, "account": rule['Account'], "category": rule['Category'],
        "sub_category": rule['Sub-category'], "type": selected_type,
        "user": rule['User'], "amount": amount
    }

def check_fixed_conditions(rule: pd.Series, current_date: datetime) -> bool:
    """Checks if a fixed/recurring rule should trigger on the current date."""
    freq = rule['Expense-Frequency']
    day = current_date.day
    month = current_date.month

    if freq == 'monthly':
        if rule['Category'] == 'Rent' and day == 1: return True
        if rule['Category'] == 'Household' and rule['Sub-category'] == 'Maid' and day == 1: return True
        if rule['Category'] == 'Investment' and rule['Sub-category'] == 'SIP' and day == 5: return True
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'ULIP' and day == 10: return True
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'Health Insurance' and day == 15: return True
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Netflix' and day == 20: return True # Example day for monthly connectivity
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Water' and day == 7: return True # Example day
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Maintenance' and day == 6: return True # Example day
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Garbage Collection' and day == 3: return True # Example day
        return False
    elif freq == 'bi-monthly': # Odd months, day 2
        return month % 2 != 0 and day == 2
    elif freq == 'once every 3 months': # Jan, Apr, Jul, Oct, day 3
        return month in [1, 4, 7, 10] and day == 3
    elif freq == 'once every 6 months': # Jan, Jul, day 4
        return month in [1, 7] and day == 4
    elif freq == 'bi-annually': # Mar 20, Sep 20
        return (month == 3 and day == 20) or (month == 9 and day == 20)
    elif freq == 'annually': # Jan 15
         # Handle specific annual items
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'Vehicle Insurance': return month == 2 and day == 25 # Example Date
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Prime Video': return month == 1 and day == 15 # Example Date
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Disney+ Hotstar': return month == 1 and day == 16 # Example Date
        return False # Only trigger specific annuals
    return False

# --- Main Generation Logic (No changes needed inside function) ---
def generate_data():
    """Main function to generate the expense data."""
    logging.info("--- Starting Data Generation ---")
    logging.info(f"Looking for rules file at: {RULES_FILE}")
    logging.info(f"Output will be saved to: {OUTPUT_FILE}")

    df_rules = load_rules(RULES_FILE)
    if df_rules is None:
        return

    fixed_rules = df_rules[df_rules['Expense-Frequency'] != 'ad-hoc'].copy()
    adhoc_rules = df_rules[df_rules['Expense-Frequency'] == 'ad-hoc'].copy()

    all_transactions = []
    current_date = START_DATE
    total_days = (END_DATE - START_DATE).days + 1
    pbar = tqdm(total=total_days, desc="Generating Daily Transactions")

    current_month_str = ""
    current_month_total = 0.0
    current_month_rows = 0
    monthly_rule_counts: Dict[int, int] = {}

    while current_date <= END_DATE:
        date_info = get_date_parts(current_date)

        if date_info['month'] != current_month_str:
            if current_month_str:
                logging.info(f"Month {current_month_str} Summary: Rows={current_month_rows}, Total=₹{current_month_total:.2f}")
                if current_month_total < MONTHLY_MIN_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} BELOW target minimum ₹{MONTHLY_MIN_TOTAL}")
                if current_month_total > MONTHLY_MAX_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} ABOVE target maximum ₹{MONTHLY_MAX_TOTAL}")
                if current_month_rows > MONTHLY_MAX_ROWS: logging.warning(f"Month {current_month_str} rows {current_month_rows} EXCEEDED target maximum {MONTHLY_MAX_ROWS}")
            current_month_str = date_info['month']
            current_month_total = 0.0; current_month_rows = 0; monthly_rule_counts = {}
            logging.debug(f"Starting generation for month: {current_month_str}")

        # 1. Generate Fixed Transactions
        for index, rule in fixed_rules.iterrows():
            if check_fixed_conditions(rule, current_date):
                transaction = generate_fixed_transaction(rule, date_info)
                if transaction and current_month_rows < MONTHLY_MAX_ROWS + 5:
                     all_transactions.append(transaction)
                     current_month_total += transaction['amount']
                     current_month_rows += 1
                     monthly_rule_counts[index] = monthly_rule_counts.get(index, 0) + 1
                     logging.debug(f"Generated fixed: {transaction['category']}/{transaction['sub_category']} on {date_info['date']}")
                elif transaction:
                     logging.warning(f"Skipped fixed {rule['Category']}/{rule['Sub-category']} on {date_info['date']} (Monthly row limit: {current_month_rows})")

        # 2. Generate Ad-hoc Transactions
        num_adhoc_today = random.randint(ADHOC_RANGE[0], ADHOC_RANGE[1])
        adhoc_added_today = 0
        weights = adhoc_rules['Account'].apply(lambda x: 1.5 if x in ['Anirban-ICICI', 'Puspita-SBI'] else 1.0).values
        if weights.sum() > 0: weights = weights / weights.sum()
        else: weights = None

        for _ in range(num_adhoc_today):
            if current_month_total >= MONTHLY_MAX_TOTAL or current_month_rows >= MONTHLY_MAX_ROWS:
                logging.debug(f"Stopping ad-hoc for {date_info['date']} due to limits.")
                break
            if weights is None or adhoc_rules.empty: continue

            rule_selected = False
            for attempt in range(5):
                 try:
                     selected_rule_series = adhoc_rules.sample(n=1, weights=weights).iloc[0]
                     rule_index = selected_rule_series.name
                 except ValueError as e: logging.warning(f"Adhoc sample error: {e}"); continue

                 current_rule_count = monthly_rule_counts.get(rule_index, 0)
                 max_allowed = selected_rule_series['Max-times-per-month']

                 if current_rule_count < max_allowed:
                     transaction = generate_adhoc_transaction(selected_rule_series, date_info)
                     # Further check if adding this exceeds monthly total *drastically*
                     if current_month_total + transaction['amount'] <= MONTHLY_MAX_TOTAL * 1.05: # Allow slight overshoot
                         all_transactions.append(transaction)
                         current_month_total += transaction['amount']
                         current_month_rows += 1
                         monthly_rule_counts[rule_index] = current_rule_count + 1
                         adhoc_added_today += 1
                         rule_selected = True
                         logging.debug(f"Generated adhoc: {transaction['category']}/{transaction['sub_category']} on {date_info['date']}")
                         break # Exit retry loop
                     else:
                         logging.debug(f"Skipping adhoc {selected_rule_series['Category']}/{selected_rule_series['Sub-category']} to avoid exceeding monthly total drastically.")
                         # Don't break, allow trying another rule maybe
                 else:
                     logging.debug(f"Rule {rule_index} hit monthly limit ({max_allowed}). Retrying...")

            if not rule_selected: logging.debug(f"Could not find valid ad-hoc rule for {date_info['date']} after retries.")

        current_date += timedelta(days=1)
        pbar.update(1)

    pbar.close()
    # Log summary for the very last month
    if current_month_str:
        logging.info(f"Month {current_month_str} Summary: Rows={current_month_rows}, Total=₹{current_month_total:.2f}")
        if current_month_total < MONTHLY_MIN_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} BELOW target minimum ₹{MONTHLY_MIN_TOTAL}")
        if current_month_total > MONTHLY_MAX_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} ABOVE target maximum ₹{MONTHLY_MAX_TOTAL}")
        if current_month_rows > MONTHLY_MAX_ROWS: logging.warning(f"Month {current_month_str} rows {current_month_rows} EXCEEDED target maximum {MONTHLY_MAX_ROWS}")


    if not all_transactions:
        logging.warning("No transactions were generated.")
        return

    df_final = pd.DataFrame(all_transactions)
    output_columns = ['date', 'year', 'month', 'week', 'day_of_week', 'account', 'category', 'sub_category', 'type', 'user', 'amount']
    df_final = df_final[output_columns]

    logging.info(f"--- Data Generation Complete ---")
    logging.info(f"Total transactions generated: {len(df_final)}")

    try:
        df_final.to_csv(OUTPUT_FILE, index=False, encoding='utf-8')
        logging.info(f"Successfully saved generated data to: {OUTPUT_FILE}")
    except Exception as e:
        logging.error(f"Error saving output CSV file {OUTPUT_FILE}: {e}", exc_info=True)

# --- Execution Guard ---
if __name__ == "__main__":
    generate_data()
"""

File: generate_db.py
Location: reference\generate_db.py
Summary: The script processes 'data/expenses.csv' by reconstructing missing 'date' entries using 'year', 'month', and 'day_of_week', adds UUIDs, and saves the data to 'data/expenses.db'. It ensures required columns are present, converts dates, and writes the processed data to an SQLite database.
Code: """
# create_db.py
"""
This script reads 'data/expenses.csv', reconstructs missing 'date' entries using 'year', 'month', and 'day_of_week',
adds UUIDs, and saves the result into 'data/expenses.db'.
"""

import sqlite3
import pandas as pd
import uuid
from pathlib import Path
import calendar
from datetime import datetime

# Define paths
ROOT_DIR = Path(__file__).parent
DATA_DIR = ROOT_DIR / "data"
CSV_PATH = DATA_DIR / "expenses.csv"
DB_PATH = DATA_DIR / "expenses.db"

# Ensure data directory exists
DATA_DIR.mkdir(parents=True, exist_ok=True)

# Load CSV
df = pd.read_csv(CSV_PATH)

# Normalize column names
df.columns = (
    df.columns
    .str.strip()
    .str.lower()
    .str.replace("-", "_")
    .str.replace(" ", "_")
)

# Check if 'date' column exists; if not, create it
if 'date' not in df.columns:
    df['date'] = pd.NaT

# Convert 'date' column to datetime
df['date'] = pd.to_datetime(df['date'], errors='coerce')

# Identify rows with missing 'date' values
missing_date_mask = df['date'].isnull()

# Function to reconstruct date
def reconstruct_date(row):
    year = int(row['year'])
    month = int(row['month'].split('-')[1]) if isinstance(row['month'], str) and '-' in row['month'] else int(row['month'])
    day_name = row['day_of_week']
    # Get all days in the month
    month_calendar = calendar.monthcalendar(year, month)
    # Find the first occurrence of the specified day_of_week
    for week in month_calendar:
        for i, day in enumerate(week):
            if day != 0 and calendar.day_name[i] == day_name:
                return datetime(year, month, day)
    return pd.NaT

# Apply reconstruction to missing dates
df.loc[missing_date_mask, 'date'] = df[missing_date_mask].apply(reconstruct_date, axis=1)

# Check if any 'date' entries are still missing
still_missing = df['date'].isnull().sum()
if still_missing > 0:
    print(f"⚠️ Warning: {still_missing} 'date' entries could not be reconstructed and will be dropped.")
    df = df.dropna(subset=['date'])

# Generate derived date columns
df['month'] = df['date'].dt.to_period('M').astype(str)
df['week'] = df['date'].dt.strftime('%G-W%V')  # ISO week format
df['day_of_week'] = df['date'].dt.day_name()

# Format 'date' as string
df['date'] = df['date'].dt.strftime('%Y-%m-%d')

# Add UUID as primary key
df['id'] = [str(uuid.uuid4()) for _ in range(len(df))]

# Final schema validation
required_columns = {
    'date', 'account', 'category', 'sub_category', 'type',
    'user', 'amount', 'month', 'week', 'day_of_week'
}
missing_cols = required_columns - set(df.columns)
if missing_cols:
    raise ValueError(f"❌ Missing required column(s) after processing: {missing_cols}")

# Write to SQLite database
with sqlite3.connect(DB_PATH) as conn:
    df.to_sql("expenses", conn, if_exists="replace", index=False)

print(f"\n✅ Database successfully created at: {DB_PATH.resolve()}")
print(f"📊 Total records written: {len(df)}")

"""

File: generate_summary.py
Location: reference\generate_summary.py
Summary: The `generate_summary.py` script generates documentation for the `app-personal-finance` by combining functionalities from three scripts. It retrieves relevant files, reads and summarizes their content using OpenAI's API, compresses code details, and generates a folder tree. It excludes specified directories, files, and extensions during processing.
Code: """
#!/usr/bin/env python3
"""
generate_summary.py - Combined documentation generator for app-personal-finance
Combines functionality from:
- generate_code_details.py
- generate_code_details_compressed.py 
- generate_tree.py
"""

import os
import logging
from pathlib import Path
from dotenv import load_dotenv
from typing import List
import pandas as pd
from openai import OpenAI
from tenacity import retry, wait_random_exponential, stop_after_attempt
import tiktoken

# --- Configuration ---
load_dotenv()
SCRIPT_DIR = Path(__file__).resolve().parent
ROOT_DIR = SCRIPT_DIR.parent
REFERENCE_DIR = ROOT_DIR / "reference"

# File paths
CODE_DETAILS_PATH = REFERENCE_DIR / "instruction_code_details.txt"
COMPRESSED_PATH = REFERENCE_DIR / "instruction_code_details_compressed.txt"
TREE_PATH = REFERENCE_DIR / "instruction_file_tree.txt"

# Exclusion lists (combined from original scripts)
EXCLUDED_DIRS = {'.git', '__pycache__', '.vscode', '.idea', '.venv', 'venv', 
                '.mypy_cache', '.pytest_cache', '.git', '.vscode', '.idea', 'venv', '.github'}
EXCLUDED_FILES = {'.env', '.log', '.gitignore', '.env', '.gitignore'}
EXCLUDED_EXTENSIONS = {'.pyc', '.log', '.env', '.db', '.codespellignore'}

# OpenAI setup
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# --- Shared Functions from generate_code_details.py ---
def get_all_relevant_files(directory: Path) -> List[Path]:
    files = []
    for root, dirs, filenames in os.walk(directory):
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
        for fname in filenames:
            fpath = Path(root) / fname
            if (fpath.suffix.lower() not in EXCLUDED_EXTENSIONS and 
                fpath.name not in EXCLUDED_FILES):
                files.append(fpath)
    return files

def read_file_content(file_path: Path) -> str:
    try:
        if file_path.suffix.lower() == '.csv':
            df = pd.read_csv(file_path)
            return df.head().to_string(index=False)
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        logging.error(f"Error reading file {file_path}: {e}")
        return "Unable to read file."

@retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(6))
def summarize_content(content: str, model: str = "gpt-4o") -> str:
    try:
        encoding = tiktoken.encoding_for_model(model)
        tokens = encoding.encode(content)
        if len(tokens) > 12000:
            content = encoding.decode(tokens[:8000])
        response = client.chat.completions.create(
            model=model,
            messages=[{
                "role": "system",
                "content": "You are an assistant that summarizes code files."
            }, {
                "role": "user",
                "content": f"Summarize the following file in no more than 50 words:\n\n{content}"
            }],
            temperature=0.3,
            max_tokens=100
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"OpenAI API error: {e}")
        return "Summary could not be generated."

# --- Compression Logic from generate_code_details_compressed.py ---
def compress_code_details():
    current_block = []
    in_code_block = False
    file_ext = None
    
    with open(CODE_DETAILS_PATH, 'r', encoding='utf-8') as infile, \
         open(COMPRESSED_PATH, 'w', encoding='utf-8') as outfile:
        
        for line in infile:
            line = line.strip()
            
            if line.startswith("File: "):
                if current_block:
                    _write_compressed_block(current_block, file_ext, outfile)
                    current_block = []
                current_block.append(f"# {line[6:]}")
            
            elif line.startswith("Location: "):
                path = line[10:]
                file_ext = Path(path).suffix.lower()
                current_block.append(f"@path: {path}")
            
            elif line.startswith("Summary: "):
                current_block.append(f"@summary: {line[9:]}")
            
            elif line == 'Code: """':
                in_code_block = True
                code_lines = []
            
            elif line == '"""' and in_code_block:
                in_code_block = False
                code = '\n'.join(code_lines)
                truncated = code[:6000] + ('[...]' if len(code) > 6000 else '') \
                    if file_ext == '.py' else code[:300] + ('[...]' if len(code) > 300 else '')
                current_block.append(f"@code:\n{truncated}")
            
            elif in_code_block:
                code_lines.append(line)
        
        if current_block:
            _write_compressed_block(current_block, file_ext, outfile)

def _write_compressed_block(block: list, ext: str, outfile):
    compressed = '\n'.join(block)
    marker = "#PY " if ext == '.py' else "#FILE "
    outfile.write(f"\n{compressed.replace('# ', marker)}\n")

# --- Tree Generation from generate_tree.py ---
def generate_folder_tree():
    with open(TREE_PATH, 'w', encoding='utf-8') as f:
        for root, dirs, files in os.walk(ROOT_DIR, topdown=True):
            dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
            level = root.replace(str(ROOT_DIR), '').count(os.sep)
            indent = ' ' * 4 * level
            
            if root == str(ROOT_DIR):
                f.write(f'{ROOT_DIR.name}/\n')
            else:
                f.write(f'{indent}{os.path.basename(root)}/\n')
            
            subindent = ' ' * 4 * (level + 1)
            for file in files:
                if file not in EXCLUDED_FILES:
                    f.write(f'{subindent}{file}\n')

# --- Main Execution Flow ---
def main():
    REFERENCE_DIR.mkdir(parents=True, exist_ok=True)
    
    # Step 1: Generate code details
    with open(CODE_DETAILS_PATH, 'w', encoding='utf-8') as out:
        out.write("# instruction_code_details.txt\n\"\"\"\nDescribes the functionality of each file...\n\"\"\"\n\n")
        for fpath in get_all_relevant_files(ROOT_DIR):
            rel_path = fpath.relative_to(ROOT_DIR)
            content = read_file_content(fpath)
            summary = summarize_content(content if fpath.suffix == '.py' else content[:1000])
            out.write(f"File: {fpath.name}\nLocation: {rel_path}\nSummary: {summary}\nCode: \"\"\"\n{content}\n\"\"\"\n\n")
    
    # Step 2: Compress code details
    compress_code_details()
    
    # Step 3: Generate folder tree
    generate_folder_tree()
    
    print(f"✅ Summary files generated in {REFERENCE_DIR}")

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()
"""

File: instruction_advanced_question_types.txt
Location: reference\instruction_advanced_question_types.txt
Summary: The file outlines how the Data Science Sub Agent (DSA) categorizes user questions into five advanced machine learning types: Regression, Forecasting, Classification, Segmentation, and Unsupervised Clustering. It provides detailed reasoning and examples for each type, specifically for a personal finance advisor app, emphasizing the unique focus of each ML approach.
Code: """
These are sample user questions.These are the questions which the DATA SCIENCE SUB AGENT (DSA) needs to answer. The DSA will categorize questions in one of the 5 advanced question types:Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering. Here we have detailed reasoning for 5 example question across each of the 5 ML types (Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering), specifically tailored for my 2-person personal finance advisor app.

1. Regression Questions (Predicting Specific Numerical Values)

	Goal: Predict a continuous numerical value (usually Amount) for a specific event or instance based on its characteristics.

	Why Regression (vs. Forecasting)? Focuses on the relationship between features of a single instance and its numerical outcome, rather than predicting the next value in a sequence based primarily on past values and time patterns.

	Question: "Predict the cost (Amount) of the next 'Household Repair' (Plumbing, Electrical, Appliance) needed, based on the specific type of repair (Sub-category) and the month it occurs?"

	Reasoning: This predicts a single numerical value (cost) for an often irregular event. Key predictors are the features of that specific event (type of repair, seasonality via month), not necessarily the cost of the last repair (as that could have been entirely different). It's not a time series prediction of monthly repair totals.

	Benefit: Helps anticipate costs for necessary but unpredictable maintenance.

	Question: "Estimate the Amount Anirban is likely to spend on a single 'Shopping' transaction at 'Amazon' or 'Flipkart', considering the platform (Sub-category), the month (for potential sales events), and the day of the week?"

	Reasoning: Predicts the value of one shopping instance. The platform (Amazon vs. Flipkart), time of year (sales), and whether it's a weekend might influence the basket size more directly than the amount spent on the previous online order. This models the characteristics-to-amount relationship for a specific event.

	Benefit: Understands typical spending per online shopping session on major platforms.

	Question: "What is the predicted Amount for a 'Food Delivery' order, based on the User ordering, the DayOfWeek, and potentially the restaurant mentioned in 'Type' (requires NLP)?"

	Reasoning: Focuses on predicting the cost of a single food delivery event. The user (different preferences/order sizes), day (weekend vs. weekday), and restaurant choice (if extractable) are direct features influencing the cost of that specific order, distinguishing it from forecasting total monthly food delivery spend.

	Benefit: Provides insight into typical meal costs when ordering in, varying by person and context.

	Question: "Predict the Amount Puspita will spend on her next 'Flight' booking, based on the month of booking and the account used ('Puspita-Bandhan' vs. 'Puspita-SBI')?"

	Reasoning: Predicts the cost of one specific, potentially high-value, and infrequent event. While seasonal factors (Month) matter, the model uses features associated with the booking event (like which account is used, potentially reflecting different trip types/budgets associated with that account) rather than forecasting a sequence of flight costs.

	Benefit: Helps plan for significant, variable travel expenses often associated with specific accounts or times of year.

	Question: "Estimate the Amount of a 'Gifts & Donations' transaction, based on the Sub-category ('Family', 'Friends', 'Charity', 'Temple') and the User making the transaction?"

	Reasoning: Predicts the value of a single gifting/donation instance. The recipient/purpose (Sub-category) and who is giving (User) are likely the primary drivers of the amount for that specific transaction, rather than forming a predictable time series pattern.

	Benefit: Understands typical spending levels for different types of gifts or donations, varying by person and occasion/recipient.

2. Forecasting Questions (Predicting Future Values in a Time Series)

	Goal: Predict future values (often numerical aggregates) of a variable that evolves sequentially over time.

	Why Forecasting (vs. Regression)? Focuses explicitly on the temporal dependencies – trend, seasonality, and autocorrelation (how past values influence future values) – inherent in the time series data itself. The primary input is the historical sequence.

	Question: "What is the forecasted total combined spending (Anirban + Puspita) across all categories for the next calendar month?"

	Reasoning: This predicts an aggregate value over a future time period (next month). The prediction relies primarily on the historical sequence of total monthly spending, capturing overall trends (e.g., lifestyle inflation) and seasonality (e.g., higher spending near holidays). This is a classic time series forecasting problem.

	Benefit: High-level budget planning and cash flow projection for the household.

	Question: "Forecast the total amount we are likely to spend on 'Groceries' in the next 4 weeks (providing a weekly breakdown)."

	Reasoning: Predicts an aggregate spend for a specific category over multiple future time periods (next 4 weeks). Grocery spending often has weekly cycles (stock-ups) and monthly patterns. Forecasting models explicitly handle these temporal patterns based on the history of weekly/monthly grocery totals.

	Benefit: Detailed near-term budget planning for a major, recurring expense category.

	Question: "What is the predicted total monthly spending attributed to Puspita for the next 3 months?"

	Reasoning: Treats Puspita's total personal spending as a time series. It forecasts the future aggregate monthly values based on her historical spending patterns, trends, and seasonality, distinct from predicting a single future transaction's amount based on its features (which would be regression).

	Benefit: Helps track and plan individual spending contributions and budgets over the medium term.

	Question: "Forecast the combined monthly spending specifically on the 'Waste' category (Smoke, Alcohol) for the next month."

	Reasoning: This involves predicting the aggregate amount for a specific (potentially sensitive) category over the next time period. Even if irregular, if there's any underlying trend or seasonality in this combined category total over months, forecasting attempts to capture it from the historical sequence.

	Benefit: Helps monitor and potentially manage spending in non-essential/habitual categories by predicting the near-term outlay based on past patterns.

	Question: "Predict the total number of transactions (count, not amount) we are likely to make as a couple in the next week."

	Reasoning: This forecasts a count over a future time period. Transaction frequency itself can be treated as a time series. It depends on the historical pattern of weekly transaction counts, including any day-of-week or intra-month effects. Regression wouldn't typically predict a count for a future period based on the sequence.

	Benefit: Provides insight into the activity level of spending, complementing amount-based forecasts. High frequency might indicate many small purchases.

3. Classification Questions (Predicting Predefined Labels)

	Goal: Assign an instance (e.g., a transaction, a day) to one of several predefined, discrete classes based on its features.

	Why Classification (vs. Segmentation/Clustering)? We are predicting membership in known, predefined categories (like Essential/Discretionary). We are not defining the segments themselves (Segmentation) or discovering unknown groups (Clustering).

	Question: "Classify each transaction as 'Essential' or 'Discretionary' based on its Category/Sub-category." (Requires a predefined mapping rule).

	Reasoning: Assigns each transaction instance to one of two predefined labels. This is the canonical classification task. It's not segmentation because we aren't analyzing the characteristics of the 'Essential' group vs. 'Discretionary' group, but rather labeling individual items. It's not clustering because the labels are known beforehand.

	Benefit: Automatic categorization for budget analysis (Needs vs. Wants).

	Question: "Based on amount, time of day, and day of week, classify a 'Restaurant' transaction as 'Meal' (likely lunch/dinner cost) or 'Snack/Coffee' (lower cost, typical cafe/snack times)?"

	Reasoning: Assigns restaurant transactions to one of two predefined functional categories ('Meal'/'Snack') based on their features. The rules/model defines the boundary between these known classes. It differs from clustering, which might discover different groupings automatically.

	Benefit: Provides more context to restaurant spending beyond just the total amount.

	Question: "Classify each month as a 'High Travel Spending Month' (Yes/No) based on whether total Travel category spending exceeds a certain threshold (e.g., ₹15,000 combined)?"

	Reasoning: Assigns a predefined binary label ('High Travel' / 'Normal Travel') to each month based on a rule applied to aggregated data for that month. It's classification because the label is predefined. It's not segmentation because the focus is labeling the month, not analyzing the characteristics of all 'High Travel Months' together.

	Benefit: Quickly identifies periods dominated by significant travel costs.

	Question: "Predict if a 'Shopping' transaction made by Anirban is likely for 'Electronics' (Yes/No) based on the Sub-category (Amazon, Flipkart, Purple, Lifestyle, Max, Myntra) and the Amount (higher amounts might suggest electronics)?"

	Reasoning: Assigns a predefined label ('Electronics'/'Not Electronics') to individual shopping transactions. This requires defining which sub-categories can sell electronics and potentially learning from amount patterns. It's classification because the target label is known.

	Benefit: Helps infer the purpose of shopping transactions on general platforms where the sub-category alone isn't specific enough.

	Question: "Classify a day as having 'Anomalous Spending' (Yes/No) if the total daily spend is significantly higher (e.g., > 3 standard deviations above the rolling monthly average) than usual for that day of the week?"

	Reasoning: Assigns a predefined binary label ('Anomalous'/'Normal') to each day based on a statistical rule comparing its spend to its historical context. It's classification because the label is defined by the rule. It differs from clustering which might find groups of 'high spending days' without the context of deviation from the norm.

	Benefit: Automatically flags days with unusually high expenditure for review.

4. Segmentation Questions (Analyzing Predefined Groups)

	Goal: Divide data into meaningful, predefined groups based on rules or shared characteristics, and then analyze and compare these segments.

	Why Segmentation (vs. Classification/Clustering)? The primary focus is on defining the groups first based on domain knowledge or specific criteria, and then describing or comparing the data within those defined segments. It's not predicting a label for new instances (Classification) or discovering unknown groups (Clustering).

	Question: "Compare the spending patterns (top categories, avg. transaction amount, user split) within two defined segments: 'Planned Recurring Expenses' (Rent, SIP, ULIP, Insurance Premiums) vs. 'Variable & Discretionary Expenses' (all other categories)."

	Reasoning: We first define segments based on category purpose ('Planned Recurring' vs. 'Variable/Discretionary'). The analysis then compares the characteristics of transactions falling into these predefined groups. This is segmentation analysis, not classification (not predicting segment for a new transaction) or clustering (segments are predefined).

	Benefit: Clearly separates committed outflows from flexible spending for high-level budget understanding.

	Question: "Analyze the 'High-Frequency Spending' segment (transactions under ₹300). What are the dominant categories, sub-categories, and users within this segment? Does its total monthly value change significantly?"

	Reasoning: We define a segment based on a rule (Amount < 300). The analysis then describes the composition (categories, users) and tracks the aggregate behavior (total value over time) of this specific, predefined segment.

	Benefit: Highlights where small, frequent purchases are occurring, often an area for potential budget leaks ("death by a thousand cuts").

	Question: "Segment monthly spending into 'Pay Week 1', 'Week 2', 'Week 3', 'Week 4+'. How does the distribution of spending across categories (e.g., % on Grocery vs. % on Entertainment) differ between these predefined intra-month time segments?"

	Reasoning: Segments are defined based on the week of the month (assuming a monthly pay cycle context). The analysis then compares the category breakdown across these predefined time-based segments.

	Benefit: Reveals spending patterns tied to pay cycles (e.g., more discretionary spending early in the month, bills later).

	Question: "Create user-based segments ('Anirban's Spending' vs. 'Puspita's Spending'). What are the key differences in their top 5 spending categories, average transaction values, and preferred accounts within their respective segments?"

	Reasoning: Segments are simply defined by the User field. The analysis then performs a comparative characterization between these two predefined segments.

	Benefit: Directly compares the financial habits and priorities of both individuals based on their tracked expenses.

	Question: "Define a 'Travel Mode Segment' (Flight, Train, Cab/Commute, Other Travel). What is the average cost, frequency, and associated user/account for transactions within each of these predefined travel sub-segments?"

	Reasoning: Segments are defined by grouping specific travel Sub-category values. The analysis then describes the typical financial characteristics associated with each defined travel mode.

	Benefit: Provides a clear cost and usage comparison between different forms of travel used by the couple.

5. Unsupervised Clustering Questions (Discovering Unknown Groups)

	Goal: Allow an algorithm to automatically discover natural groupings (clusters) within the data based on similarity across features, without using predefined labels.

	Why Clustering (vs. Classification/Segmentation)? The key is the discovery of groups. We don't know the optimal or 'correct' groupings beforehand. We want the algorithm to reveal structures or archetypes based purely on the data patterns, unlike classification (predicting known labels) or segmentation (analyzing predefined groups).

	Question: "Cluster our days based on the combination of total amount spent and the number of transactions that day. What kind of 'daily activity' clusters emerge (e.g., 'Low Spend/Low Activity', 'High Spend/Low Activity (single big purchase?)', 'Moderate Spend/High Activity (many small purchases?)')?"

	Reasoning: We don't predefine what makes a 'type' of day. We feed features (total daily amount, total daily transaction count) into a clustering algorithm (like K-Means) and let it find groups of days that are mathematically similar based on these two dimensions. We then interpret the resulting clusters.

	Benefit: Discovers data-driven daily spending styles beyond simple high/low thresholds.

	Question: "Based on the vector of monthly spending across all major categories, can we cluster the months? Do distinct 'financial character' months emerge automatically (e.g., months focused heavily on Investment, months dominated by Travel, 'balanced' months)?"

	Reasoning: We represent each month by its spending profile across categories (a vector of numbers). Clustering groups months with similar spending distributions, regardless of the absolute total spend. This might reveal patterns like "Holiday Prep Month" or "Saving Drive Month" without us defining those labels first.

	Benefit: Identifies seasonality or periods defined by shifting financial priorities across the board, discovered from the data itself.

	Question: "Cluster individual 'Grocery' transactions based on Amount, Store/Sub-category, and TimeOfDay (if available). What natural groupings of grocery runs are discovered (e.g., weekday morning top-ups at Local Store, large weekend BigBasket orders, late-night Zepto snacks)?"

	Reasoning: Aims to find inherent patterns within grocery shopping without pre-labeling runs as 'Stock-up' or 'Top-up'. The algorithm groups similar grocery transaction events based on cost, place, and potentially time.

	Benefit: May reveal more nuanced grocery shopping habits or contexts than simple rule-based classification.

	Question: "Can we cluster weeks based on the proportion of spending allocated to Needs (e.g., Rent, Grocery, Utilities) vs. Wants (e.g., Restaurant, Shopping, Entertainment)? Do weeks with distinct Needs/Wants balance ratios emerge?"

	Reasoning: We calculate features (proportion of spend on Needs, proportion on Wants) for each week and ask the clustering algorithm to group weeks with similar proportions, discovering different types of weekly budget allocations automatically.

	Benefit: Finds weeks characterized by different financial discipline levels or priorities based on the needs/wants balance, identified by the algorithm.

	Question: "Cluster Anirban's 'Shopping' transactions based on Amount and Platform/Sub-category. Are there distinct clusters representing, perhaps, 'Small Amazon Buys', 'Large Electronics Purchases (Flipkart/Amazon)', 'Clothing Hauls (Myntra/Lifestyle/Max)' that the data naturally separates?"

	Reasoning: Applies clustering specifically to Anirban's shopping data using amount and store type as features. The goal is to see if the algorithm discovers groupings that align with intuitive shopping purposes without us predefining them.

	Benefit: Data-driven identification of distinct shopping behavior types for a specific user, potentially revealing patterns not immediately obvious.
"""

File: instruction_code_details.txt
Location: reference\instruction_code_details.txt
Summary: The `expense_metadata.json` file defines a structure for financial transactions, specifying date format, account holders, and spending categories such as Investment, Rent, Travel, and Restaurant, with detailed subcategories like SIP, House Rent, Day Trip, and Dine-in.
Code: """
# instruction_code_details.txt
"""
Describes the functionality of each file...
"""

File: expense_metadata.json
Location: expense_metadata.json
Summary: The file outlines a financial transaction structure, detailing the date format, account holders, and various spending categories. Categories include Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, each with specific subcategories like SIP, House Rent, Day Trip, Dine-in, and more.
Code: """
{
    "Date": "Date of the transaction (format: YYYY-MM-DD)",
    "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],
	"categories": {
        "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
        "Rent": ["House Rent"],
        "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
        "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
        "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
        "Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ],
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
        "Waste": ["Smoke", "Alcohol"],
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
        "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare", "Salon"],
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
        "Entertainment": ["Movies", "Concerts", "Games"],
        "Education": ["Online Courses", "Books", "Workshops"]
	},
    "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
    "Type": "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
    "Amount": "INR value of the transaction"
}
"""

File: requirements-v2.0.txt
Location: requirements-v2.0.txt
Summary: This file lists dependencies for a core application, database, and GenAI & embeddings. It includes `streamlit`, `pandas`, `numpy`, `python-dateutil`, `python-dotenv`, `requests`, `aiosqlite`, `SQLAlchemy`, `langchain-google-genai`, `google-generativeai`, `tiktoken`, `langchain`, and `langchain-community`. Some packages are commented out, indicating they are not currently in use.
Code: """
# Core Application
streamlit
pandas
numpy # Removed specific version for now, let pip resolve
python-dateutil
python-dotenv==1.0.1 # Keep specific version
requests

# Database
aiosqlite==0.21.0         # async SQLite support
# faiss-cpu==1.10.0       # Can be commented out if not used for metadata similarity yet
SQLAlchemy==2.0.39 # Keep specific version

# GenAI & Embeddings
# openai==1.68.2          # Commented out as we focus on Gemini now
# cohere==5.14.0          # Commented out
langchain-google-genai   # ADDED for Gemini support
google-generativeai      # Often a dependency, good to list
# sentence-transformers==4.0.2 # Commented out if not used for embeddings yet
# huggingface-hub==0.30.1 # Commented out if not used
# transformers            # Commented out if not used
tiktoken # Often needed by LangChain tokenizers
# tokenizers==0.21.1      # Commented out if not used directly

# LangChain & LangGraph
langchain
# langchain-cohere        # Commented out
langchain-community
langchain-core
# langchain-milvus        # Commented out
# langchain-ollama        # Commented out
# langchain-openai        # Commented out
langchain-text-splitters
langchainhub
# langfuse                # Commented out if not using LangFuse specifically
langgraph                # REQUIRED
# langgraph-api           # Usually part of langgraph or langserve install
# langgraph-checkpoint    # Needed for persistence, maybe later
langgraph-cli            # REQUIRED
# langgraph-prebuilt      # Optional prebuilt graphs
# langgraph-sdk           # Usually part of langgraph install
langsmith                # Recommended for tracing

# LangServe (for LangGraph CLI Server)
langserve                # REQUIRED

# Data Science, ML and DL (Keep for potential future DSA use)
scikit-learn # Removed specific version
scipy        # Removed specific version
statsmodels  # Removed specific version
# keras==3.9.2 # Commented out if not used now
# xgboost==3.0.0 # Commented out if not used now
joblib       # Removed specific version
torch        # Keep if planning DL later

# Data Visualization
matplotlib # Removed specific version
plotly     # REQUIRED
seaborn    # Removed specific version

# Python
six # Removed specific version
pydantic-settings # Removed specific version
pydantic         # REQUIRED (Often v1 needed by LangChain, pip should handle)

# Utilities & Helpers
black # Removed specific version
cloudpickle # Removed specific version
click     # Removed specific version
pypdf
openpyxl # Removed specific version
tqdm

# Web Frameworks (for LangServe)
# Flask==3.1.0 # Commented out, LangServe uses FastAPI
fastapi    # REQUIRED
uvicorn    # REQUIRED (often needs [standard] extras)
# beautifulsoup4 # Commented out if not used
# boto3==1.36.26 # Commented out if not used
# botocore==1.36.26 # Commented out if not used
Jinja2 # Removed specific version
"""

File: .codespellignore
Location: assistant\finance-assistant\.codespellignore
Summary: Please provide the content of the file you would like summarized.
Code: """

"""

File: .env.example
Location: assistant\finance-assistant\.env.example
Summary: This file sets up environment variables for a project named "new-agent" to manage API keys for different language model providers, including Anthropic, Fireworks, and OpenAI.
Code: """
# To separate your traces from other application
LANGSMITH_PROJECT=new-agent

# The following depend on your selected configuration

## LLM choice:
ANTHROPIC_API_KEY=....
FIREWORKS_API_KEY=...
OPENAI_API_KEY=...

"""

File: langgraph.json
Location: assistant\finance-assistant\langgraph.json
Summary: This file specifies a configuration with dependencies, a graph, and an environment. It lists the current directory as a dependency, defines a graph located at `./src/agent/graph.py:graph`, and sets the environment configuration to be loaded from a `.env` file.
Code: """
{
  "dependencies": ["."],
  "graphs": {
    "agent": "./src/agent/graph.py:graph"
  },
  "env": ".env"
}

"""

File: LICENSE
Location: assistant\finance-assistant\LICENSE
Summary: The file is the MIT License for LangChain's software, granting free use, modification, and distribution rights, provided the copyright notice is included. It disclaims warranties and limits liability for any damages.
Code: """
MIT License

Copyright (c) 2024 LangChain

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

"""

File: Makefile
Location: assistant\finance-assistant\Makefile
Summary: This Makefile defines various targets for testing, linting, and formatting a Python project. It includes commands for running unit and integration tests, watching tests, profiling tests, and executing extended tests. Additionally, it sets up linting and formatting for Python files, with specific configurations for different file sets.
Code: """
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

# Default target executed when no arguments are given to make.
all: help

# Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
	python -m pytest $(TEST_FILE)

integration_tests:
	python -m pytest tests/integration_tests 

test_watch:
	python -m ptw --snapshot-update --now . -- -vv tests/unit_tests

test_profile:
	python -m pytest -vv tests/unit_tests/ --profile-svg

extended_tests:
	python -m pytest --only-extended $(TEST_FILE)


######################
# LINTING AND FORMATTING
######################

# Define a variable for Python and notebook files.
PYTHON_FILES=src/
MYPY_CACHE=.mypy_cache
lint format: PYTHON_FILES=.
lint_diff format_diff: PYTHON_FILES=$(shell git diff --name-only --diff-filter=d main | grep -E '\.py$$|\.ipynb$$')
lint_package: PYTHON_FILES=src
lint_tests: PYTHON_FILES=tests
lint_tests: MYPY_CACHE=.mypy_cache_test

lint lint_diff lint_package lint_tests:
	python -m ruff check .
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff format $(PYTHON_FILES) --diff
	[ "$(PYTHON_FILES)" = "" ] || python -m ruff check --select I $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || python -m mypy --strict $(PYTHON_FILES)
	[ "$(PYTHON_FILES)" = "" ] || mkdir -p $(MYPY_CACHE) && python -m mypy --strict $(PYTHON_FILES) --cache-dir $(MYPY_CACHE)

format format_diff:
	ruff format $(PYTHON_FILES)
	ruff check --select I --fix $(PYTHON_FILES)

spell_check:
	codespell --toml pyproject.toml

spell_fix:
	codespell --toml pyproject.toml -w

######################
# HELP
######################

help:
	@echo '----'
	@echo 'format                       - run code formatters'
	@echo 'lint                         - run linters'
	@echo 'test                         - run unit tests'
	@echo 'tests                        - run unit tests'
	@echo 'test TEST_FILE=<test_file>   - run all tests in file'
	@echo 'test_watch                   - run unit tests in watch mode'


"""

File: pyproject.toml
Location: assistant\finance-assistant\pyproject.toml
Summary: This file is a configuration for a Python project named "agent" version 0.0.1. It specifies metadata, dependencies, and build settings. The project requires Python 3.9 or higher and depends on "langgraph" and "python-dotenv". It includes optional development dependencies and uses "setuptools" for packaging. Linting rules are defined using "ruff".
Code: """
[project]
name = "agent"
version = "0.0.1"
description = "Starter template for making a new agent LangGraph."
authors = [
    { name = "William Fu-Hinthorn", email = "13333726+hinthornw@users.noreply.github.com" },
]
readme = "README.md"
license = { text = "MIT" }
requires-python = ">=3.9"
dependencies = [
    "langgraph>=0.2.6",
    "python-dotenv>=1.0.1",
]


[project.optional-dependencies]
dev = ["mypy>=1.11.1", "ruff>=0.6.1"]

[build-system]
requires = ["setuptools>=73.0.0", "wheel"]
build-backend = "setuptools.build_meta"

[tool.setuptools]
packages = ["langgraph.templates.agent", "agent"]
[tool.setuptools.package-dir]
"langgraph.templates.agent" = "src/agent"
"agent" = "src/agent"


[tool.setuptools.package-data]
"*" = ["py.typed"]

[tool.ruff]
lint.select = [
    "E",    # pycodestyle
    "F",    # pyflakes
    "I",    # isort
    "D",    # pydocstyle
    "D401", # First line should be in imperative mood
    "T201",
    "UP",
]
lint.ignore = [
    "UP006",
    "UP007",
    # We actually do want to import from typing_extensions
    "UP035",
    # Relax the convention by _not_ requiring documentation for every function parameter.
    "D417",
    "E501",
]
[tool.ruff.lint.per-file-ignores]
"tests/*" = ["D", "UP"]
[tool.ruff.lint.pydocstyle]
convention = "google"

"""

File: README.md
Location: assistant\finance-assistant\README.md
Summary: The "New LangGraph Project" repository includes badges for continuous integration (CI) and integration tests, indicating automated testing workflows. It also features a badge to open the project in LangGraph Studio, suggesting a focus on graph-based development or visualization. The project appears to be hosted on GitHub.
Code: """
# New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/integration-tests.yml)
[![Open in - LangGraph Studio](https://img.shields.io/badge/Open_in-LangGraph_Studio-00324d.svg?logo=data:image/svg%2bxml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4NS4zMzMiIGhlaWdodD0iODUuMzMzIiB2ZXJzaW9uPSIxLjAiIHZpZXdCb3g9IjAgMCA2NCA2NCI+PHBhdGggZD0iTTEzIDcuOGMtNi4zIDMuMS03LjEgNi4zLTYuOCAyNS43LjQgMjQuNi4zIDI0LjUgMjUuOSAyNC41QzU3LjUgNTggNTggNTcuNSA1OCAzMi4zIDU4IDcuMyA1Ni43IDYgMzIgNmMtMTIuOCAwLTE2LjEuMy0xOSAxLjhtMzcuNiAxNi42YzIuOCAyLjggMy40IDQuMiAzLjQgNy42cy0uNiA0LjgtMy40IDcuNkw0Ny4yIDQzSDE2LjhsLTMuNC0zLjRjLTQuOC00LjgtNC44LTEwLjQgMC0xNS4ybDMuNC0zLjRoMzAuNHoiLz48cGF0aCBkPSJNMTguOSAyNS42Yy0xLjEgMS4zLTEgMS43LjQgMi41LjkuNiAxLjcgMS44IDEuNyAyLjcgMCAxIC43IDIuOCAxLjYgNC4xIDEuNCAxLjkgMS40IDIuNS4zIDMuMi0xIC42LS42LjkgMS40LjkgMS41IDAgMi43LS41IDIuNy0xIDAtLjYgMS4xLS44IDIuNi0uNGwyLjYuNy0xLjgtMi45Yy01LjktOS4zLTkuNC0xMi4zLTExLjUtOS44TTM5IDI2YzAgMS4xLS45IDIuNS0yIDMuMi0yLjQgMS41LTIuNiAzLjQtLjUgNC4yLjguMyAyIDEuNyAyLjUgMy4xLjYgMS41IDEuNCAyLjMgMiAyIDEuNS0uOSAxLjItMy41LS40LTMuNS0yLjEgMC0yLjgtMi44LS44LTMuMyAxLjYtLjQgMS42LS41IDAtLjYtMS4xLS4xLTEuNS0uNi0xLjItMS42LjctMS43IDMuMy0yLjEgMy41LS41LjEuNS4yIDEuNi4zIDIuMiAwIC43LjkgMS40IDEuOSAxLjYgMi4xLjQgMi4zLTIuMy4yLTMuMi0uOC0uMy0yLTEuNy0yLjUtMy4xLTEuMS0zLTMtMy4zLTMtLjUiLz48L3N2Zz4=)](https://langgraph-studio.vercel.app/templates/open?githubUrl=https://github.com/langchain-ai/new-langgraph-project)

This template demonstrates a simple chatbot implemented using [LangGraph](https://github.com/langchain-ai/langgraph), designed for [LangGraph Studio](https://github.com/langchain-ai/langgraph-studio). The chatbot maintains persistent chat memory, allowing for coherent conversations across multiple interactions.

![Graph view in LangGraph studio UI](./static/studio_ui.png)

The core logic, defined in `src/agent/graph.py`, showcases a straightforward chatbot that responds to user queries while maintaining context from previous messages.

## What it does

The simple chatbot:

1. Takes a user **message** as input
2. Maintains a history of the conversation
3. Generates a response based on the current message and conversation history
4. Updates the conversation history with the new interaction

This template provides a foundation that can be easily customized and extended to create more complex conversational agents.

## Getting Started

Assuming you have already [installed LangGraph Studio](https://github.com/langchain-ai/langgraph-studio?tab=readme-ov-file#download), to set up:

1. Create a `.env` file.

```bash
cp .env.example .env
```

2. Define required API keys in your `.env` file.

<!--
Setup instruction auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
-->



<!--
End setup instructions
-->

3. Customize the code as needed.
4. Open the folder in LangGraph Studio!

## How to customize

1. **Modify the system prompt**: The default system prompt is defined in [configuration.py](./src/agent/configuration.py). You can easily update this via configuration in the studio to change the chatbot's personality or behavior.
2. **Select a different model**: We default to Anthropic's Claude 3 Sonnet. You can select a compatible chat model using `provider/model-name` via configuration. Example: `openai/gpt-4-turbo-preview`.
3. **Extend the graph**: The core logic of the chatbot is defined in [graph.py](./src/agent/graph.py). You can modify this file to add new nodes, edges, or change the flow of the conversation.

You can also quickly extend this template by:

- Adding custom tools or functions to enhance the chatbot's capabilities.
- Implementing additional logic for handling specific types of user queries or tasks.
- Integrating external APIs or databases to provide more dynamic responses.

## Development

While iterating on your graph, you can edit past state and rerun your app from previous states to debug specific nodes. Local changes will be automatically applied via hot reload. Try experimenting with:

- Modifying the system prompt to give your chatbot a unique personality.
- Adding new nodes to the graph for more complex conversation flows.
- Implementing conditional logic to handle different types of user inputs.

Follow-up requests will be appended to the same thread. You can create an entirely new thread, clearing previous history, using the `+` button in the top right.

For more advanced features and examples, refer to the [LangGraph documentation](https://github.com/langchain-ai/langgraph). These resources can help you adapt this template for your specific use case and build more sophisticated conversational agents.

LangGraph Studio also integrates with [LangSmith](https://smith.langchain.com/) for more in-depth tracing and collaboration with teammates, allowing you to analyze and optimize your chatbot's performance.

<!--
Configuration auto-generated by `langgraph template lock`. DO NOT EDIT MANUALLY.
{
  "config_schemas": {
    "agent": {
      "type": "object",
      "properties": {}
    }
  }
}
-->
"""

File: configuration.py
Location: assistant\finance-assistant\src\agent\configuration.py
Summary: The file defines a `Configuration` dataclass for an agent, allowing for customizable parameters. It includes a method `from_runnable_config` to create a `Configuration` instance from a `RunnableConfig` object, filtering fields based on predefined configurations.
Code: """
"""Define the configurable parameters for the agent."""

from __future__ import annotations

from dataclasses import dataclass, fields
from typing import Optional

from langchain_core.runnables import RunnableConfig


@dataclass(kw_only=True)
class Configuration:
    """The configuration for the agent."""

    # Changeme: Add configurable values here!
    # these values can be pre-set when you
    # create assistants (https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/)
    # and when you invoke the graph
    my_configurable_param: str = "changeme"

    @classmethod
    def from_runnable_config(
        cls, config: Optional[RunnableConfig] = None
    ) -> Configuration:
        """Create a Configuration instance from a RunnableConfig object."""
        configurable = (config.get("configurable") or {}) if config else {}
        _fields = {f.name for f in fields(cls) if f.init}
        return cls(**{k: v for k, v in configurable.items() if k in _fields})

"""

File: graph.py
Location: assistant\finance-assistant\src\agent\graph.py
Summary: The `graph.py` file defines a workflow for a finance assistant agent using a state graph. It sets up logging, loads environment variables, connects to a SQLite database, and initializes a language model (Gemini) for natural language processing. The workflow includes nodes for classifying queries, generating SQL, executing SQL, generating charts, and creating responses. It handles errors and uses conditional logic to determine the flow, ultimately generating a natural language response based on the user's query.
Code: """
# assistant/finance-assistant/src/agent/graph.py
"""Define the graph for the finance assistant agent."""

import os
import json
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from langchain_google_genai import ChatGoogleGenerativeAI # Use Gemini
from langchain_core.prompts import ChatPromptTemplate
# from langchain_core.pydantic_v1 import BaseModel, Field # Not needed right now
from langgraph.graph import StateGraph, END
from sqlalchemy import create_engine, text           # For database interaction
from pathlib import Path
import logging
from dotenv import load_dotenv
import yaml # To load the metadata YAML

# Import the AgentState definition from the state.py file in the same directory
from .state import AgentState

# --- Basic Configuration ---
# Configure logging for better visibility
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__) # Use a specific logger for this module

# Load .env file from the *project root* (app-personal-finance/)
# Adjust the number of .parent calls based on the script's location
# src/agent/graph.py -> src/agent -> src -> finance-assistant -> assistant -> app-personal-finance
project_root = Path(__file__).resolve().parent.parent.parent.parent.parent
env_path = project_root / '.env'
if env_path.exists():
    load_dotenv(dotenv_path=env_path)
    logger.info(f"Loaded environment variables from: {env_path}")
else:
    logger.warning(f".env file not found at {env_path}. Relying on system environment variables.")

# --- Database Setup ---
# Construct the path relative to the project root
DB_PATH = project_root / "data" / "expenses.db"
if not DB_PATH.exists():
    logger.error(f"CRITICAL: DATABASE NOT FOUND at expected location: {DB_PATH}")
    raise FileNotFoundError(f"Database file not found at {DB_PATH}. Ensure data/expenses.db exists in the project root.")
DB_URI = f"sqlite:///{DB_PATH.resolve()}"
try:
    # connect_args might be needed for specific DB types or async operations later
    engine = create_engine(DB_URI) #, connect_args={"check_same_thread": False})
    logger.info(f"Database engine created for: {DB_URI}")
    # Simple connection test
    with engine.connect() as conn:
         logger.info("Database connection test successful.")
except Exception as e:
    logger.error(f"Failed to create database engine or connect: {e}", exc_info=True)
    raise # Stop execution if DB setup fails

# --- LLM Setup (Gemini) ---
google_api_key = os.getenv("GOOGLE_API_KEY")
if not google_api_key:
    logger.error("CRITICAL: GOOGLE_API_KEY not found in environment variables.")
    raise ValueError("GOOGLE_API_KEY environment variable must be set in the .env file.")

try:
    # Initialize Gemini LLM - Using flash for speed/cost
    LLM = ChatGoogleGenerativeAI(
        model="gemini-1.5-flash-latest",
        google_api_key=google_api_key,
        temperature=0.1, # Lower temperature for more deterministic tasks initially
        convert_system_message_to_human=True # Important for Gemini compatibility
    )
    logger.info("ChatGoogleGenerativeAI model initialized (gemini-1.5-flash-latest).")
except Exception as e:
    logger.error(f"Failed to initialize ChatGoogleGenerativeAI: {e}", exc_info=True)
    raise # Stop execution if LLM setup fails

# --- Metadata Loading ---
# Load the detailed metadata YAML file
metadata_path = project_root / "metadata" / "expenses_metadata_detailed.yaml"
SCHEMA_METADATA = "" # Initialize as empty string
try:
    if metadata_path.exists():
        with open(metadata_path, 'r', encoding='utf-8') as f:
            # Load the YAML content - consider formatting it for the prompt
            metadata_content = yaml.safe_load(f)
            # Basic string conversion - could be refined for better LLM digestion
            SCHEMA_METADATA = json.dumps(metadata_content, indent=2)
            logger.info(f"Successfully loaded metadata from {metadata_path}")
    else:
        logger.warning(f"Metadata file not found at {metadata_path}. SQL generation accuracy may be reduced.")
        # Provide a minimal fallback schema description if file is missing
        SCHEMA_METADATA = """
         Fallback Schema:
         Table: expenses
         Columns: id(TEXT PK), date(DATE 'YYYY-MM-DD'), year(INT), month(TEXT 'YYYY-MM'), week(TEXT 'YYYY-Www'), day_of_week(TEXT), account(TEXT), category(TEXT), sub_category(TEXT), type(TEXT), user(TEXT 'Anirban'|'Puspita'), amount(REAL INR).
         """
except Exception as e:
    logger.error(f"Failed to load or parse metadata YAML: {e}", exc_info=True)
    # Proceed with fallback schema or raise error depending on desired robustness
    SCHEMA_METADATA = """
     Fallback Schema: Table: expenses. Columns: id, date, year, month, week, day_of_week, account, category, sub_category, type, user, amount.
     """


# ==========================================================================
#                       NODE FUNCTIONS Will Go Here
# ==========================================================================
def classify_query_node(state: AgentState) -> dict:
    """
    Classifies the user's original query into 'simple', 'advanced', or 'irrelevant'.

    Args:
        state (AgentState): The current state of the graph. Must contain 'original_query'.

    Returns:
        dict: A dictionary containing the 'classification' key with the determined category,
              or an 'error' key if classification fails.
    """
    logger.info("--- Executing Node: classify_query_node ---")
    query = state.get('original_query') # Use .get() for safety

    if not query:
        logger.error("Original query is missing in state for classification.")
        # Return error and default classification
        return {"error": "Missing user query.", "classification": "irrelevant"}

    logger.debug(f"Classifying query: '{query}'")

    # Define the prompt for the classification task
    prompt = ChatPromptTemplate.from_messages([
        ("system", """Your primary task is to classify user questions about personal finance data into one of three categories. Respond ONLY with a single word: 'simple', 'advanced', or 'irrelevant'.

Definitions:
- simple: Directly answerable with a standard SQL query on the 'expenses' table. Examples: totals, averages, filtering by date/category/user, specific lookups like 'What was my total spend last month?', 'Show my grocery expenses in Jan 2024', 'List expenses over 1000 INR'.
- advanced: Requires complex analysis beyond direct SQL (e.g., forecasting, prediction, anomaly detection, clustering, complex multi-step calculations). Examples: 'Predict my spending next week', 'Cluster my spending habits', 'Find unusual spending patterns'. FOR THIS INITIAL IMPLEMENTATION, TREAT 'advanced' THE SAME AS 'simple' downstream (proceed to SQL generation).
- irrelevant: Unrelated to the user's personal finance data stored in the expenses table. Examples: 'What is the weather like?', 'Who won the game?', 'General knowledge questions'.
"""),
        # Explicitly tell the LLM what to do with the user's query
        ("user", f"Classify the following user query: {query}")
    ])

    # Create the chain: Prompt -> LLM
    chain = prompt | LLM

    try:
        # Invoke the LLM
        response = chain.invoke({}) # Provide empty input as context is in the prompt
        # Clean the LLM response: lower case, remove extra characters/whitespace
        classification = response.content.strip().lower().replace("'", "").replace('"', '').replace(".", "")
        logger.info(f"Gemini raw classification response: '{response.content}' -> Cleaned: '{classification}'")

        # Validate the classification output
        valid_classifications = ['simple', 'advanced', 'irrelevant']
        if classification not in valid_classifications:
            logger.warning(f"LLM returned an unexpected classification: '{classification}'. Defaulting to 'simple'.")
            # Fallback to a safe default if the LLM response is malformed
            classification = 'simple'

    except Exception as e:
        logger.error(f"LLM call failed during query classification for query '{query}': {e}", exc_info=True)
        # If the LLM call fails, set an error and default classification
        return {"error": f"Failed to classify query due to LLM error: {e}", "classification": "simple"}

    # Return the classification in the expected dictionary format to update the state
    return {"classification": classification}

def generate_sql_node(state: AgentState) -> dict:
    """
    Generates an SQLite query based on the user's original query and schema metadata.

    Args:
        state (AgentState): The current state graph. Must contain 'original_query'.
                           Uses the pre-loaded SCHEMA_METADATA constant.

    Returns:
        dict: A dictionary containing the 'sql_query' key with the generated query string,
              or an 'error' key if SQL generation fails.
    """
    logger.info("--- Executing Node: generate_sql_node ---")
    query = state.get('original_query')

    # Check if classification failed or query is missing
    if state.get('error'):
         logger.warning(f"Skipping SQL generation due to previous error: {state['error']}")
         # Don't overwrite the existing error, just pass through
         return {} # Return empty dict, error state persists
    if not query:
        logger.error("Original query is missing in state for SQL generation.")
        return {"error": "Missing user query."} # Set specific error for this node

    logger.debug(f"Generating SQL for query: '{query}'")

    # Ensure SCHEMA_METADATA is available (loaded during initial setup)
    if not SCHEMA_METADATA:
        logger.error("Schema metadata (SCHEMA_METADATA) is empty or was not loaded.")
        return {"error": "Database schema metadata is unavailable."}

    # Define the prompt for SQL generation, injecting the loaded metadata
    prompt = ChatPromptTemplate.from_messages([
         ("system", f"""You are an expert SQLite query generator. Your task is to generate a precise and syntactically correct SQLite query for the 'expenses' table based ONLY on the user's question and the provided schema metadata.

Schema Metadata:
------
{SCHEMA_METADATA}
------

Query Generation Instructions:
1.  Analyze the user's question and the detailed schema metadata.
2.  Identify the relevant columns, filters, aggregations (SUM, AVG, COUNT), and grouping clauses needed.
3.  Use the 'purpose_for_llm' descriptions in the metadata to understand column usage and handle potential ambiguities (e.g., prefer 'Household.Electricity Bill' for bill payments, consider context for 'Amazon').
4.  Construct a single, valid SQLite query.
5.  Interpret timeframes relative to a plausible current date (e.g., assume mid-2024 or later for 'last month', 'this year'). Use specific 'YYYY-MM-DD' date formats in WHERE clauses (e.g., `date BETWEEN '2024-01-01' AND '2024-01-31'`).
6.  Respond ONLY with the raw SQL query. Do NOT include any explanations, comments, or markdown formatting (like ```sql or ```).
7.  Ensure the query terminates correctly (no trailing semicolon needed typically for execution libraries).
"""),
        # Provide the user query clearly
         ("user", f"Generate the SQLite query for the following question: {query}")
    ])

    # Create the chain
    chain = prompt | LLM

    try:
        # Invoke the LLM
        response = chain.invoke({}) # Context is in the prompt
        # Clean the response: remove markdown, strip whitespace, remove trailing semicolon
        sql_query = response.content.strip().replace("```sql", "").replace("```", "").strip()
        if sql_query.endswith(';'):
            sql_query = sql_query[:-1].strip()

        logger.info(f"Gemini raw SQL response: '{response.content}' -> Cleaned: '{sql_query}'")

        # Basic validation: Check if it's non-empty and seems like a SELECT statement
        if not sql_query or not sql_query.lower().startswith("select"):
             logger.error(f"Generated query is empty or does not start with SELECT: '{sql_query}'")
             # Return the potentially faulty query along with the error
             return {"error": "Failed to generate a valid SELECT query.", "sql_query": sql_query or "Empty response"}

    except Exception as e:
        logger.error(f"LLM call failed during SQL generation for query '{query}': {e}", exc_info=True)
        return {"error": f"Failed to generate SQL query due to LLM error: {e}"}

    # Return the generated SQL query to update the state
    return {"sql_query": sql_query}

def execute_sql_node(state: AgentState) -> dict:
    """
    Executes the generated SQL query against the SQLite database using SQLAlchemy.

    Args:
        state (AgentState): The current graph state. Must contain 'sql_query' if no prior error.

    Returns:
        dict: A dictionary containing 'sql_results_df' (Pandas DataFrame) and
              'sql_results_str' (string representation), or an 'error' key if execution fails.
    """
    logger.info("--- Executing Node: execute_sql_node ---")
    sql_query = state.get('sql_query') # Safer access using .get()

    # Check if SQL generation failed or if there's a prior error
    if state.get('error'):
        logger.warning(f"Skipping SQL execution due to previous error: {state['error']}")
        # Ensure results state fields are appropriately empty/error-indicating
        return {"sql_results_df": pd.DataFrame(), "sql_results_str": f"Error: {state['error']}"}
    if not sql_query:
        logger.error("No SQL query found in state to execute.")
        return {"error": "SQL query generation failed or was missing.", "sql_results_df": pd.DataFrame(), "sql_results_str": "Error: No SQL query found."}

    logger.info(f"Attempting to execute SQL query: [{sql_query}]")
    try:
        # Use the globally defined SQLAlchemy engine
        with engine.connect() as connection:
            # Execute query using pandas for easy DataFrame conversion
            # Use text() for safe query execution with SQLAlchemy
            df = pd.read_sql(sql=text(sql_query), con=connection)
        logger.info(f"SQL query executed successfully. Number of rows returned: {len(df)}")

        # --- Post-execution Data Formatting (Optional but Recommended) ---
        if not df.empty:
            # Attempt to format common column types for better display/consistency
            for col in df.columns:
                # Format date-like columns
                if 'date' in col.lower(): # Check if 'date' is part of the column name
                    try:
                        # Convert to datetime if not already, then format
                        df[col] = pd.to_datetime(df[col]).dt.strftime('%Y-%m-%d')
                    except Exception as date_fmt_err:
                        logger.warning(f"Could not format date column '{col}': {date_fmt_err}")
                # Format amount-like columns (round to 2 decimals)
                elif 'amount' in col.lower() and pd.api.types.is_numeric_dtype(df[col]):
                    try:
                        df[col] = df[col].round(2)
                    except Exception as amount_fmt_err:
                        logger.warning(f"Could not format amount column '{col}': {amount_fmt_err}")

            # Create string representation for LLM prompt context / basic display
            # Use na_rep to show NULL for missing values clearly
            results_str = df.to_string(index=False, na_rep='<NA>')
        else:
            results_str = "Query returned no results." # Specific message for empty results

        # Return both the DataFrame and the string representation
        # Note: Passing DataFrames in state can sometimes cause serialization issues
        # depending on the checkpoint/backend used with LangGraph.
        # If issues arise, consider serializing df to dict/json: df.to_dict('records')
        return {"sql_results_df": df, "sql_results_str": results_str}

    except Exception as e:
        # Catch potential SQLAlchemy errors, pandas errors, etc.
        logger.error(f"SQL execution failed for query [{sql_query}]: {e}", exc_info=True)
        # Provide a detailed error message
        error_msg = f"Failed to execute SQL query. Error: {e}. Query Attempted: [{sql_query}]"
        # Ensure state consistency by returning empty df and error string
        return {"error": error_msg, "sql_results_df": pd.DataFrame(), "sql_results_str": f"Error executing SQL."}

def generate_chart_node(state: AgentState) -> dict:
    """
    Generates a Plotly chart JSON based on the SQL query results (DataFrame).
    Uses simple heuristics to determine the most appropriate chart type.

    Args:
        state (AgentState): The current graph state. Needs 'sql_results_df'.

    Returns:
        dict: A dictionary containing 'chart_json' (Plotly JSON string) if successful,
              otherwise None. Does not typically set the main 'error' state unless
              charting itself is critical and fails unexpectedly.
    """
    logger.info("--- Executing Node: generate_chart_node ---")
    # Use .get() for safe access to state elements
    df = state.get('sql_results_df')
    error = state.get('error')
    query = state.get('original_query', 'Unknown query') # For context if needed

    # --- Pre-checks ---
    # 1. Don't generate if there was a preceding error
    if error:
        logger.warning(f"Skipping chart generation due to previous error: {error}")
        return {"chart_json": None}
    # 2. Don't generate if the DataFrame is missing (shouldn't happen if execute_sql handles errors properly)
    if df is None:
        logger.warning("Skipping chart generation as DataFrame is None.")
        return {"chart_json": None}
    # 3. Don't generate if DataFrame is empty
    if df.empty:
        logger.info("Skipping chart generation as DataFrame is empty.")
        return {"chart_json": None}

    logger.info(f"Attempting chart generation with DataFrame shape: {df.shape}")
    logger.debug(f"DataFrame columns: {df.columns.tolist()}")
    # logger.debug(f"DataFrame dtypes:\n{df.dtypes}") # Uncomment for detailed debugging

    # --- Chart Generation Logic ---
    try:
        fig = None # Initialize figure object
        num_rows, num_cols = df.shape
        # Use lower case column names for case-insensitive matching
        col_names_lower = df.columns.str.lower()

        # Identify numeric columns suitable for plotting (exclude 'id', 'year')
        numeric_cols = [
            col for col in df.columns
            if pd.api.types.is_numeric_dtype(df[col])
            and col.lower() not in ['id', 'year'] # Exclude typical non-measure IDs/years
        ]
        logger.debug(f"Identified numeric columns for plotting: {numeric_cols}")

        # --- Heuristics for Chart Type Selection ---

        # Heuristic 1: Time Series Data (Date/Month vs. One Numeric Value) -> Line Chart
        # Check for common date/time column names
        date_col_present = 'date' in col_names_lower or 'month' in col_names_lower or 'yearmonth' in col_names_lower
        if date_col_present and len(numeric_cols) == 1:
            # Identify the date/time column
            if 'date' in col_names_lower:
                time_col = df.columns[col_names_lower.tolist().index('date')]
            elif 'month' in col_names_lower:
                 time_col = df.columns[col_names_lower.tolist().index('month')]
            else:
                 time_col = df.columns[col_names_lower.tolist().index('yearmonth')]

            value_col = numeric_cols[0]
            logger.info(f"Attempting Line Chart: X='{time_col}', Y='{value_col}'")
            try:
                # Ensure time column is sortable (convert to datetime if needed, handle errors)
                df_sorted = df.sort_values(by=time_col)
                fig = px.line(df_sorted, x=time_col, y=value_col, title=f"{value_col.capitalize()} Trend", markers=True)
                fig.update_layout(xaxis_title=time_col.capitalize(), yaxis_title=value_col.capitalize())
            except TypeError as sort_err:
                 logger.warning(f"TypeError during sorting/plotting line chart (column '{time_col}' might not be sortable): {sort_err}. Skipping line chart.")
            except Exception as line_err:
                 logger.warning(f"Could not generate line chart: {line_err}. Skipping line chart.")

        # Heuristic 2: Categorical vs. Single Numeric -> Bar Chart (Most Common)
        # Typically shape (N rows, 2 columns) where one is numeric
        elif num_cols == 2 and len(numeric_cols) == 1:
            value_col = numeric_cols[0]
            # Find the non-numeric column assumed to be categorical
            cat_col = next((col for col in df.columns if col != value_col), None)

            if cat_col:
                logger.info(f"Attempting Bar Chart: Category='{cat_col}', Value='{value_col}'")
                try:
                    # Limit number of bars for readability - Sort descending by value first
                    max_bars = 15
                    df_agg = df.sort_values(by=value_col, ascending=False)
                    df_chart = df_agg.head(max_bars)

                    title_suffix = f" (Top {max_bars})" if len(df_agg) > max_bars else ""
                    title = f"{value_col.capitalize()} by {cat_col.capitalize()}{title_suffix}"

                    fig = px.bar(df_chart, x=cat_col, y=value_col, title=title, text_auto='.2s')
                    # Improve layout for bar values
                    fig.update_traces(textangle=0, textposition="outside")
                    fig.update_layout(xaxis_title=cat_col.capitalize(), yaxis_title=value_col.capitalize())
                except Exception as bar_err:
                    logger.warning(f"Could not generate bar chart: {bar_err}. Skipping bar chart.")
            else:
                logger.warning("Bar chart condition met (2 cols, 1 numeric) but failed to identify categorical column.")

        # Heuristic 3: Single Value Result -> No graphical chart needed
        # Example: SELECT SUM(amount)... results in 1 row, 1 numeric col
        elif num_rows == 1 and len(numeric_cols) == 1:
            logger.info("Single numeric value result. Skipping graphical chart generation.")
            # The text summary node should handle displaying this value.
            return {"chart_json": None}

        # --- Fallback ---
        # If no specific heuristic matched
        if fig is None:
            logger.info("No specific chart type matched heuristics. Skipping chart generation.")
            return {"chart_json": None}

        # --- Finalize and Serialize Chart ---
        # Apply common layout settings
        fig.update_layout(
            margin=dict(l=40, r=20, t=60, b=40), # Adjust margins as needed
            title_x=0.5, # Center title
            legend_title_text=None # Hide legend title if legend exists
        )
        chart_json = fig.to_json()
        logger.info("Plotly chart JSON generated successfully.")
        return {"chart_json": chart_json}

    except Exception as e:
        # Catch any unexpected errors during the charting process
        logger.error(f"Unexpected error during chart generation: {e}", exc_info=True)
        # Don't set the main 'error' state here, just fail to produce a chart
        return {"chart_json": None}

# Import PromptTemplate if not already imported at the top
from langchain_core.prompts import PromptTemplate # Or keep ChatPromptTemplate

def generate_response_node(state: AgentState) -> dict:
    """
    Generates the final natural language response. Uses PromptTemplate but
    removes backticks around SQL data in the template to avoid rendering issues.

    Args:
        state (AgentState): The current graph state. Needs 'original_query'.
                           Uses 'sql_results_str', 'error', 'classification',
                           and checks for 'chart_json'.

    Returns:
        dict: A dictionary containing the 'final_response' string.
    """
    logger.info("--- Executing Node: generate_response_node ---")
    query = state.get('original_query', "An unspecified query")
    sql_results = state.get('sql_results_str', '')
    error = state.get('error')
    classification = state.get('classification')
    chart_available = state.get('chart_json') is not None

    final_response = ""

    # --- Response Generation Logic ---

    # 1. Prioritize responding to errors (Same as previous versions)
    if error:
        logger.warning(f"Generating response based on detected error: {error}")
        error_str = str(error)
        # ... (error handling logic remains the same) ...
        if "Failed to execute SQL" in error_str or "syntax error" in error_str.lower():
            final_response = f"I encountered an issue trying to retrieve the data ({error_str}). Perhaps try asking differently?"
        elif "Failed to generate SQL" in error_str:
             final_response = f"I had trouble understanding how to fetch the data ({error_str}). Could you please rephrase?"
        elif "Failed to classify query" in error_str:
             final_response = f"I had trouble understanding your request type ({error_str}). Could you clarify?"
        else: # Generic error
            final_response = f"I'm sorry, I encountered an issue: {error_str}. Please try again."


    # 2. Handle irrelevant classification (Same as previous versions)
    elif classification == 'irrelevant':
         final_response = "This question doesn't seem related to your financial expenses. Could you ask something about your spending?"
         logger.info("Generated response for 'irrelevant' classification.")

    # 3. Handle no results (Same as previous versions)
    elif not error and (not sql_results or sql_results == "Query returned no results."):
         final_response = "I looked through your expense records based on your query, but couldn't find any matching transactions."
         logger.info("Generated response for query with no results.")

    # 4. Generate a summary response based on successful SQL results
    elif not error and sql_results:
        logger.info("Generating summary response using PromptTemplate (no backticks).")
        chart_mention = "I've also prepared a chart to visualize this." if chart_available else ""

        # *** TEMPLATE WITHOUT BACKTICKS AROUND DATA ***
        # Define the template string with clear placeholders, omitting ```
        template_string = """System: You are a friendly financial assistant. Summarize the retrieved data based on the user's question.

Instructions:
*   Answer the user's question ({user_query}) using the key information from the data below.
*   Summarize findings/trends if data is tabular. State single numbers clearly. Do NOT just repeat the raw data.
*   {chart_mention_instruction} Mention the chart briefly if applicable.
*   Keep the tone conversational (use "You"/"Your"). Avoid jargon.

Retrieved Data:
{sql_data}

Assistant: """ 

        # Create the PromptTemplate object
        prompt = PromptTemplate(
            template=template_string,
            input_variables=["user_query", "sql_data", "chart_mention_instruction"]
        )
        # *** END OF TEMPLATE MODIFICATION ***

        # Create the chain
        chain = prompt | LLM

        try:
            if LLM is None: raise ValueError("LLM client is not initialized.")

            # Prepare the input dictionary
            input_dict = {
                "user_query": query,
                "sql_data": sql_results,
                "chart_mention_instruction": chart_mention
            }

            # Invoke the chain
            response = chain.invoke(input_dict)
            final_response = response.content.strip()
            logger.info("Successfully generated summary response from LLM.")

        except Exception as e:
            logger.error(f"LLM call failed during final response generation: {e}", exc_info=True)
            # Include raw results in fallback, even without backticks in prompt
            final_response = f"I retrieved the data:\n{sql_results}\nBut I had trouble summarizing it."

    # 5. Fallback (Same as previous versions)
    else:
        logger.error("Reached end of generate_response_node without generating a response. State: %s", state)
        final_response = "I'm sorry, I wasn't able to determine a response for your query."

    # Ensure final_response is always set (Same as previous versions)
    if not final_response:
        logger.warning("Final response was empty after processing, providing default.")
        final_response = "I'm sorry, I couldn't process that request properly."

    return {"final_response": final_response}

# ==========================================================================
#                       EDGE LOGIC FUNCTION
# ==========================================================================

def should_continue(state: AgentState) -> str:
    """
    Determines the next node to execute based on the current state,
    specifically the query classification or presence of errors.

    Args:
        state (AgentState): The current graph state.

    Returns:
        str: The name of the next node to call ('generate_sql', 'generate_response'),
             or potentially END (though current logic routes errors to response).
    """
    logger.info("--- Evaluating Edge: should_continue ---")
    classification = state.get('classification')
    error = state.get('error') # Check if ANY previous node set an error

    # Priority 1: Handle errors immediately by routing to final response generation
    # The generate_response_node is responsible for formatting the error message.
    if error:
        logger.warning(f"Error detected in state ('{error}'), routing directly to 'generate_response'.")
        return "generate_response"

    # Priority 2: Handle irrelevant classification
    elif classification == 'irrelevant':
        logger.info("Classification is 'irrelevant', routing to 'generate_response'.")
        return "generate_response"

    # Priority 3: Proceed with data retrieval for simple/advanced queries
    elif classification in ['simple', 'advanced']:
        logger.info(f"Classification is '{classification}', routing to 'generate_sql'.")
        return "generate_sql"

    # Fallback: This case indicates an issue, likely with the classification node.
    # Route to response node to report the internal issue.
    else:
        logger.error(f"Unknown or missing classification ('{classification}') in state. Routing to generate_response.")
        # We don't set the error here, let generate_response handle the lack of valid path.
        # Alternatively, could set state['error'] = "Internal classification error" here.
        return "generate_response"

# ==========================================================================
#                       GRAPH DEFINITION
# ==========================================================================

logger.info("Defining LangGraph workflow structure...")

# Initialize the state graph with our AgentState definition
workflow = StateGraph(AgentState)
logger.debug("StateGraph initialized.")

# Add the nodes to the graph, associating a name with each function
workflow.add_node("classify_query", classify_query_node)
workflow.add_node("generate_sql", generate_sql_node)
workflow.add_node("execute_sql", execute_sql_node)
workflow.add_node("generate_chart", generate_chart_node)
workflow.add_node("generate_response", generate_response_node)
logger.info("Nodes added to the graph: classify_query, generate_sql, execute_sql, generate_chart, generate_response")

# Define the entry point of the graph
workflow.set_entry_point("classify_query")
logger.info("Graph entry point set to 'classify_query'.")

# Define the conditional edge after the classification node.
# The 'should_continue' function will determine which node to go to next.
workflow.add_conditional_edges(
    start_node_name="classify_query", # The node where the decision is made
    condition=should_continue,        # The function that returns the next node's name
    # A dictionary mapping the possible return values of 'condition'
    # to the actual names of the next nodes to execute.
    conditional_edge_mapping={
        "generate_sql": "generate_sql",        # If should_continue returns "generate_sql"
        "generate_response": "generate_response" # If should_continue returns "generate_response" (for errors or irrelevant)
        # We don't map END here, as both paths lead to further processing nodes.
    }
)
logger.info("Conditional edge added from 'classify_query' based on 'should_continue' logic.")

# Define the linear flow for the main data processing path
# Connect nodes sequentially after the conditional split directs to 'generate_sql'
workflow.add_edge("generate_sql", "execute_sql")
workflow.add_edge("execute_sql", "generate_chart")
workflow.add_edge("generate_chart", "generate_response")
logger.info("Linear edges defined: generate_sql -> execute_sql -> generate_chart -> generate_response.")

# Define the final step: after generating the response, the graph ends.
workflow.add_edge("generate_response", END) # END is a special marker from langgraph.graph
logger.info("Final edge added from 'generate_response' to END.")

# ==========================================================================
#                       Compile & Assign Entry Point Variable ('graph')
# ==========================================================================

# Compile the workflow into a runnable application object
# The compiled object MUST be assigned to the variable name 'graph'
# as defined in langgraph.json
graph = workflow.compile()
logger.info("LangGraph workflow compiled successfully. Runnable 'graph' object created.")

# Optional: Add a simple test execution block (useful during development)
# This will only run if you execute graph.py directly (python src/agent/graph.py)
if __name__ == "__main__":
    logger.info("--- Running Direct Script Test ---")
    # Example test invocation (replace with relevant queries)
    test_queries = [
        "What was my total spend last month?",
        "Show my grocery expenses",
        "what is the weather?",
        "Compare spending between Anirban and Puspita for Rent",
        "Generate a query with syntax error deliberately" # Example for testing error path
    ]
    test_input = {"original_query": test_queries[0]} # Change index to test different queries

    logger.info(f"Test Input: {test_input}")
    try:
        # Use stream to see the steps
        for output_chunk in graph.stream(test_input, {"recursion_limit": 10}):
            # output is a dictionary where keys are node names, values are output dicts
            node_name = list(output_chunk.keys())[0]
            node_data = output_chunk[node_name]
            logger.info(f"--- Step Output: {node_name} ---")
            # Log relevant parts of the node output (avoid printing large dataframes directly)
            log_output = {k: (v[:100] + '...' if isinstance(v, str) and len(v) > 100 else v)
                          for k, v in node_data.items() if k != 'sql_results_df'} # Exclude df for brevity
            logger.info(f"{log_output}")

        # Optionally invoke again to get final state easily (can be large)
        # final_state = graph.invoke(test_input, {"recursion_limit": 10})
        # logger.info(f"--- Final State ---")
        # logger.info(json.dumps(final_state, indent=2, default=str)) # Use default=str for non-serializable like DataFrame

    except Exception as e:
        logger.error(f"Test execution failed: {e}", exc_info=True)

    logger.info("--- Direct Script Test Complete ---")
"""

File: state.py
Location: assistant\finance-assistant\src\agent\state.py
Summary: The file defines the `AgentState` class using `TypedDict` to represent the state shared across an agent graph. It includes fields for the user's original query, query classification, generated SQL query and results, chart data, final response, and error handling.
Code: """
# assistant/finance-assistant/src/agent/state.py
"""Define the state structures for the agent."""

from __future__ import annotations # Ensures compatibility with type hints

# Use typing.TypedDict for standard LangGraph state
from typing import TypedDict, Optional, List, Dict, Any
import pandas as pd

# Define the structure of the state that will be passed between nodes
class AgentState(TypedDict):
    """Represents the state shared across the agent graph."""
    original_query: str           # The initial question from the user
    classification: Optional[str]   # 'simple', 'advanced', 'irrelevant'
    sql_query: Optional[str]        # Generated SQL query
    sql_results_str: Optional[str]  # SQL results as a formatted string
    sql_results_df: Any             # SQL results as a Pandas DataFrame (use Any for now, handle serialization if needed)
    chart_json: Optional[str]       # Plotly figure JSON representation
    final_response: Optional[str]   # Final text response for the user
    error: Optional[str]            # To capture errors during execution
"""

File: __init__.py
Location: assistant\finance-assistant\src\agent\__init__.py
Summary: The file introduces a new module called "New LangGraph Agent," which defines a custom graph by importing the `graph` from `agent.graph`. The `__all__` list specifies that only `graph` is intended for public use from this module.
Code: """
"""New LangGraph Agent.

This module defines a custom graph.
"""

from agent.graph import graph

__all__ = ["graph"]

"""

File: studio_ui.png
Location: assistant\finance-assistant\static\studio_ui.png
Summary: I'm unable to access the contents of the file to provide a summary. Please try again by providing the text or key details from the file.
Code: """
Unable to read file.
"""

File: test_graph.py
Location: assistant\finance-assistant\tests\integration_tests\test_graph.py
Summary: This code is a test file using `pytest` and `langsmith` to test an asynchronous function `test_agent_simple_passthrough`. It invokes the `graph.ainvoke` function with a dictionary input and asserts that the result is not `None`.
Code: """
import pytest
from langsmith import unit

from agent import graph


@pytest.mark.asyncio
@unit
async def test_agent_simple_passthrough() -> None:
    res = await graph.ainvoke({"changeme": "some_val"})
    assert res is not None

"""

File: __init__.py
Location: assistant\finance-assistant\tests\integration_tests\__init__.py
Summary: This file is a placeholder or instruction indicating that integration tests should be defined within the specified directory.
Code: """
"""Define any integration tests you want in this directory."""

"""

File: test_configuration.py
Location: assistant\finance-assistant\tests\unit_tests\test_configuration.py
Summary: This code snippet imports the `Configuration` class from the `agent.configuration` module and defines a test function `test_configuration_empty`. The function tests the `Configuration.from_runnable_config` method with an empty dictionary as input, likely to verify handling of empty configurations.
Code: """
from agent.configuration import Configuration


def test_configuration_empty() -> None:
    Configuration.from_runnable_config({})

"""

File: __init__.py
Location: assistant\finance-assistant\tests\unit_tests\__init__.py
Summary: The file is a placeholder or instruction for defining unit tests within the directory, suggesting that developers should create and include any necessary unit tests for the code present in that location.
Code: """
"""Define any unit tests you may want in this directory."""

"""

File: expenses.csv
Location: data\expenses.csv
Summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes entries for rent, household, grocery, and restaurant expenses, categorized by account holder (Anirban or Puspita), with specific sub-categories and amounts for each transaction.
Code: """
      date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
2023-01-01  2023 2023-01 2023-W52      Sunday   Puspita-SBI  Household             Maid        Monthly Maid Salary Puspita  2500.00
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI    Grocery            Other         Meat/Fish Purchase Anirban   534.04
2023-01-01  2023 2023-01 2023-W52      Sunday   Puspita-SBI    Grocery Flipkart Grocery         FK Quick Groceries Puspita  2921.10
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI Restaurant         Takeaway               Lunch Parcel Anirban   848.85
"""

File: expenses_metadata_detailed.yaml
Location: metadata\expenses_metadata_detailed.yaml
Summary: The file describes the "expenses" table, which records financial transactions for users Anirban and Puspita. Each transaction is uniquely identified by a primary key "id". Relationships map accounts to users, aiding in tracking spending, budget adherence, and financial analysis. The "id" column is a unique, auto-generated identifier.
Code: """
table_name: expenses
description: "Stores all recorded financial transactions for users Anirban and Puspita. Each row represents a single expense event. Used to track spending patterns, budget adherence, and answer financial queries."
primary_key: id # Assuming 'id' is a UUID added during DB creation

# Explicit relationship mapping derived from expense_metadata.json
relationships:
  - type: derived
    from_column: account
    to_column: user
    mapping:
      "Anirban-SBI": "Anirban"
      "Anirban-ICICI": "Anirban"
      "Puspita-SBI": "Puspita"
      "Puspita-Bandhan": "Puspita"
    description: "The 'user' is strictly determined by the 'account' used in the transaction according to this fixed mapping."

columns:
  - name: id
    data_type: TEXT # Or UUID if supported natively
    description: "Unique identifier for each transaction record. Auto-generated, not typically used in user queries."
    constraints: "Primary Key, Not Null, Unique"
    purpose_for_llm: "Internal database identifier. Avoid using in filters unless a specific transaction ID is provided."

  - name: date
    data_type: DATE # Store as ISO 8601 string 'YYYY-MM-DD' or DATE type
    description: "The exact date the transaction occurred (format: YYYY-MM-DD)."
    example_values: ["2023-10-26", "2024-01-15"]
    constraints: "Not Null"
    purpose_for_llm: "Primary column for filtering by time. Use for specific dates, date ranges (e.g., 'last month', 'this year', 'between Jan 1 2024 and Mar 31 2024'), or time-based aggregations. Always use this column for date conditions."

  - name: year
    data_type: INTEGER
    description: "The year the transaction occurred (extracted from the 'date' column)."
    example_values: [2023, 2024]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for filtering or grouping expenses by calendar year (e.g., 'total spend in 2023', 'compare 2023 vs 2024'). Less granular than 'month' or 'date'."

  - name: month
    data_type: TEXT # Format 'YYYY-MM'
    description: "The year and month the transaction occurred (extracted from the 'date' column, format: YYYY-MM)."
    example_values: ["2023-10", "2024-01"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Primary column for monthly analysis. Use for filtering or grouping by specific month (e.g., 'spend in January 2024', 'monthly trends', 'compare spending across months'). Use this when the query specifies a month or asks for monthly patterns."

  - name: week
    data_type: TEXT # Format 'YYYY-Www' (ISO week date)
    description: "The ISO week number (W01-W53) within the year the transaction occurred (extracted from the 'date' column, format YYYY-Www)."
    example_values: ["2023-W43", "2024-W03"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for filtering or grouping expenses by week (e.g., 'last week's spend', 'weekly grocery total'). Useful for short-term pattern analysis."

  - name: day_of_week
    data_type: TEXT
    description: "The name of the day the transaction occurred (e.g., Sunday, Monday)."
    example_values: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    constraints: "Derived from 'date'. Not Null."
    purpose_for_llm: "Use for analyzing spending patterns based on the day of the week (e.g., 'weekend restaurant spending', 'average spend on weekdays vs weekends')."

  - name: account
    data_type: TEXT
    description: "The specific bank account used for the transaction. Belongs to either Anirban or Puspita. Each account maps deterministically to one user."
    unique_values: ["Anirban-SBI", "Anirban-ICICI", "Puspita-SBI", "Puspita-Bandhan"]
    constraints: "Not Null. Value must be one of the predefined accounts."
    purpose_for_llm: |
        Use for filtering expenses by the source account or comparing spending across accounts.
        This column directly determines the 'user'. Refer to the 'relationships' section or the 'user' column definition for the exact mapping:
        - 'Anirban-SBI' -> 'Anirban'
        - 'Anirban-ICICI' -> 'Anirban'
        - 'Puspita-SBI' -> 'Puspita'
        - 'Puspita-Bandhan' -> 'Puspita'
        If a query mentions a user AND an account, ensure they are consistent with this mapping.

  - name: category
    data_type: TEXT
    description: "Broad classification of the expense (e.g., Rent, Grocery, Travel). Provides a high-level view of spending areas. Each Category maps to specific Sub-categories defined below."
    unique_values: ["Investment", "Rent", "Travel", "Restaurant", "Insurance Premium", "Household", "Connectivity", "Waste", "Grocery", "Beauty", "Shopping", "Health", "Utilities", "Gifts & Donations", "Entertainment", "Education"]
    constraints: "Not Null. Value must be one of the predefined categories."
    mapping: # Explicit mapping from expense_metadata.json
        Investment: ["SIP", "Mutual Funds", "Stocks", "FD/RD"]
        Rent: ["House Rent"]
        Travel: ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"]
        Restaurant: ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"]
        Insurance Premium: ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"]
        Household: ["Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning", "Pest Control", "Bike Maintenance", "Car Maintenance", "Furniture", "Kitchen Tools", "Ironing", "Maid"]
        Connectivity: ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"]
        Waste: ["Smoke", "Alcohol"]
        Grocery: ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"]
        Beauty: ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare"] # Removed duplicate Salon
        Shopping: ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"]
        Health: ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"]
        Utilities: ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"]
        Gifts & Donations: ["Family", "Friends", "Charity", "Temple"]
        Entertainment: ["Movies", "Concerts", "Games"]
        Education: ["Online Courses", "Books", "Workshops"]
    purpose_for_llm: |
        Primary column for high-level expense analysis.
        Use this when the user asks about:
        - General spending types (e.g., 'How much on Travel?').
        - Broad overviews (e.g., 'Show my spending breakdown', 'Top spending categories').
        - Comparing major areas (e.g., 'Compare Grocery vs Restaurant spending').
        - Queries about 'main expenses' or 'overall spending'.
        - Use the 'mapping' above to know valid sub-categories for a given category.

  - name: sub_category
    data_type: TEXT
    description: "Detailed classification within a Category (e.g., within 'Travel', sub-categories are 'Cab', 'Flight'). Provides finer granularity. Value MUST belong to the list associated with the transaction's 'category' in the 'category' column mapping."
    example_values: ["SIP", "House Rent", "Cab", "Dine-in", "Life Insurance", "Electricity Bill", "Airtel WiFi", "Smoke", "BigBasket", "Amazon", "Salon", "Doctor Visit", "Gas Cylinder", "Family", "Movies", "Online Courses"]
    constraints: "Can be Null/Empty if a Category has no Sub-categories (e.g., Rent). Value must correspond to the selected Category based on the predefined mapping in the 'category' column."
    purpose_for_llm: |
        Use for detailed analysis *within* a category or when specific items are mentioned.
        Prioritize using this column when the query includes terms like:
        - Specific types: 'Flights', 'SIP', 'Maid Salary', 'BigBasket', 'Netflix', 'ULIP'.
        - More detail than category: 'How much did we spend on cabs?', 'Track mutual fund investments'.
        - Ambiguity Resolution:
            - For 'Electricity Bill' payments, always use `sub_category = 'Electricity Bill'` (under `category = 'Household'`). Avoid `Utilities.Electricity` for bill payments.
            - If query mentions 'Amazon', check context. If 'Amazon groceries', use `category = 'Grocery'` AND `sub_category = 'Amazon'`. If 'Amazon shopping', use `category = 'Shopping'` AND `sub_category = 'Amazon'`. If just 'Amazon', consider filtering `WHERE sub_category = 'Amazon'` across both categories or ask for clarification.
            - For investment details (SIP, Mutual Funds etc.), use the relevant sub_category under `category = 'Investment'`.
        - Confirm the `sub_category` queried is valid for the implied or stated `category` using the mapping in the 'category' column definition.

  - name: type
    data_type: TEXT
    description: "User-provided free-text description of the specific transaction item or purpose (e.g., 'Lunch with colleagues', 'Monthly SIP deduction', 'Groceries for the week', 'Flight tickets BLR-DEL'). Can be very specific but inconsistent."
    example_values: ["Monthly House Rent Payment", "Monthly Maid Salary", "Meat/Fish Purchase", "FK Quick Groceries", "Lunch Parcel", "IRCTC Booking - Home", "Mixer Grinder", "Uber to Airport"]
    constraints: "Free text, max length approx 60 chars. Can be Null/Empty."
    purpose_for_llm: |
        Use ONLY for identifying very specific purchases when category/sub-category are too broad OR when the user provides a specific description.
        Examples:
        - 'Find the transaction for the Mixer grinder purchase'. -> `WHERE type LIKE '%Mixer grinder%'`
        - 'What was that expense description containing "Airport"?' -> `WHERE type LIKE '%Airport%'`
        - Less reliable for aggregation (SUM, AVG) due to free-text nature. Use category/sub-category for aggregation whenever possible.

  - name: user
    data_type: TEXT
    description: "The person who owns the account used for the transaction. Automatically derived from the 'account' based on a fixed mapping."
    unique_values: ["Anirban", "Puspita"]
    constraints: "Not Null. Value is strictly determined by the 'account' used, according to the mapping defined in the 'relationships' section or the 'account' column definition."
    purpose_for_llm: |
        Use for filtering or comparing expenses made by Anirban vs. Puspita. Essential for user-specific queries (e.g., 'Show my spending', 'Who spent more last month?', 'Puspita's travel costs').
        This value is derived from the 'account' column via the following fixed mapping:
        - 'Anirban-SBI' -> 'Anirban'
        - 'Anirban-ICICI' -> 'Anirban'
        - 'Puspita-SBI' -> 'Puspita'
        - 'Puspita-Bandhan' -> 'Puspita'
        Queries filtering by both user and account must be consistent with this mapping.

  - name: amount
    data_type: REAL # Or NUMERIC, DECIMAL depending on SQLite specifics for currency
    description: "The monetary value of the transaction in Indian Rupees (INR)."
    example_values: [30000.00, 2500.0, 534.04, 1409.08, 100.0]
    constraints: "Not Null. Must be a positive number."
    purpose_for_llm: |
        The primary measure of spending value.
        Use for:
        - Calculating totals, averages, sums (e.g., 'Total spend', 'Average restaurant bill').
        - Finding minimum/maximum expenses (e.g., 'Largest expense this month').
        - Filtering by value (e.g., 'transactions over 1000 INR', 'show expenses less than 50 INR'). Use operators like >, <, >=, <=.
        - Answering queries about 'high value', 'low value', or 'expensive' items by applying appropriate amount filters.
"""

File: expense_metadata.json
Location: metadata\expense_metadata.json
Summary: The file outlines a transaction record format, including a date field and account options for Anirban and Puspita. It categorizes expenses into areas such as Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
Code: """
{
    "Date": "Date of the transaction (format: YYYY-MM-DD)",
    "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],
	"categories": {
        "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
        "Rent": ["House Rent"],
        "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
        "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
        "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
        "Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ],
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
        "Waste": ["Smoke", "Alcohol"],
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
        "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare"],
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
        "Entertainment": ["Movies", "Concerts", "Games"],
        "Education": ["Online Courses", "Books", "Workshops"]
	},
    "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
    "Type": "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
    "Amount": "INR value of the transaction"
}
"""

File: agentic_ds_app_prep.txt
Location: reference\agentic_ds_app_prep.txt
Summary: The file outlines a preliminary step for implementing agentic AI, which involves generating additional data similar to a sample CSV file. The data spans from January 1, 2023, to April 20, 2025, and includes specific columns such as date, account, category, transaction type, user, and amount, with detailed formatting and content guidelines.
Code: """
## THINGS TO DO BEFORE AGENTIC AI IMPLEMENTATION

STEP 1: GENERATE MORE DATA
 - Generate more data, similar to the sample dummy_expenses.csv, from 2023.01.01 - 2025.04.20 (current date). Important considerations for data generation:
	- SUPER IMPORTANT: columns: 
	1. date: dd-mm-yyyy	
	2. year: yyyy	
	3. month: yyyy-mm	
	4. week: 2021-W01 to latest, 2025-xxx	
	5. day_of_week: {Monday, Tuesday,... Sunday} according to date, refer calendar
	6. account: "Account": [
        "Anirban-SBI",
        "Anirban-ICICI",
        "Puspita-SBI",
        "Puspita-Bandhan"
    ],	
	7. category: refer below and metadata
	8. sub_category: refer below and metadata	
	9. type: "Free text input describing the nature or name of the transaction (e.g., 'Family dinner', 'Cab to airport')",
	10. user:	 "User": {
        "Anirban-SBI": "Anirban",
        "Anirban-ICICI": "Anirban",
        "Puspita-SBI": "Puspita",
        "Puspita-Bandhan": "Puspita"
    },
	11. amount:"INR value of the transaction, max 50000"

	- IMPORTANT: Generate data accoording to day to day expenditure values in Bangalore, India for all categories to mimic real world scenario
	- Each month cannot have total spend amount more than inr 120000 and less than 60000
	- Each month cannot have more than 100 rows
	- Total rows -less than 2500 
	- IMPORTANT: Spends MUST adhere to the category-subcategory mapping:
		categories = {
    "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
    "Rent": ["House Rent"],
    "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
    "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
    "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
    "Household": [
        "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
        "Pest Control", "Bike Maintenance", "Car Maintenance", 
        "Furniture", "Kitchen Tools", "Ironing", "Maid"
    ],
    "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
    "Waste": ["Smoke", "Alcohol"],
    "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
    "Beauty": ["Nykaa", "Meesho", "Purple", "Salon", "Makeup", "Skincare", "Salon"],
    "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
    "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
    "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
    "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
    "Entertainment": ["Movies", "Concerts", "Games"],
    "Education": ["Online Courses", "Books", "Workshops"]
}
	- IMPORTANT: I have updated the categories and subcategories. Some additional information: there are only 2 users: 'Anirban' and 'Puspita'. Anirban has the following bank accouts: 'Anirban-SBI' and 'Anirban-ICICI'.  Puspita has the following bank accouts: 'Puspita-SBI' and 'Puspita-Bandhan'. I want to keep the app as simple as possible, so i am thinking of creating a database (sqlite3 / csv) with the following columns: 
	'Date': Date of transaction, 
	'Account': One of the 4 accounts for me and my wife mentioned above, 
	'Category': from the categories dictionary mentioned above, 
	'Sub-category': from the categories dictionary mentioned above, 
	'Type': Free text, we need to be able to enter it in the steamlit frontend, 
	'User': One of the 2 values: 'Anirban', "Puspita" 
	'Amount': amount of transaction.
	- IMPORTANT: "Currency Format: Just plain numbers, keep it simple!
		Frequency of Transactions: minimum: 2(atleat 1 transaction per user), maximum: 20
		Expense Bias: Should we simulate more transactions from a specific account or category (e.g., more grocery or restaurant spends)? - Grocery and household are the biggest ones, but they are less than rent. House rent: once a month, fixed, 30000 (Anirban-ICICI). Maid: once a month, fixed, 2500 (Puspita-SBI). I pay house rent, wife pays maid salary. Puspita uses Puspita-Bandhan only for Travel and beauty categories. For me, most of the daily expenses are from Anirban-ICICI, with some from Anirban-SBI.
		Include recurring transactions? Like SIPs, rent, etc. on specific days?SIP: once a month, 3000, fixed. ULIP: once a month, 4000. fixed I pay both from Anirban-ICICI.
		match the type to category and sub category. For example, if: Category - household, Subcategory - Ironing, then type has to be ironing. if the cat - Travel and subcat -train, the type has to be something like: bangalore-mysore vande bharat, type can't be 'lab test', In summary, the type has to make sense for category and subcategory. Also, Puspita uses her bandhan for travel and rarely something else. In travel also, she will mainly use it to book train / flight tickets, not pay  parking fees, I pay that. Please generate data accordingly.
		
	- IMPORTANT: Spend trends, fixed values and behaviour
		- Fixed spends: "Investment": ["SIP" - 3000, "Mutual Funds" - 0 (None for now), "Stocks" - 0 (None for now), "FD/RD"0 (None for now)],
        "Rent": ["House Rent" - inr 30000] - all once a month, with fixed values
		"Insurance Premium": ["Life Insurance" - 55000 twice a year on 20th march and 20th september, "ULIP" - 4000 every month between 20th - 25th, "Health Insurance" - lets say 1200 every month between 20th - 25th, "Vehicle Insurance" - once a year, 0 for now]
		"Household": [
            "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
            "Pest Control", "Bike Maintenance", "Car Maintenance",
            "Furniture", "Kitchen Tools", "Ironing", "Maid"
        ], - many have 2 month (Electricity bill) or 1 month (Maid) cycles or ad hoc costs (everything else in "Household") 
        "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"], - many have 6 month (Airtel WiFi) or 3 month ( "Jio Recharge", "Airtel Mobile") cycles or ad hoc costs (everything else in "Connectivity") 
		- Category wise spends: 
		"Waste": ["Smoke", "Alcohol"], - ad hoc, a small percentage of total, variable weekly and monthly, alcohol max once a month
        "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"], - ad hoc, concentrated on the first week of the month (after salary, salary is not tracked in the data), smaller spends dotted throughout the month
        "Beauty": ["Nykaa", "Meesho", "Purplle", "Salon", "Makeup", "Skincare", "Salon"],- ad hoc, spends dotted throughout the month
        "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"], - ad hoc, concentrated on the first week of the month (after salary, salary is not tracked in the data), smaller spends dotted throughout the month
        "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],- ad hoc, spends dotted throughout the month
        "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],- electricity bill - 2 month cycle, gas cylinder - 2 month cycle, rest ad hoc, spends dotted throughout the month
        "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],ad hoc, small amounts, spends dotted throughout the month
        "Entertainment": ["Movies", "Concerts", "Games"],ad hoc, small amounts, spends dotted throughout the month
        "Education": ["Online Courses", "Books", "Workshops"] ad hoc, small amounts, spends dotted throughout the month
 

		
		
		
		
		
		
		
		
		

"""

File: data_analysis.ipynb
Location: reference\data_analysis.ipynb
Summary: The file outlines an Exploratory Data Analysis (EDA) process for personal finance data, focusing on validating the structure and realism of the dataset `dummy_expenses_generated.csv` for AI/ML tasks. It mentions data sources and references, and imports libraries like pandas, numpy, and plotly for analysis and visualization.
Code: """
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Exploratory Data Analysis (EDA) for Personal Finance Data (v2)\n",
    "\n",
    "**Objective:** Analyze the generated expense data (`dummy_expenses_generated.csv`) to validate its structure, adherence to generation rules, realism, and suitability for downstream AI/ML tasks (Phase 2 Assistant). Plots will be displayed inline.\n",
    "\n",
    "**Data Source:** `../dummy_expenses_generated.csv` (Relative path from `reference/` to project root)\n",
    "**Ruleset Reference:** `../sample_data_generation.csv`\n",
    "**Metadata Reference:** `../expense_metadata.json`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "fcb1b6c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "import json\n",
    "from pathlib import Path\n",
    "import datetime\n",
    "import logging\n",
    "import os # Import os for directory creation\n",
    "from typing import Optional, Dict, Any # For type hints\n",
    "\n",
    "# Configure logging for analysis insights\n",
    "logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "86a4f331",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Setup Paths and Create Output Directory ---\n",
    "\n",
    "# Define file paths relative to the notebook location (reference/)\n",
    "NOTEBOOK_DIR = Path().resolve() # Should be the reference folder when running notebook there\n",
    "PROJECT_ROOT = NOTEBOOK_DIR.parent\n",
    "DATA_FILE = PROJECT_ROOT / \"dummy_expenses_generated.csv\"\n",
    "RULES_FILE = PROJECT_ROOT / \"sample_data_generation.csv\"\n",
    "METADATA_FILE = PROJECT_ROOT / \"expense_metadata.json\"\n",
    "\n",
    "# Define image output directory (though we won't save by default now)\n",
    "IMG_DIR = NOTEBOOK_DIR / \"img\"\n",
    "\n",
    "# Optionally ensure the image directory exists if you uncomment saving later\n",
    "# try:\n",
    "#     os.makedirs(IMG_DIR, exist_ok=True)\n",
    "#     logging.info(f\"Image output directory exists or created: {IMG_DIR}\")\n",
    "# except OSError as e:\n",
    "#     logging.error(f\"Could not create image directory {IMG_DIR}: {e}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f596d3c0",
   "metadata": {},
   "source": [
    "## Helper Function: Load Rules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "2a2675ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- Helper Function: Load Rules (Moved here to be defined before use) ---\n",
    "def load_rules(filepath: Path) -> Optional[pd.DataFrame]:\n",
    "    \"\"\"Loads and preprocesses the ruleset CSV.\"\"\"\n",
    "    if not filepath.exists():\n",
    "        logging.error(f\"Rules file not found: {filepath}\")\n",
    "        return None\n",
    "    try:\n",
    "        df_rules = pd.read_csv(filepath)\n",
    "        # Clean column names if needed (assuming they are already clean based on previous step)\n",
    "        df_rules.columns = [col.strip() for col in df_rules.columns]\n",
    "        # Split the valid types string into a list\n",
    "        # Handle potential errors if the column doesn't exist or has NaNs\n",
    "        if 'Valid-expense-types' in df_rules.columns:\n",
    "             df_rules['Valid-expense-types'] = df_rules['Valid-expense-types'].fillna('').astype(str).str.split('|')\n",
    "        else:\n",
    "             logging.warning(\"'Valid-expense-types' column not found in rules file.\")\n",
    "             df_rules['Valid-expense-types'] = [[] for _ in range(len(df_rules))] # Add empty list\n",
    "\n",
    "        # Convert amount/count columns to numeric, coercing errors\n",
    "        for col in ['Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']:\n",
    "            if col in df_rules.columns:\n",
    "                df_rules[col] = pd.to_numeric(df_rules[col], errors='coerce')\n",
    "            else:\n",
    "                logging.warning(f\"Column '{col}' not found in rules file.\")\n",
    "                df_rules[col] = np.nan # Add column with NaN if missing\n",
    "\n",
    "        # Fill missing Max-times with a default (e.g., 5) or handle based on frequency\n",
    "        df_rules['Max-times-per-month'].fillna(5, inplace=True)\n",
    "        df_rules['Max-times-per-month'] = df_rules['Max-times-per-month'].astype(int)\n",
    "\n",
    "        # Define critical columns needed from rules file\n",
    "        critical_rule_cols = ['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency', 'Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']\n",
    "        missing_critical = [col for col in critical_rule_cols if col not in df_rules.columns]\n",
    "        if missing_critical:\n",
    "            logging.error(f\"Rules file is missing critical columns: {missing_critical}\")\n",
    "            return None\n",
    "\n",
    "        # Drop rows with missing critical numeric info after conversion attempts\n",
    "        df_rules.dropna(subset=['Min-expenses-amount', 'Max-expenses-amount'], inplace=True)\n",
    "        # Drop rows with missing critical categorical info\n",
    "        df_rules.dropna(subset=['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency'], inplace=True)\n",
    "\n",
    "        logging.info(f\"Loaded and preprocessed {len(df_rules)} rules from {filepath}\")\n",
    "        return df_rules\n",
    "    except Exception as e:\n",
    "        logging.error(f\"Error loading or processing rules file {filepath}: {e}\", exc_info=True)\n",
    "        return None"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e32c188",
   "metadata": {},
   "source": [
    "## 1. Load Data and Basic Checks\n",
    "\n",
    "Load the generated CSV, parse dates correctly using the 'dd-mm-yyyy' format, check basic info, data types, and null values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "55eae2b5",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Attempting to load data from: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\dummy_expenses_generated.csv\n",
      "INFO: Reference ruleset: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\sample_data_generation.csv\n",
      "INFO: Reference metadata: E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\expense_metadata.json\n",
      "INFO: Successfully loaded E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\dummy_expenses_generated.csv. Shape: (951, 11)\n",
      "INFO: Successfully loaded metadata from E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\expense_metadata.json\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 951 rows.\n"
     ]
    }
   ],
   "source": [
    "logging.info(f\"Attempting to load data from: {DATA_FILE}\")\n",
    "logging.info(f\"Reference ruleset: {RULES_FILE}\")\n",
    "logging.info(f\"Reference metadata: {METADATA_FILE}\")\n",
    "\n",
    "# Load the generated data\n",
    "try:\n",
    "    df = pd.read_csv(DATA_FILE)\n",
    "    logging.info(f\"Successfully loaded {DATA_FILE}. Shape: {df.shape}\")\n",
    "    print(f\"Loaded {len(df)} rows.\")\n",
    "except FileNotFoundError:\n",
    "    logging.error(f\"Data file not found at {DATA_FILE}. Please ensure it's generated in the project root.\")\n",
    "    df = pd.DataFrame() # Create empty df to avoid downstream errors\n",
    "except Exception as e:\n",
    "    logging.error(f\"Error loading data CSV {DATA_FILE}: {e}\", exc_info=True)\n",
    "    df = pd.DataFrame()\n",
    "\n",
    "# Load metadata for validation checks\n",
    "try:\n",
    "    with open(METADATA_FILE, 'r') as f:\n",
    "        metadata = json.load(f)\n",
    "    logging.info(f\"Successfully loaded metadata from {METADATA_FILE}\")\n",
    "except Exception as e:\n",
    "    logging.error(f\"Could not load metadata file {METADATA_FILE}: {e}\")\n",
    "    metadata = {} # Assign empty dict if load fails"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "5d905392",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Converted 'date' column to datetime objects ('date_dt').\n",
      "INFO: All dates successfully parsed.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Data Info ---\n",
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 951 entries, 0 to 950\n",
      "Data columns (total 11 columns):\n",
      " #   Column        Non-Null Count  Dtype  \n",
      "---  ------        --------------  -----  \n",
      " 0   date          951 non-null    object \n",
      " 1   year          951 non-null    int64  \n",
      " 2   month         951 non-null    object \n",
      " 3   week          951 non-null    object \n",
      " 4   day_of_week   951 non-null    object \n",
      " 5   account       951 non-null    object \n",
      " 6   category      951 non-null    object \n",
      " 7   sub_category  951 non-null    object \n",
      " 8   type          951 non-null    object \n",
      " 9   user          951 non-null    object \n",
      " 10  amount        951 non-null    float64\n",
      "dtypes: float64(1), int64(1), object(9)\n",
      "memory usage: 81.9+ KB\n",
      "\n",
      "--- Date Conversion ---\n"
     ]
    }
   ],
   "source": [
    "# Display basic information if data loaded\n",
    "if not df.empty:\n",
    "    print(\"\\n--- Data Info ---\")\n",
    "    df.info()\n",
    "\n",
    "    # Convert 'date' column from dd-mm-yyyy string to datetime objects for analysis\n",
    "    print(\"\\n--- Date Conversion ---\")\n",
    "    try:\n",
    "        # Explicitly use dayfirst=True or format='%d-%m-%Y'\n",
    "        df['date_dt'] = pd.to_datetime(df['date'], format='%d-%m-%Y', errors='coerce')\n",
    "        logging.info(\"Converted 'date' column to datetime objects ('date_dt').\")\n",
    "\n",
    "        # Check for any conversion errors\n",
    "        null_dates = df['date_dt'].isnull().sum()\n",
    "        if null_dates > 0:\n",
    "            logging.warning(f\"Found {null_dates} rows with invalid date formats that couldn't be parsed to 'dd-mm-yyyy'.\")\n",
    "            # Optional: Display problematic rows\n",
    "            # print(\"\\nRows with date parsing errors:\")\n",
    "            # print(df[df['date_dt'].isnull()]['date'])\n",
    "            df.dropna(subset=['date_dt'], inplace=True) # Remove rows with invalid dates for analysis\n",
    "            logging.info(f\"Removed rows with invalid dates. New shape: {df.shape}\")\n",
    "        else:\n",
    "            logging.info(\"All dates successfully parsed.\")\n",
    "\n",
    "    except KeyError:\n",
    "        logging.error(\"Column 'date' not found in the CSV.\")\n",
    "    except Exception as e:\n",
    "        logging.error(f\"Error during date conversion: {e}\", exc_info=True)\n",
    "\n",
    "else:\n",
    "    print(\"DataFrame is empty. Cannot perform further analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d2692605",
   "metadata": {},
   "source": [
    "## 2. Data Range and Null Value Check\n",
    "\n",
    "Verify the date range covers the expected period and check for unexpected missing values in core columns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "77c097ac",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: Data ends earlier (2025-04-15) than expected (2025-04-20).\n",
      "INFO: No unexpected null values found in critical columns (sub_category/type might have blanks/nulls).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Date Range Check ---\n",
      "Data spans from: 2023-01-01 to 2025-04-15\n",
      "\n",
      "--- Null Value Check ---\n",
      "Columns with Null/NaN values:\n",
      "Series([], dtype: int64)\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns:\n",
    "    min_date = df['date_dt'].min()\n",
    "    max_date = df['date_dt'].max()\n",
    "    print(f\"\\n--- Date Range Check ---\")\n",
    "    print(f\"Data spans from: {min_date.strftime('%Y-%m-%d')} to {max_date.strftime('%Y-%m-%d')}\")\n",
    "\n",
    "    expected_start = datetime.datetime(2023, 1, 1)\n",
    "    expected_end = datetime.datetime(2025, 4, 20)\n",
    "\n",
    "    if min_date.date() > expected_start.date():\n",
    "        logging.warning(f\"Data starts later ({min_date.date()}) than expected ({expected_start.date()}).\")\n",
    "    if max_date.date() < expected_end.date():\n",
    "        logging.warning(f\"Data ends earlier ({max_date.date()}) than expected ({expected_end.date()}).\")\n",
    "\n",
    "    print(\"\\n--- Null Value Check ---\")\n",
    "    null_counts = df.isnull().sum()\n",
    "    print(\"Columns with Null/NaN values:\")\n",
    "    print(null_counts[null_counts > 0]) # Only show columns with nulls\n",
    "\n",
    "    # Check critical columns - adjust if 'sub_category' or 'type' can legitimately be empty strings instead of NaN\n",
    "    critical_cols = ['date', 'year', 'month', 'week', 'day_of_week', 'account', 'category', 'user', 'amount', 'date_dt']\n",
    "    unexpected_nulls = null_counts.reindex(critical_cols, fill_value=0).sum() > 0 # Use reindex to handle missing cols safely\n",
    "\n",
    "    if unexpected_nulls:\n",
    "        logging.error(\"UNEXPECTED null values found in critical columns! Review data generation.\")\n",
    "    else:\n",
    "        logging.info(\"No unexpected null values found in critical columns (sub_category/type might have blanks/nulls).\")\n",
    "else:\n",
    "     print(\"Skipping range/null checks as DataFrame is empty or date conversion failed.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cff3bca3",
   "metadata": {},
   "source": [
    "## 3. Constraint Validation: Row Counts\n",
    "\n",
    "Check if the number of transactions per month adheres to the `MONTHLY_MAX_ROWS = 100` limit."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "fac25dab",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (YYYY-MM)=%{x}<br>Number of Transactions=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "LyUjGyMaHScpJx8iHhwgGh0iIhwmJiElHigrHw==",
          "dtype": "i1"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "annotations": [
         {
          "showarrow": false,
          "text": "Max Limit (100)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 100,
          "yanchor": "bottom",
          "yref": "y"
         }
        ],
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "shapes": [
         {
          "line": {
           "color": "red",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 100,
          "y1": 100,
          "yref": "y"
         }
        ],
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Number of Transactions per Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Number of Transactions"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Monthly row counts are within the limit (<= 100).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Row Count Validation ---\n",
      "Maximum rows found in a single month: 47\n",
      "Total rows generated: 951\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    monthly_row_counts = df.groupby('month').size().reset_index(name='transaction_count')\n",
    "\n",
    "    fig_row_counts = px.bar(monthly_row_counts, x='month', y='transaction_count',\n",
    "                            title='Number of Transactions per Month',\n",
    "                            labels={'month': 'Month (YYYY-MM)', 'transaction_count': 'Number of Transactions'},\n",
    "                            height=400)\n",
    "    fig_row_counts.add_hline(y=100, line_dash=\"dash\", line_color=\"red\", annotation_text=\"Max Limit (100)\")\n",
    "    fig_row_counts.update_layout(xaxis_tickangle=-45)\n",
    "    fig_row_counts.show() # Display inline\n",
    "\n",
    "    # Save image (Commented out)\n",
    "    # try:\n",
    "    #     img_path = IMG_DIR / \"monthly_transaction_counts.png\"\n",
    "    #     fig_row_counts.write_image(img_path)\n",
    "    #     logging.info(f\"Saved monthly row counts plot to {img_path}\")\n",
    "    # except Exception as e:\n",
    "    #     logging.error(f\"Failed to save monthly row counts plot: {e}\")\n",
    "\n",
    "\n",
    "    # Discrepancy Check\n",
    "    max_rows_in_month = monthly_row_counts['transaction_count'].max()\n",
    "    print(f\"\\n--- Row Count Validation ---\")\n",
    "    print(f\"Maximum rows found in a single month: {max_rows_in_month}\")\n",
    "    if max_rows_in_month > 100:\n",
    "        exceeding_months = monthly_row_counts[monthly_row_counts['transaction_count'] > 100]['month'].tolist()\n",
    "        logging.error(f\"Monthly row count limit (>100) EXCEEDED! Max found: {max_rows_in_month}. Check months: {exceeding_months}\")\n",
    "    else:\n",
    "        logging.info(\"Monthly row counts are within the limit (<= 100).\")\n",
    "\n",
    "    total_rows = df.shape[0]\n",
    "    print(f\"Total rows generated: {total_rows}\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping row count validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9e3fde44",
   "metadata": {},
   "source": [
    "## 4. Constraint Validation: Monthly Totals\n",
    "\n",
    "Verify if the total spending per month falls within the target range of ₹60,000 - ₹120,000."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "48fd2dc7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (YYYY-MM)=%{x}<br>Total Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "16NwPVrD/kCkcD0KD/j+QM3MzMxcKgZBCtejcLkA/0D2KFyPsrH+QPYoXI/+Wv9ASOF6FD4m/0CamZmZ2V7/QFK4HoUzHgZBhetRuE4C/0CamZmZTTb/QIXrUbhWxf5A61G4HksjAEHsUbgeFU7/QD4K16MyYQZBzczMzDzO/0AfhetRWNz+QNejcD22GP9AH4XrURwg/0DhehSuI7P9QBSuR+EaTQZB9ihcj96d/UAfhetRhCj/QOtRuB4ZPf5AAAAAABQV/0BxPQrXJxb+QEjhehTiCwZBj8L1KKS0/kA=",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "annotations": [
         {
          "showarrow": false,
          "text": "Min Target (60k)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 60000,
          "yanchor": "bottom",
          "yref": "y"
         },
         {
          "showarrow": false,
          "text": "Max Target (120k)",
          "x": 1,
          "xanchor": "right",
          "xref": "x domain",
          "y": 120000,
          "yanchor": "bottom",
          "yref": "y"
         }
        ],
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "shapes": [
         {
          "line": {
           "color": "orange",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 60000,
          "y1": 60000,
          "yref": "y"
         },
         {
          "line": {
           "color": "red",
           "dash": "dash"
          },
          "type": "line",
          "x0": 0,
          "x1": 1,
          "xref": "x domain",
          "y0": 120000,
          "y1": 120000,
          "yref": "y"
         }
        ],
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Total Spending per Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "tickprefix": "₹",
         "title": {
          "text": "Total Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: All monthly totals meet or exceed the minimum target (₹60,000).\n",
      "ERROR: 22 months found SIGNIFICANTLY ABOVE ₹120,000 target (>5% overshoot): ['2023-01', '2023-02', '2023-03', '2023-04', '2023-06', '2023-07', '2023-08', '2023-09', '2023-10', '2023-11', '2023-12', '2024-01', '2024-02', '2024-03', '2024-04', '2024-05', '2024-06', '2024-07', '2024-09', '2024-11', '2025-01', '2025-03']\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Monthly Total Validation ---\n",
      "Minimum monthly total found: ₹121,309.91\n",
      "Maximum monthly total found: ₹183,334.33\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns and 'amount' in df.columns:\n",
    "    monthly_totals = df.groupby('month')['amount'].sum().reset_index(name='total_amount')\n",
    "\n",
    "    fig_monthly_totals = px.bar(monthly_totals, x='month', y='total_amount',\n",
    "                                title='Total Spending per Month',\n",
    "                                labels={'month': 'Month (YYYY-MM)', 'total_amount': 'Total Amount (INR)'},\n",
    "                                height=400)\n",
    "    fig_monthly_totals.add_hline(y=60000, line_dash=\"dash\", line_color=\"orange\", annotation_text=\"Min Target (60k)\")\n",
    "    fig_monthly_totals.add_hline(y=120000, line_dash=\"dash\", line_color=\"red\", annotation_text=\"Max Target (120k)\")\n",
    "    fig_monthly_totals.update_layout(yaxis_tickprefix=\"₹\", xaxis_tickangle=-45)\n",
    "    fig_monthly_totals.show() # Display inline\n",
    "\n",
    "    # Save image (Commented out)\n",
    "    # try:\n",
    "    #     img_path = IMG_DIR / \"monthly_total_spending.png\"\n",
    "    #     fig_monthly_totals.write_image(img_path)\n",
    "    #     logging.info(f\"Saved monthly total spending plot to {img_path}\")\n",
    "    # except Exception as e:\n",
    "    #     logging.error(f\"Failed to save monthly total spending plot: {e}\")\n",
    "\n",
    "    # Discrepancy Check\n",
    "    min_monthly_total = monthly_totals['total_amount'].min()\n",
    "    max_monthly_total = monthly_totals['total_amount'].max()\n",
    "    months_below_min = monthly_totals[monthly_totals['total_amount'] < 60000]\n",
    "    months_above_max = monthly_totals[monthly_totals['total_amount'] > 120000]\n",
    "\n",
    "    print(f\"\\n--- Monthly Total Validation ---\")\n",
    "    print(f\"Minimum monthly total found: ₹{min_monthly_total:,.2f}\")\n",
    "    print(f\"Maximum monthly total found: ₹{max_monthly_total:,.2f}\")\n",
    "\n",
    "    if not months_below_min.empty:\n",
    "        logging.warning(f\"{len(months_below_min)} months found BELOW ₹60,000 target: {months_below_min['month'].tolist()}\")\n",
    "    else:\n",
    "        logging.info(\"All monthly totals meet or exceed the minimum target (₹60,000).\")\n",
    "\n",
    "    if not months_above_max.empty:\n",
    "        # Allow slightly above (e.g. 5%) due to fixed costs potentially pushing it over\n",
    "        months_significantly_above_max = monthly_totals[monthly_totals['total_amount'] > 120000 * 1.05]\n",
    "        if not months_significantly_above_max.empty:\n",
    "            logging.error(f\"{len(months_significantly_above_max)} months found SIGNIFICANTLY ABOVE ₹120,000 target (>5% overshoot): {months_significantly_above_max['month'].tolist()}\")\n",
    "        else:\n",
    "            logging.warning(f\"{len(months_above_max)} months found slightly above ₹120,000 target (<=5% overshoot - check if acceptable): {months_above_max['month'].tolist()}\")\n",
    "    else:\n",
    "        logging.info(\"All monthly totals are within or acceptably close to the maximum target (<= ₹120,000).\")\n",
    "else:\n",
    "    print(\"Skipping monthly total validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83bfb2b9",
   "metadata": {},
   "source": [
    "## 5. Mapping Validation: User vs. Account\n",
    "\n",
    "Ensure that the `user` column correctly corresponds to the `account` column based on the metadata rules."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "3965f380",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- User-Account Mapping Validation ---\n",
      "Observed User-Account Combinations (Transaction Counts):\n",
      "account  Anirban-ICICI  Anirban-SBI  Puspita-Bandhan  Puspita-SBI\n",
      "user                                                             \n",
      "Anirban            412          101                0            0\n",
      "Puspita              0            0               62          376\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0d0d09cefa9a4d088150bc1871e4b369",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Checking User-Account:   0%|          | 0/951 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: User-Account mapping appears consistent with metadata for all transactions.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and metadata and 'User' in metadata:\n",
    "    print(\"\\n--- User-Account Mapping Validation ---\")\n",
    "    # Display counts of each combination\n",
    "    user_account_crosstab = pd.crosstab(df['user'], df['account'])\n",
    "    print(\"Observed User-Account Combinations (Transaction Counts):\")\n",
    "    print(user_account_crosstab)\n",
    "\n",
    "    # Discrepancy Check against metadata\n",
    "    valid_map = metadata.get(\"User\", {})\n",
    "    invalid_combos_found = False\n",
    "    checked_accounts = set()\n",
    "\n",
    "    # Use tqdm if iterating over many rows, otherwise direct iteration is fine\n",
    "    from tqdm.notebook import tqdm # Use notebook version\n",
    "    for index, row in tqdm(df.iterrows(), total=df.shape[0], desc=\"Checking User-Account\"):\n",
    "    # for index, row in df.iterrows(): # Direct iteration for <2500 rows is okay\n",
    "        account = row['account']\n",
    "        user = row['user']\n",
    "        # Avoid re-checking same account if metadata is missing\n",
    "        if account in checked_accounts: continue\n",
    "\n",
    "        expected_user = valid_map.get(account)\n",
    "\n",
    "        if expected_user is None:\n",
    "            logging.error(f\"FATAL: Account '{account}' found in data but MISSING in metadata User map! Cannot validate.\")\n",
    "            invalid_combos_found = True\n",
    "            checked_accounts.add(account) # Mark as checked to avoid repeating error\n",
    "        elif user != expected_user:\n",
    "            logging.error(f\"User-Account MISMATCH! Account: '{account}', Expected User: '{expected_user}', Found User: '{user}'. Row index: {index}\")\n",
    "            invalid_combos_found = True\n",
    "            # Don't add to checked_accounts here, allow finding more mismatches for same account if they exist\n",
    "\n",
    "    if not invalid_combos_found:\n",
    "        logging.info(\"User-Account mapping appears consistent with metadata for all transactions.\")\n",
    "    else:\n",
    "        logging.error(\"CRITICAL User-Account mapping inconsistencies detected! Review generation logic or metadata.\")\n",
    "else:\n",
    "    print(\"Skipping User-Account validation (Data or Metadata missing/incomplete).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dddcbe0c",
   "metadata": {},
   "source": [
    "## 6. Mapping Validation: Category vs. Sub-Category\n",
    "\n",
    "Check if all non-blank `sub_category` values are valid for their corresponding `category` based on the metadata."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "19e899df",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Category-SubCategory Mapping Validation ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "08c39562969e4463b6d692023b8d59c3",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Checking Cat-SubCat:   0%|          | 0/951 [00:00<?, ?it/s]"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Category-SubCategory mapping appears consistent with metadata for all non-blank sub-categories.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and metadata and 'categories' in metadata:\n",
    "    print(\"\\n--- Category-SubCategory Mapping Validation ---\")\n",
    "    category_map = metadata.get(\"categories\", {})\n",
    "    invalid_subcats_found = False\n",
    "    invalid_details = [] # Store details of invalid rows\n",
    "\n",
    "    from tqdm.notebook import tqdm\n",
    "    for index, row in tqdm(df.iterrows(), total=df.shape[0], desc=\"Checking Cat-SubCat\"):\n",
    "    # for index, row in df.iterrows():\n",
    "        category = row['category']\n",
    "        sub_category = row['sub_category']\n",
    "\n",
    "        # Only validate if sub_category is present (not NaN or empty string)\n",
    "        if pd.notna(sub_category) and sub_category != \"\":\n",
    "            valid_subcats = category_map.get(category)\n",
    "\n",
    "            if valid_subcats is None:\n",
    "                detail = f\"Category '{category}' (Row {index}) not found in metadata map.\"\n",
    "                if detail not in [d[0] for d in invalid_details]: # Log category error once\n",
    "                    logging.error(detail)\n",
    "                    invalid_details.append((detail, index))\n",
    "                invalid_subcats_found = True\n",
    "            elif sub_category not in valid_subcats:\n",
    "                detail = f\"Invalid Sub-category! Category: '{category}', Found Sub-cat: '{sub_category}'. Valid: {valid_subcats}. Row Index: {index}\"\n",
    "                logging.error(detail)\n",
    "                invalid_details.append((detail, index))\n",
    "                invalid_subcats_found = True\n",
    "\n",
    "    if not invalid_subcats_found:\n",
    "        logging.info(\"Category-SubCategory mapping appears consistent with metadata for all non-blank sub-categories.\")\n",
    "    else:\n",
    "        logging.error(f\"CRITICAL Category-SubCategory mapping inconsistencies detected! Found {len(invalid_details)} issues.\")\n",
    "        # print(\"\\nSample Invalid Details:\")\n",
    "        # for detail, idx in invalid_details[:min(5, len(invalid_details))]:\n",
    "        #     print(f\"- {detail}\")\n",
    "else:\n",
    "    print(\"Skipping Category-SubCategory validation (Data or Metadata missing/incomplete).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1624e291",
   "metadata": {},
   "source": [
    "## 7. Fixed Expense Validation: Rent\n",
    "\n",
    "Check frequency (1/month), amount (30k), payer (Anirban/ICICI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "409a5dfe",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Rent Validation ---\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Rent transactions appear correct (Amount, Payer, Frequency).\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "month=%{x}<br>count=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "2023-01",
          "2023-02",
          "2023-03",
          "2023-04",
          "2023-05",
          "2023-06",
          "2023-07",
          "2023-08",
          "2023-09",
          "2023-10",
          "2023-11",
          "2023-12",
          "2024-01",
          "2024-02",
          "2024-03",
          "2024-04",
          "2024-05",
          "2024-06",
          "2024-07",
          "2024-08",
          "2024-09",
          "2024-10",
          "2024-11",
          "2024-12",
          "2025-01",
          "2025-02",
          "2025-03",
          "2025-04"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "AQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQ==",
          "dtype": "i1"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 300,
        "legend": {
         "tracegroupgap": 0
        },
        "showlegend": false,
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Monthly Rent Transaction Count"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Month (YYYY-MM)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "dtick": 1,
         "tickmode": "linear",
         "title": {
          "text": "Count"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Rent Validation ---\")\n",
    "    rent_df = df[(df['category'] == 'Rent') & (df['sub_category'] == 'House Rent')].copy()\n",
    "\n",
    "    if rent_df.empty:\n",
    "        logging.warning(\"No Rent transactions found!\")\n",
    "    else:\n",
    "        valid = True\n",
    "        # Check Amount\n",
    "        if not (rent_df['amount'] == 30000).all():\n",
    "            logging.error(f\"Rent amount incorrect! Found values != 30000: {rent_df[rent_df['amount'] != 30000]['amount'].unique()}\")\n",
    "            valid = False\n",
    "        # Check User/Account\n",
    "        if not ((rent_df['user'] == 'Anirban') & (rent_df['account'] == 'Anirban-ICICI')).all():\n",
    "            logging.error(f\"Rent payer incorrect! Found instances not paid by Anirban/Anirban-ICICI.\")\n",
    "            valid = False\n",
    "        # Check Frequency\n",
    "        rent_monthly_counts = rent_df.groupby('month').size()\n",
    "        if (rent_monthly_counts != 1).any():\n",
    "            logging.error(f\"Rent frequency incorrect! Months with counts != 1: {rent_monthly_counts[rent_monthly_counts != 1].index.tolist()}\")\n",
    "            valid = False\n",
    "\n",
    "        if valid:\n",
    "            logging.info(\"Rent transactions appear correct (Amount, Payer, Frequency).\")\n",
    "\n",
    "        # Visualize counts even if correct\n",
    "        fig_rent_counts = px.bar(rent_monthly_counts.reset_index(name='count'), x='month', y='count', title='Monthly Rent Transaction Count', height=300)\n",
    "        fig_rent_counts.update_layout(yaxis_title='Count', xaxis_title='Month (YYYY-MM)', showlegend=False, yaxis=dict(tickmode='linear', dtick=1))\n",
    "        fig_rent_counts.show() # Display inline\n",
    "        # try: fig_rent_counts.write_image(IMG_DIR / \"rent_monthly_counts.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save rent counts plot: {e}\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping Rent validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "094e3696",
   "metadata": {},
   "source": [
    "## 8. Fixed Expense Validation: SIP & ULIP\n",
    "\n",
    "Check monthly frequency, amounts (SIP=3k, ULIP=4k), and payer (Anirban-ICICI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "e631899a",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: SIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\n",
      "INFO: ULIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- SIP & ULIP Validation ---\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- SIP & ULIP Validation ---\")\n",
    "    sip_df = df[(df['category'] == 'Investment') & (df['sub_category'] == 'SIP')].copy()\n",
    "    ulip_df = df[(df['category'] == 'Insurance Premium') & (df['sub_category'] == 'ULIP')].copy()\n",
    "    valid_sip = True; valid_ulip = True\n",
    "\n",
    "    # --- SIP ---\n",
    "    if sip_df.empty: logging.warning(\"No SIP transactions found!\")\n",
    "    else:\n",
    "        if not (sip_df['amount'] == 3000).all(): logging.error(f\"SIP amount incorrect! Found values != 3000.\"); valid_sip = False\n",
    "        if not ((sip_df['user'] == 'Anirban') & (sip_df['account'] == 'Anirban-ICICI')).all(): logging.error(\"SIP payer incorrect!\"); valid_sip = False\n",
    "        sip_counts = sip_df.groupby('month').size()\n",
    "        if (sip_counts > 1).any(): logging.error(f\"SIP frequency incorrect (>1 per month)!\"); valid_sip = False\n",
    "        # Check for missing months more accurately\n",
    "        all_months_in_data = set(df['month'].unique()) # Get all unique months from the main dataframe\n",
    "        sip_months_found = set(sip_df['month'].unique())\n",
    "        missing_sip_months = all_months_in_data - sip_months_found\n",
    "        if missing_sip_months and valid_sip: logging.warning(f\"SIP seems missing in {len(missing_sip_months)} months: {sorted(list(missing_sip_months))[:5]}...\")\n",
    "\n",
    "        if valid_sip: logging.info(\"SIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\")\n",
    "\n",
    "    # --- ULIP ---\n",
    "    if ulip_df.empty: logging.warning(\"No ULIP transactions found!\")\n",
    "    else:\n",
    "        if not (ulip_df['amount'] == 4000).all(): logging.error(f\"ULIP amount incorrect! Found values != 4000.\"); valid_ulip = False\n",
    "        if not ((ulip_df['user'] == 'Anirban') & (ulip_df['account'] == 'Anirban-ICICI')).all(): logging.error(\"ULIP payer incorrect!\"); valid_ulip = False\n",
    "        ulip_counts = ulip_df.groupby('month').size()\n",
    "        if (ulip_counts > 1).any(): logging.error(f\"ULIP frequency incorrect (>1 per month)!\"); valid_ulip = False\n",
    "        ulip_months_found = set(ulip_df['month'].unique())\n",
    "        missing_ulip_months = all_months_in_data - ulip_months_found\n",
    "        if missing_ulip_months and valid_ulip: logging.warning(f\"ULIP seems missing in {len(missing_ulip_months)} months: {sorted(list(missing_ulip_months))[:5]}...\")\n",
    "\n",
    "        if valid_ulip: logging.info(\"ULIP transactions appear correct (Amount, Payer, Frequency<=1). Check warnings for missed months.\")\n",
    "\n",
    "else:\n",
    "    print(\"Skipping SIP/ULIP validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c01f665e",
   "metadata": {},
   "source": [
    "## 9. Fixed Expense Validation: Maid Salary\n",
    "\n",
    "Check monthly frequency (once), amount (₹2500), and payer (Puspita-SBI)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "e335ad6d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Maid Salary transactions appear correct.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Maid Salary Validation ---\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Maid Salary Validation ---\")\n",
    "    maid_df = df[(df['category'] == 'Household') & (df['sub_category'] == 'Maid')].copy()\n",
    "    valid_maid = True\n",
    "\n",
    "    if maid_df.empty: logging.warning(\"No Maid transactions found!\")\n",
    "    else:\n",
    "        if not (maid_df['amount'] == 2500).all(): logging.error(f\"Maid amount incorrect!\"); valid_maid = False\n",
    "        if not ((maid_df['user'] == 'Puspita') & (maid_df['account'] == 'Puspita-SBI')).all(): logging.error(\"Maid payer incorrect!\"); valid_maid = False\n",
    "        maid_counts = maid_df.groupby('month').size()\n",
    "        if (maid_counts != 1).any(): logging.error(f\"Maid frequency incorrect (!=1 per month)!\"); valid_maid = False\n",
    "        if valid_maid: logging.info(\"Maid Salary transactions appear correct.\")\n",
    "else:\n",
    "    print(\"Skipping Maid Salary validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4cedf86b",
   "metadata": {},
   "source": [
    "## 10. Ad-hoc Amount Distribution: Key Categories (Box Plot)\n",
    "\n",
    "Visualize amount distributions for major variable spending areas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "68829a91",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Ad-hoc Amount Distributions (Box Plots) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "boxpoints": "outliers",
         "hovertemplate": "Category=%{x}<br>Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa"
         },
         "name": "",
         "notched": false,
         "offsetgroup": "",
         "orientation": "v",
         "showlegend": false,
         "type": "box",
         "x": [
          "Grocery",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Travel",
          "Household",
          "Grocery",
          "Grocery",
          "Grocery",
          "Household",
          "Shopping",
          "Shopping",
          "Travel",
          "Travel",
          "Shopping",
          "Household",
          "Travel",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Entertainment",
          "Shopping",
          "Household",
          "Restaurant",
          "Household",
          "Grocery",
          "Restaurant",
          "Restaurant",
          "Grocery",
          "Household",
          "Health",
          "Entertainment",
          "Shopping",
          "Travel",
          "Restaurant",
          "Entertainment",
          "Travel",
          "Household",
          "Grocery",
          "Health",
          "Travel",
          "Restaurant",
          "Grocery",
          "Entertainment",
          "Grocery",
          "Travel",
          "Entertainment",
          "Travel",
          "Health",
          "Restaurant",
          "Grocery",
          "Household",
          "Household",
          "Health",
          "Travel",
          "Shopping",
          "Travel",
          "Grocery",
          "Grocery",
          "Shopping",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Travel",
          "Household",
          "Shopping",
          "Grocery",
          "Grocery",
          "Health",
          "Shopping",
          "Household",
          "Travel",
          "Grocery",
          "Household",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Grocery",
          "Health",
          "Household",
          "Travel",
          "Health",
          "Shopping",
          "Grocery",
          "Shopping",
          "Household",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Health",
          "Household",
          "Shopping",
          "Travel",
          "Entertainment",
          "Household",
          "Shopping",
          "Health",
          "Travel",
          "Restaurant",
          "Household",
          "Health",
          "Household",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Restaurant",
          "Grocery",
          "Travel",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Entertainment",
          "Household",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Shopping",
          "Shopping",
          "Household",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Grocery",
          "Travel",
          "Grocery",
          "Household",
          "Travel",
          "Health",
          "Grocery",
          "Shopping",
          "Household",
          "Household",
          "Entertainment",
          "Travel",
          "Travel",
          "Health",
          "Entertainment",
          "Household",
          "Travel",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Grocery",
          "Health",
          "Health",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Shopping",
          "Household",
          "Shopping",
          "Restaurant",
          "Household",
          "Health",
          "Travel",
          "Travel",
          "Household",
          "Grocery",
          "Restaurant",
          "Travel",
          "Health",
          "Grocery",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Grocery",
          "Grocery",
          "Grocery",
          "Entertainment",
          "Shopping",
          "Travel",
          "Household",
          "Travel",
          "Health",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Grocery",
          "Restaurant",
          "Travel",
          "Household",
          "Shopping",
          "Restaurant",
          "Health",
          "Household",
          "Shopping",
          "Household",
          "Travel",
          "Restaurant",
          "Health",
          "Travel",
          "Household",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Health",
          "Grocery",
          "Restaurant",
          "Travel",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Grocery",
          "Restaurant",
          "Household",
          "Restaurant",
          "Travel",
          "Shopping",
          "Grocery",
          "Entertainment",
          "Household",
          "Grocery",
          "Shopping",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Shopping",
          "Shopping",
          "Travel",
          "Grocery",
          "Grocery",
          "Shopping",
          "Health",
          "Shopping",
          "Health",
          "Shopping",
          "Household",
          "Shopping",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Shopping",
          "Travel",
          "Household",
          "Household",
          "Travel",
          "Travel",
          "Grocery",
          "Shopping",
          "Shopping",
          "Health",
          "Household",
          "Entertainment",
          "Restaurant",
          "Household",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Grocery",
          "Household",
          "Grocery",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Health",
          "Household",
          "Household",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Health",
          "Travel",
          "Household",
          "Shopping",
          "Household",
          "Shopping",
          "Grocery",
          "Grocery",
          "Travel",
          "Shopping",
          "Travel",
          "Shopping",
          "Travel",
          "Household",
          "Grocery",
          "Travel",
          "Household",
          "Shopping",
          "Restaurant",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Health",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Household",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Household",
          "Restaurant",
          "Household",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Health",
          "Travel",
          "Travel",
          "Travel",
          "Household",
          "Shopping",
          "Grocery",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Grocery",
          "Shopping",
          "Travel",
          "Shopping",
          "Travel",
          "Grocery",
          "Shopping",
          "Entertainment",
          "Restaurant",
          "Travel",
          "Shopping",
          "Household",
          "Household",
          "Restaurant",
          "Entertainment",
          "Grocery",
          "Restaurant",
          "Travel",
          "Grocery",
          "Travel",
          "Grocery",
          "Grocery",
          "Grocery",
          "Health",
          "Shopping",
          "Household",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Entertainment",
          "Household",
          "Shopping",
          "Grocery",
          "Household",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Restaurant",
          "Shopping",
          "Travel",
          "Grocery",
          "Household",
          "Entertainment",
          "Travel",
          "Household",
          "Health",
          "Travel",
          "Restaurant",
          "Shopping",
          "Health",
          "Shopping",
          "Shopping",
          "Travel",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Health",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Household",
          "Household",
          "Shopping",
          "Shopping",
          "Shopping",
          "Household",
          "Health",
          "Restaurant",
          "Household",
          "Travel",
          "Household",
          "Household",
          "Grocery",
          "Shopping",
          "Restaurant",
          "Household",
          "Travel",
          "Household",
          "Household",
          "Shopping",
          "Household",
          "Restaurant",
          "Household",
          "Shopping",
          "Shopping",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Travel",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Shopping",
          "Travel",
          "Entertainment",
          "Shopping",
          "Shopping",
          "Household",
          "Grocery",
          "Shopping",
          "Entertainment",
          "Household",
          "Grocery",
          "Household",
          "Restaurant",
          "Shopping",
          "Grocery",
          "Health",
          "Grocery",
          "Entertainment",
          "Restaurant",
          "Health",
          "Grocery",
          "Restaurant",
          "Household",
          "Grocery",
          "Health",
          "Travel",
          "Shopping",
          "Health",
          "Travel",
          "Grocery",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Health",
          "Travel",
          "Health",
          "Shopping",
          "Shopping",
          "Travel",
          "Household",
          "Household",
          "Health",
          "Restaurant",
          "Household",
          "Entertainment",
          "Travel",
          "Household",
          "Shopping",
          "Entertainment",
          "Travel",
          "Health",
          "Shopping",
          "Entertainment",
          "Entertainment",
          "Shopping",
          "Restaurant",
          "Household",
          "Health",
          "Entertainment",
          "Grocery",
          "Shopping",
          "Health",
          "Household",
          "Shopping",
          "Health",
          "Shopping",
          "Grocery",
          "Household",
          "Household",
          "Travel",
          "Household",
          "Travel",
          "Travel",
          "Entertainment",
          "Shopping",
          "Shopping",
          "Shopping",
          "Travel",
          "Travel",
          "Health",
          "Travel",
          "Grocery",
          "Grocery",
          "Travel",
          "Travel",
          "Entertainment",
          "Restaurant",
          "Shopping",
          "Shopping",
          "Travel",
          "Health",
          "Health",
          "Shopping",
          "Health",
          "Shopping",
          "Shopping",
          "Health",
          "Household",
          "Household",
          "Shopping",
          "Restaurant",
          "Entertainment",
          "Travel",
          "Grocery",
          "Shopping",
          "Travel",
          "Grocery",
          "Travel",
          "Travel",
          "Health",
          "Household",
          "Restaurant",
          "Shopping",
          "Restaurant",
          "Travel",
          "Household",
          "Health",
          "Shopping",
          "Grocery",
          "Household",
          "Household",
          "Household",
          "Travel",
          "Shopping",
          "Restaurant",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Restaurant",
          "Household",
          "Household",
          "Household",
          "Household",
          "Travel",
          "Household",
          "Grocery",
          "Shopping",
          "Travel",
          "Grocery",
          "Household",
          "Restaurant",
          "Travel",
          "Travel",
          "Grocery",
          "Household",
          "Restaurant",
          "Grocery",
          "Shopping",
          "Travel",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Household",
          "Shopping",
          "Entertainment",
          "Travel",
          "Travel",
          "Restaurant",
          "Entertainment",
          "Restaurant",
          "Household",
          "Travel",
          "Restaurant",
          "Shopping",
          "Travel",
          "Restaurant",
          "Restaurant",
          "Shopping",
          "Travel",
          "Shopping",
          "Grocery",
          "Restaurant",
          "Household",
          "Travel",
          "Grocery",
          "Entertainment",
          "Shopping",
          "Entertainment",
          "Shopping",
          "Restaurant",
          "Grocery",
          "Restaurant",
          "Household",
          "Entertainment",
          "Grocery",
          "Restaurant",
          "Travel"
         ],
         "x0": " ",
         "xaxis": "x",
         "y": {
          "bdata": "uB6F61GwgEAzMzMzM9KmQM3MzMzMhopAuB6F61EElkApXI/C9VabQIXrUbge5VBAZmZmZmZUhEDsUbgehVGKQPYoXI9CCK9APQrXo3A3h0AzMzMzsy2hQFyPwvUotbJA7FG4HkUHsUApXI/C9QR6QKRwPQoXUbJApHA9ChddsUCamZmZmSuRQAAAAAAAMG5ASOF6FK53bEBxPQrXo+6OQB+F61G4EIRA4XoUrkdHlUDNzMzMjOqyQLgehevRMqVAXI/C9SgYekBI4XoULuenQK5H4XoUYaNAAAAAAAC/lECF61G4HsWIQMP1KFxPWLdA16NwPQpfckDNzMzMzN+aQHE9CtejOoFApHA9Ctc5i0ApXI/C9W2QQOxRuB6F44BAPQrXo3CDpECuR+F61G63QFyPwvWo9bBArkfhehTslkDhehSux5qmQB+F61G4cntA9ihcj8JcmUBcj8L1KNSEQClcj8L1DbFAuB6F61H0ckAzMzMzM9dyQNejcD0Kj45AH4XrUbhDk0DsUbgehWanQBSuR+H6DcZAhetRuJ7LrkCkcD0KV1auQBSuR+G6xbZAKVyPwvVwfEAUrkfheiilQArXo3C93qRAFK5H4XosZUB7FK5HYfa1QOxRuB6FlpdAPQrXo3B7g0A9Ctej8BSqQHE9CtejDaNAuB6F61G4lEAK16Nw/e+/QIXrUbgeTWNAZmZmZmZSeEBI4XoUrnytQFyPwvVoFLBAPQrXo3Abr0C4HoXrUZhhQOF6FK5HXK9A4XoUrkcKk0AUrkfhejyhQClcj8I14bFA9ihcj8JOlkDD9ShcD/GgQOxRuB7FhLhAMzMzMzPffECuR+F6FJaUQD0K16NwTJdACtejcD3EgkBSuB6Fy2LLQHE9CtejGH5AAAAAAAAce0B7FK5H4TJxQDMzMzOzYKZACtejcD0JlUC4HoXrkYDGQB+F61G4TJZAAAAAAOD6xUCF61G4nvKkQFyPwvUo5o1ArkfhetTMsEAAAAAAAH+XQOF6FK5H3KpAXI/C9QiQwUBcj8L1KMmSQDMzMzMzmaRAZmZmZmazmEBSuB6Fa8quQMP1KFyPSmVA4XoUrkclmEAzMzMzM39/QIXrUbhemMRAZmZmZmanlUApXI/C9XhjQNejcD0KV6FAPQrXo3DriEAK16Nw/cm7QM3MzMzM3aBAhetRuF7EvkBI4XoUrludQNejcD2K671ArkfhehRuT0DXo3A9Ch9oQArXo3A9ml1AmpmZmZn2k0CF61G4nlGyQGZmZmZm7IRASOF6FK4RnED2KFyPwhKVQLgehetRPLJAAAAAAIB7w0DXo3A9CgmMQPYoXI/Cka9AMzMzM7M0p0DsUbgehamhQJqZmZmZCVVAMzMzM3O2t0DXo3A9CmimQFyPwvXo58JAw/UoXI/qbUDhehSuRzVzQArXo3C9Da9A9ihcj4KRsEBI4XoUrtqZQNejcD0Kr2tAH4XrUfhVykCkcD0K1zmMQClcj8L1jI1AZmZmZnY72ECPwvUoPC7AQDMzMzMz239AzczMzMxBlEBxPQrXo6OSQI/C9ShcZ25Aw/UoXI/8p0CamZmZOYzBQClcj8IVkcNAcT0K16NQjkAfhetRuKKPQK5H4Xp0Z8BAPQrXo3A9TkDhehSuh5uwQKRwPQpX1a5ArkfhehSqhkBmZmZmZsZjQOxRuB6Fa5FAZmZmZiZIwEAzMzMzM6KRQK5H4XoUuqlAw/UoXI9MkUCF61G43jm1QHsUrkfh+lNAMzMzMxMNwkDhehSuR7WfQGZmZmbmjK9ApHA9ClfmpEDsUbgehTifQFK4HoVrXaRApHA9CtcvkkDXo3A9CqygQKRwPQrXFJRA16NwPQqHe0DNzMzMzKyTQBSuR+F6ypVAw/UoXI9KjUBmZmZm5lirQMP1KFyPUnlAzczMzAxzwUBcj8L1KIiDQArXo3A91q1AKVyPwvU5kkDsUbgeBVygQGZmZmZmuZ1AMzMzMzOKoEBI4XoULiC2QB+F61G4FMRAcT0K16NGk0DNzMzMzAKGQKRwPQrX/aVApHA9CteOrECPwvUoXCGKQMP1KFyPiptA4XoUrketjUC4HoXrUUeSQHE9CtejYGRAmpmZmZkZd0CPwvUoXFidQBSuR+F6/q5APQrXo3CHlUD2KFyPwtVgQD0K16NwWJBAKVyPwvUKrECkcD0K18OeQClcj8L1cIJAuB6F61HEcECuR+F6lLW9QDMzMzMzk31A7FG4HgV3o0A9CtejcC1nQMP1KFwP+rxAhetRuB4InkCamZmZmU16QGZmZmZm3mBAUrgehes4okDD9Shcj/OlQFyPwvXo/tFAmpmZmZkBfUD2KFyPwnadQOF6FK5HfXxASOF6FK6ti0B7FK5H4S2qQOxRuB7FGcBArkfhehSSeEAK16NwfT+5QKRwPQrXk3ZAH4XrUbjnoUBmZmZmZnCWQHsUrkfhwmxA7FG4HoXzYEB7FK5H4aJwQK5H4XoUSnxAj8L1KFzGpUCamZmZmTucQArXo3A9wIJAAAAAAAB+gUDD9Shcjw56QDMzMzNT8NBAAAAAAIDsskBcj8L1KIGlQOF6FK5HLYtAj8L1KFx9lkBxPQrXIxywQHsUrkdhTapAw/UoXI+KjkDD9ShcD9anQMP1KFwPo6hAmpmZmZlBpkCkcD0KF8GxQI/C9Sic/LBAzczMzEzBpkDhehSuRzl5QNejcD0KH6dAw/UoXA9vvkCuR+F6FB6NQFK4HoXrKpxArkfhehQ8j0DNzMzMDA27QHsUrkdhvqVAexSuRyFlw0A9CtejcHCqQHE9Ctej6HpA16NwPQrPm0BI4XoUrh9wQOxRuB5lRMhApHA9CtcNmUBI4XoUTuzGQFyPwvUoRG9AXI/C9ShfokAfhetROHaiQGZmZmZmQqJAcT0K16PNlUCamZmZmZKQQMP1KFyPkq1A4XoUrkdEpkApXI/C9Rm1QClcj8L10KBA4XoUrkchn0AK16NwvYCjQHsUrkfhyZlAPQrXo3ADj0AUrkfhekR9QBSuR+F6VHlAAAAAAGCMwkAfhetRuOZvQD0K16Nw94ZAj8L1KNx3pUBI4XoUrlKjQNejcD0KD3BApHA9ClcTpUBSuB6FazCjQBSuR+G6eshAXI/C9SgAq0Bcj8L1KLWRQEjhehSuUp1A4XoUrkcDkkCPwvUoXLGZQOxRuB6Fs3xAmpmZmZn5i0AK16NwvR3HQBSuR+F6FLBAcT0K16OllUAK16NwvdStQB+F61G4T5JAj8L1KJyssUD2KFyPQtypQHsUrkdh3a5AcT0K1yNCpkCF61G4HoChQJqZmZmZfJ9AhetRuB4ZkEAAAAAAAGKGQFK4HoXrqrhAexSuR+HibEDD9Shczxy6QLgehetxUsJA16NwPQqSoEBxPQrXo5iCQFK4HoXr8dVAZmZmZmagqEBmZmZm5p+vQClcj8L1TH9A9ihcj8LNZUCPwvUoXBeYQOxRuB4lesFAhetRuB5bwEAzMzMzM9CaQMP1KFyPW55AZmZmZmb6nkDD9Shcj85zQD0K16NwMZRAH4XrUbgItkBSuB6F61CmQFK4HoXrTZRAH4XrUbgSfUCuR+F6FAZuQB+F61E48qJA16NwPYrLvECkcD0K1+NxQClcj8L1K59AZmZmZmY8g0DsUbgeBRitQB+F61G43k9A4XoUrqdTxUCPwvUoXImVQEjhehQOMsVAexSuR+GlrUAzMzMzs3enQDMzMzMzNYlA16NwPQp5tEAK16NwPfKJQD0K16OwVLtAPQrXo3AJcEBSuB6F68+fQBSuR+F6DbpAmpmZmZn/lkC4HoXrUSKtQEjhehTujMBAhetRuB7OvEAAAAAAAGB6QGZmZmZm7nNAzczMzKyCxEAzMzMzszijQM3MzMzM9HpA16NwPYqx2UAUrkfh+t6pQAAAAAAAXpdAj8L1KFygkkApXI/C9cmbQB+F61G4K5JA4XoUrkcqokDhehSuR+mBQFyPwvW45dBAAAAAAACIk0DD9Shcj6OrQNejcD0KuYhAcT0K16MPo0CamZmZmXmhQMP1KFyPRoVAFK5H4fqKtkAK16NwvXemQDMzMzMz/6xApHA9CtdKwUDXo3A9CreIQAAAAAAAwHNAZmZmZmaimEDhehSuR860QArXo3A9DpJAUrgehesxdEDXo3A9Cr9xQKRwPQrX62JA9ihcj8I9qUCPwvUoXGWtQI/C9ShcqplAKVyPwvUPnECkcD0Kd5LWQFyPwvUolHhAzczMzMw4fkCamZmZmQmLQKRwPQrXVYdAzczMzOylwkAfhetRuDSOQDMzMzMz42pA9ihcj8Jhc0CPwvUoHKu6QLgehetReZpAzczMzEyvqUDNzMzMDGaxQK5H4XoUvmxAMzMzM7NJtkB7FK5H4QZ7QAAAAADAm7JA16NwPco2sUDD9Shcj5W2QClcj8L1GFhApHA9CtdRlEAfhetR+B3GQKRwPQrX55lAmpmZmRlptkDXo3A9CqWxQArXo3A9Wq1AFK5H4XrYlkAzMzMzEzrAQNejcD0K1ZZASOF6FK6AnUBI4XoUrgN1QEjhehSuypNAj8L1KFwvc0DsUbgeBWCjQEjhehSurJZAuB6F61FQeUCPwvUoXL9RQK5H4XoUO5lAzczMzMwojECamZmZmZmaQHE9Ctej2K1ASOF6FK6dkUBcj8L1KKRoQOxRuB6FlplAFK5H4XqDqUCkcD0KF1S4QM3MzMzMar9AKVyPwnV3ukCamZmZGZagQKRwPQrXQsRAmpmZmZlKlUAUrkfheiSDQClcj8JVw8RAuB6F61H4SkCkcD0K1yCkQHsUrkdh16VA7FG4HoVHlEDsUbgehbyeQArXo3D9zbVAFK5H4bpWv0CF61G4HkWBQHE9CtejsHxAH4XrUbhIskCF61G4HkV+QD0K16Nw7JpAj8L1KFxBgkCuR+F6FHmcQClcj8L1WGlAZmZmZoYKxUCkcD0K18uFQPYoXI/CA7JACtejcD3aZ0CPwvUoXHKYQBSuR+F69IlAexSuR2HEqkBxPQrXIxKkQOxRuB6FG15AcT0K16Mpk0CPwvUoXK2EQOF6FK5H2pNAPQrXo3DWn0AfhetROFPAQOxRuB6FCYNAH4XrUbgeS0BmZmZmZr5jQOF6FK5H34NA16NwPQp3fkAUrkfheqetQM3MzMzM5JFASOF6FK7HmkCamZmZmalYQAAAAAAAzZVAFK5H4Xp1n0DsUbgexTqwQMP1KFyP4qVAmpmZmZk9cUCamZmZGSWrQI/C9ShcH5JApHA9CtcxkkCPwvUoXHacQPYoXI/CTpdA7FG4HoVFjEA9CtejcICYQBSuR+G6WLxAAAAAAADgf0B7FK5HEbDXQI/C9SjceK9AAAAAAMCGskApXI/C9c6CQMP1KFyPcq1A4XoUrkc9tkBI4XoUrht+QEjhehSutJ5AcT0K1wO+wUBI4XoUrn+RQGZmZmZmvIJAKVyPwvUmjkCamZmZGVumQKRwPQrXS5RAUrgehetfsUBmZmZmZqmXQOxRuB4FpKBAUrgehetpg0CPwvUoXIiUQOF6FK5H0YBAuB6F61F4VkApXI/C9ax/QB+F61G4R75AFK5H4XrajkDhehSuR42WQNejcD1KCbdAuB6F65G5u0B7FK5H4beUQFyPwvUoNpJAj8L1KFwvWkAK16NwPU6BQArXo3A9EZ1AexSuR+HKa0AzMzMzMytqQBSuR+F6xHlAFK5H4Xp0aECPwvUo3BKiQIXrUbieKKtAH4XrUThEs0BSuB6F687FQOF6FK7H7aBAMzMzM5PJwECPwvUoXHyUQOF6FK7HcLNAmpmZmZkXqkCuR+F6FCSmQJqZmZmZCL5ApHA9Ctc7k0C4HoXrUbSqQGZmZmZm6JpAZmZmZuamokDD9Shcj/5xQI/C9ShcVqFASOF6FK6Nk0BI4XoUrn9xQPYoXI9C9r1Aj8L1KJxpvECkcD0K10+VQHsUrkfhULtAFK5H4Xr2iUAfhetR+MG+QKRwPQrXKJ9AZmZmZmbMiUBcj8L1KDahQB+F61G4vmNACtejcD2KTkBmZmZmZsCLQKRwPQrXB55AZmZmZuavqkBI4XoUrreTQK5H4XoU1pRApHA9CteEkkAUrkfhelGQQPYoXI/C5VBAH4XrUTjOqkCPwvUoXGmCQDMzMzOzdrpAzczMzExBpkBxPQrXoyy9QOxRuB6Fe3RAH4XrUbjcgkCPwvUoXBikQAAAAAAAMFpASOF6FK6nWEAfhetROA6gQHE9Ctcja69A4XoUrscfwEB7FK5H4aOWQClcj8L14GxAhetRuP4swUA9CtejcJmPQHsUrkfhw6tAMzMzMzNrmEBcj8L1KCxyQBSuR+F67p1AmpmZmZlLlEA9CtejcBV0QK5H4XoUBaJAFK5H4foEo0BSuB6F61lkQHE9CtejAKpA7FG4HoUBnECF61G4HheNQDMzMzMzy4ZAZmZmZmYieUCkcD0KVyauQFyPwvVo/sNAmpmZmZlXtEAfhetRuI6XQAAAAAAAIFNA16NwPQpjfECuR+F6FHiEQBSuR+F60ItA4XoUrkfBgUC4HoXr0f2uQKRwPQrXo41AXI/C9Si8dkBmZmZmJqm5QPYoXI/C/aNA4XoUrkdZqUAUrkfhegKAQD0K16PwK7ZACtejcD3ov0A9Ctej8MbCQOF6FK5HEWJApHA9CtdDWkB7FK5H4fJzQClcj8L16E9AzczMzMzsmkCuR+F6FJiPQClcj8L11KlAj8L1KFy4o0CuR+F6FF22QFyPwvUoRJlAAAAAAADDmkBmZmZmZvqHQGZmZmZm8I9Aw/UoXI+9okAAAAAAADRwQJqZmZmZE45AcT0K1yO4xkA=",
          "dtype": "f8"
         },
         "y0": " ",
         "yaxis": "y"
        }
       ],
       "layout": {
        "boxmode": "group",
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Amount Distribution by Major Variable Category (Log Scale, Excl. Maid/Large Furniture/Vacation)"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -45,
         "title": {
          "text": "Category"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         },
         "type": "log"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Review box plot/stats: Do medians/ranges seem realistic for Bangalore daily/weekly expenses in these categories?\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "               count         mean          std     min        25%       50%  \\\n",
      "category                                                                      \n",
      "Entertainment   34.0  1858.921176  1037.274908  484.32  1039.2350  1554.955   \n",
      "Grocery         83.0  1317.318313  1086.638861  118.41   398.4200   903.230   \n",
      "Health          52.0  3298.279808  2711.537050  540.44  1153.2025  2264.335   \n",
      "Household      120.0  2051.820250  2157.755727   70.99   781.8050  1444.155   \n",
      "Restaurant      79.0   945.827595   831.638598   63.74   336.9350   573.160   \n",
      "Shopping       122.0  4939.460984  2925.484306  307.33  2913.7725  4402.180   \n",
      "Travel         153.0  4067.852810  5407.537065   53.94   439.1700  1878.090   \n",
      "\n",
      "                     75%       max  \n",
      "category                            \n",
      "Entertainment  2444.9575   4763.75  \n",
      "Grocery        2221.5200   4124.14  \n",
      "Health         4809.3100   9084.03  \n",
      "Household      2317.8000  11323.94  \n",
      "Restaurant     1542.0300   3476.31  \n",
      "Shopping       6655.8950  14021.59  \n",
      "Travel         4689.6200  26310.16  \n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'amount' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Ad-hoc Amount Distributions (Box Plots) ---\")\n",
    "    major_variable_cats = ['Grocery', 'Restaurant', 'Shopping', 'Travel', 'Household', 'Health', 'Entertainment']\n",
    "    plot_df = df[df['category'].isin(major_variable_cats)].copy() # Make a copy\n",
    "    # Exclude known large fixed costs from Household/Travel for better visualization of variable costs\n",
    "    plot_df = plot_df[~((plot_df['category'] == 'Household') & (plot_df['sub_category'] == 'Maid'))]\n",
    "    # Exclude potential large vacation sums if they skew too much\n",
    "    # plot_df = plot_df[~((plot_df['category'] == 'Travel') & (plot_df['sub_category'] == 'Vacation') & (plot_df['amount'] > 15000))] \n",
    "    # Exclude large furniture costs\n",
    "    plot_df = plot_df[~((plot_df['category'] == 'Household') & (plot_df['sub_category'] == 'Furniture') & (plot_df['amount'] > 10000))]\n",
    "\n",
    "    if not plot_df.empty:\n",
    "        fig_box_cat = px.box(plot_df, x='category', y='amount', points=\"outliers\",\n",
    "                             title='Amount Distribution by Major Variable Category (Log Scale, Excl. Maid/Large Furniture/Vacation)',\n",
    "                             labels={'category': 'Category', 'amount': 'Amount (INR)'},\n",
    "                             log_y=True, height=500)\n",
    "        fig_box_cat.update_layout(xaxis_tickangle=-45)\n",
    "        fig_box_cat.show() # Display inline\n",
    "        # try: fig_box_cat.write_image(IMG_DIR / \"category_amount_boxplot.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save category box plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check:\n",
    "        print(plot_df.groupby('category')['amount'].describe())\n",
    "        logging.info(\"Review box plot/stats: Do medians/ranges seem realistic for Bangalore daily/weekly expenses in these categories?\")\n",
    "    else:\n",
    "        logging.info(\"No data for major variable categories found after filtering fixed/large items.\")\n",
    "else:\n",
    "    print(\"Skipping amount distribution analysis (missing columns).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9944b89",
   "metadata": {},
   "source": [
    "## 11. Ad-hoc Amount Distribution: Grocery Sub-Categories (Box Plot)\n",
    "\n",
    "Compare spending ranges for different grocery platforms/stores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "0a574c09",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Grocery Sub-Category Amount Distributions ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "boxpoints": "outliers",
         "hovertemplate": "Store/Platform=%{x}<br>Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa"
         },
         "name": "",
         "notched": false,
         "offsetgroup": "",
         "orientation": "v",
         "showlegend": false,
         "type": "box",
         "x": [
          "Flipkart Grocery",
          "Local Store",
          "Amazon",
          "BigBasket",
          "Zepto",
          "Local Store",
          "Flipkart Grocery",
          "Flipkart Grocery",
          "Local Store",
          "Amazon",
          "BigBasket",
          "Amazon",
          "BigBasket",
          "Zepto",
          "Amazon",
          "Flipkart Grocery",
          "Local Store",
          "Flipkart Grocery",
          "Amazon",
          "Local Store",
          "Zepto",
          "Amazon",
          "Zepto",
          "Amazon",
          "Amazon",
          "Amazon",
          "Flipkart Grocery",
          "Zepto",
          "BigBasket",
          "Flipkart Grocery",
          "BigBasket",
          "Local Store",
          "BigBasket",
          "Zepto",
          "Zepto",
          "Flipkart Grocery",
          "Local Store",
          "BigBasket",
          "BigBasket",
          "Local Store",
          "Amazon",
          "Local Store",
          "Flipkart Grocery",
          "Zepto",
          "Flipkart Grocery",
          "Flipkart Grocery",
          "Amazon",
          "BigBasket",
          "Local Store",
          "Zepto",
          "BigBasket",
          "Zepto",
          "Zepto",
          "Amazon",
          "Zepto",
          "Zepto",
          "Local Store",
          "Zepto",
          "Zepto",
          "Zepto",
          "BigBasket",
          "Zepto",
          "Local Store",
          "Amazon",
          "Amazon"
         ],
         "x0": " ",
         "xaxis": "x",
         "y": {
          "bdata": "MzMzMzPSpkApXI/C9VabQPYoXI9CCK9APQrXo3A3h0BI4XoUrndsQOF6FK5HR5VAuB6F69EypUBcj8L1KNSEQNejcD0Kj45A7FG4HoVmp0AUrkfheiilQHE9CtejDaNAuB6F61G4lEDhehSuRwqTQBSuR+F6PKFAMzMzMzPffEBxPQrXoxh+QIXrUbie8qRApHA9Ctc5jECuR+F6FKqGQOxRuB6Fa5FAZmZmZuZYq0ApXI/C9TmSQOxRuB4FXKBAZmZmZma5nUAUrkfhev6uQFK4HoXrOKJApHA9CteTdkCamZmZmTucQFyPwvUogaVAcT0K1yMcsEDhehSuRzl5QNejcD0KH6dAmpmZmZmSkEAfhetRuOZvQI/C9Sjcd6VA16NwPQoPcEBSuB6FazCjQJqZmZmZfJ9AhetRuB4ZkEBxPQrXo5iCQArXo3A98olAmpmZmZn/lkBmZmZmZu5zQOF6FK5HKqJAAAAAAACIk0BxPQrXow+jQJqZmZmZeaFAUrgehesxdEBcj8L1KJR4QOxRuB4FYKNApHA9CtfLhUAK16NwPdpnQHE9CtcjEqRAj8L1KFythEBmZmZmZryCQFK4HoXraYNAexSuR+HKa0CkcD0K10+VQEjhehSut5NAexSuR+HDq0A9CtejcBV0QOF6FK5HEWJAzczMzMzsmkAAAAAAAMOaQA==",
          "dtype": "f8"
         },
         "y0": " ",
         "yaxis": "y"
        }
       ],
       "layout": {
        "boxmode": "group",
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Grocery Amount Distribution by Store/Platform (Log Scale)"
        },
        "xaxis": {
         "anchor": "y",
         "categoryarray": [
          "BigBasket",
          "Zepto",
          "Local Store",
          "Amazon",
          "Flipkart Grocery"
         ],
         "categoryorder": "array",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Store/Platform"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         },
         "type": "log"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check if distributions align with expectations (e.g., BigBasket/Amazon generally higher median/IQR than Zepto/Local Store).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                  count         mean          std     min        25%      50%  \\\n",
      "sub_category                                                                    \n",
      "Amazon             14.0  2358.546429  1011.778104  595.08  1767.9875  2322.53   \n",
      "BigBasket          11.0  2400.901818   956.428750  742.93  1911.0250  2456.21   \n",
      "Flipkart Grocery   11.0  2029.481818   902.174004  461.95  1360.9500  2332.46   \n",
      "Local Store        12.0   742.185000   477.796766  144.54   383.4650   673.25   \n",
      "Zepto              17.0   672.707059   429.387667  190.82   318.9000   599.55   \n",
      "\n",
      "                        75%      max  \n",
      "sub_category                          \n",
      "Amazon            2888.7125  3972.13  \n",
      "BigBasket         2833.8800  4124.14  \n",
      "Flipkart Grocery  2730.6700  2921.10  \n",
      "Local Store        990.9800  1749.74  \n",
      "Zepto             1114.8800  1363.96  \n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'sub_category' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Grocery Sub-Category Amount Distributions ---\")\n",
    "    grocery_subs = ['BigBasket', 'Zepto', 'Local Store', 'Amazon', 'Flipkart Grocery']\n",
    "    plot_df_grocery = df[(df['category'] == 'Grocery') & (df['sub_category'].isin(grocery_subs))]\n",
    "\n",
    "    if not plot_df_grocery.empty:\n",
    "        fig_box_grocery = px.box(plot_df_grocery, x='sub_category', y='amount', points=\"outliers\",\n",
    "                                 title='Grocery Amount Distribution by Store/Platform (Log Scale)',\n",
    "                                 labels={'sub_category': 'Store/Platform', 'amount': 'Amount (INR)'},\n",
    "                                 category_orders={\"sub_category\": grocery_subs}, # Control order\n",
    "                                 log_y=True, height=500)\n",
    "        fig_box_grocery.show() # Display inline\n",
    "        # try: fig_box_grocery.write_image(IMG_DIR / \"grocery_subcat_boxplot.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save grocery box plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check\n",
    "        print(plot_df_grocery.groupby('sub_category')['amount'].describe())\n",
    "        logging.info(\"Check if distributions align with expectations (e.g., BigBasket/Amazon generally higher median/IQR than Zepto/Local Store).\")\n",
    "    else:\n",
    "        logging.info(\"No data found for specified Grocery sub-categories.\")\n",
    "else:\n",
    "    print(\"Skipping grocery sub-category analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57335010",
   "metadata": {},
   "source": [
    "## 12. Frequency Validation: Ad-hoc Monthly Counts\n",
    "\n",
    "Check adherence to `Max-times-per-month` for specific ad-hoc rules (Waste, Gifts, Entertainment)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "e2a56823",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Ad-hoc Monthly Frequency Validation (Waste/Gifts/Ent) ---\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Teertha's PC\\AppData\\Local\\Temp\\ipykernel_11796\\1882847337.py:28: FutureWarning:\n",
      "\n",
      "A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\n",
      "The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n",
      "\n",
      "For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n",
      "\n",
      "\n",
      "\n",
      "INFO: Loaded and preprocessed 177 rules from E:\\Code\\Projects\\App-PersonalFinance\\app-personal-finance\\sample_data_generation.csv\n",
      "INFO: Ad-hoc frequency constraints (Max-times-per-month) for Waste/Gifts/Entertainment appear satisfied.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'month' in df.columns:\n",
    "    print(\"\\n--- Ad-hoc Monthly Frequency Validation (Waste/Gifts/Ent) ---\")\n",
    "    df_rules_loaded = load_rules(RULES_FILE) # Use the function defined earlier\n",
    "\n",
    "    if df_rules_loaded is not None:\n",
    "        # Define the rules we want to check explicitly based on the constraints given\n",
    "        rules_to_check_criteria = (\n",
    "            (df_rules_loaded['Expense-Frequency'] == 'ad-hoc') &\n",
    "            (\n",
    "                (df_rules_loaded['Category'] == 'Waste') |\n",
    "                (df_rules_loaded['Category'] == 'Gifts & Donations') |\n",
    "                (df_rules_loaded['Category'] == 'Entertainment')\n",
    "            )\n",
    "        )\n",
    "        rules_to_check_df = df_rules_loaded[rules_to_check_criteria].copy()\n",
    "\n",
    "        if not rules_to_check_df.empty:\n",
    "            # Create a unique key combining relevant fields from BOTH data and rules\n",
    "            # Use lowercase for robust matching if casing differs slightly\n",
    "            df['rule_match_key'] = df.apply(lambda r: f\"{r['category'].lower()}|{r['sub_category'].lower()}|{r['user'].lower()}|{r['account'].lower()}\", axis=1)\n",
    "            rules_to_check_df['rule_match_key'] = rules_to_check_df.apply(lambda r: f\"{r['Category'].lower()}|{r['Sub-category'].lower()}|{r['User'].lower()}|{r['Account'].lower()}\", axis=1)\n",
    "\n",
    "            # Group transactions by month and rule_key to count actual occurrences\n",
    "            monthly_actual_counts = df[df['rule_match_key'].isin(rules_to_check_df['rule_match_key'])].groupby(['month', 'rule_match_key']).size().reset_index(name='actual_count')\n",
    "\n",
    "            # Merge actual counts with the limits from the rules file\n",
    "            merged_counts = pd.merge(\n",
    "                monthly_actual_counts,\n",
    "                rules_to_check_df[['rule_match_key', 'Max-times-per-month']],\n",
    "                on='rule_match_key',\n",
    "                how='left' # Keep all actual counts, match rules where possible\n",
    "            )\n",
    "            # Drop rows where the rule couldn't be matched (shouldn't happen if keys are correct)\n",
    "            merged_counts.dropna(subset=['Max-times-per-month'], inplace=True)\n",
    "            merged_counts['Max-times-per-month'] = merged_counts['Max-times-per-month'].astype(int) # Ensure integer comparison\n",
    "\n",
    "            # Find violations\n",
    "            merged_counts['exceeded'] = merged_counts['actual_count'] > merged_counts['Max-times-per-month']\n",
    "            exceeded_df = merged_counts[merged_counts['exceeded']]\n",
    "\n",
    "            if not exceeded_df.empty:\n",
    "                logging.error(\"Max-times-per-month constraint VIOLATED for some ad-hoc rules!\")\n",
    "                print(\"Violations Found (Rule Key | Month | Actual Count | Max Allowed):\")\n",
    "                # Improve display for readability\n",
    "                exceeded_df_display = exceeded_df[['rule_match_key', 'month', 'actual_count', 'Max-times-per-month']].copy()\n",
    "                exceeded_df_display['Rule_Info'] = exceeded_df_display['rule_match_key'].str.replace('|', ' | ', regex=False)\n",
    "                print(exceeded_df_display[['Rule_Info', 'month', 'actual_count', 'Max-times-per-month']].to_string(index=False))\n",
    "            else:\n",
    "                logging.info(\"Ad-hoc frequency constraints (Max-times-per-month) for Waste/Gifts/Entertainment appear satisfied.\")\n",
    "\n",
    "            # Clean up added column from main df\n",
    "            if 'rule_match_key' in df.columns: df.drop(columns=['rule_match_key'], inplace=True, errors='ignore')\n",
    "        else:\n",
    "            logging.info(\"No specific Waste/Gifts/Entertainment ad-hoc rules found in the rules file for frequency validation.\")\n",
    "    else:\n",
    "        logging.warning(\"Could not load rules file, skipping ad-hoc frequency validation.\")\n",
    "else:\n",
    "    print(\"Skipping ad-hoc frequency validation.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 13. Account Usage Bias Check\n",
    "\n",
    "Verify Puspita-Bandhan use for Travel/Beauty and Anirban-ICICI dominance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Account Usage Validation ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "domain": {
          "x": [
           0,
           1
          ],
          "y": [
           0,
           1
          ]
         },
         "hole": 0.3,
         "hovertemplate": "<b>%{label}</b><br>Total: ₹%{value:,.0f}<br>(%{percent})<extra></extra>",
         "labels": [
          "Anirban-ICICI",
          "Anirban-SBI",
          "Puspita-Bandhan",
          "Puspita-SBI"
         ],
         "legendgroup": "",
         "name": "",
         "showlegend": true,
         "textinfo": "percent+label",
         "type": "pie",
         "values": {
          "bdata": "pHA9Ss15PEG4HoXrCpsjQetRuB6FtBFBSOF6FBZDL0E=",
          "dtype": "f8"
         }
        }
       ],
       "layout": {
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Overall Spending Proportion by Account"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Puspita-Bandhan usage appears focused on Travel/Beauty.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Puspita-Bandhan Category Distribution (% of transactions):\n",
      "category\n",
      "Travel    58.1\n",
      "Beauty    41.9\n",
      "Name: proportion, dtype: float64\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "domain": {
          "x": [
           0,
           1
          ],
          "y": [
           0,
           1
          ]
         },
         "hole": 0.3,
         "hovertemplate": "category=%{label}<extra></extra>",
         "labels": [
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Beauty",
          "Beauty",
          "Travel",
          "Travel",
          "Travel"
         ],
         "legendgroup": "",
         "name": "",
         "showlegend": true,
         "textinfo": "percent+label",
         "type": "pie"
        }
       ],
       "layout": {
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Puspita-Bandhan Spending by Category"
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Anirban-ICICI appears dominant for Anirban's spending (>=60%).\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Anirban-ICICI accounts for 74.4% of Anirban's total spending amount.\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'account' in df.columns and 'user' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Account Usage Validation ---\")\n",
    "\n",
    "    # Overall Spend per Account (Pie Chart)\n",
    "    account_totals = df.groupby('account')['amount'].sum().reset_index()\n",
    "    fig_acc_pie = px.pie(account_totals, values='amount', names='account',\n",
    "                         title='Overall Spending Proportion by Account', hole=0.3)\n",
    "    fig_acc_pie.update_traces(textinfo='percent+label', hovertemplate=\"<b>%{label}</b><br>Total: ₹%{value:,.0f}<br>(%{percent})<extra></extra>\")\n",
    "    fig_acc_pie.show() # Display inline\n",
    "    # try: fig_acc_pie.write_image(IMG_DIR / \"account_spending_pie.png\") # Commented out\n",
    "    # except Exception as e: logging.error(f\"Failed to save account pie plot: {e}\")\n",
    "\n",
    "    # Puspita-Bandhan: Travel & Beauty focus?\n",
    "    puspita_bandhan_df = df[df['account'] == 'Puspita-Bandhan']\n",
    "    if not puspita_bandhan_df.empty:\n",
    "        pb_cat_dist = puspita_bandhan_df['category'].value_counts(normalize=True) * 100\n",
    "        print(\"\\nPuspita-Bandhan Category Distribution (% of transactions):\")\n",
    "        print(pb_cat_dist.round(1))\n",
    "        allowed_cats = ['Travel', 'Beauty']\n",
    "        other_cats_used = [cat for cat in pb_cat_dist.index if cat not in allowed_cats]\n",
    "        if other_cats_used:\n",
    "            logging.warning(f\"Puspita-Bandhan account used for categories other than Travel/Beauty: {other_cats_used}\")\n",
    "        else:\n",
    "             logging.info(\"Puspita-Bandhan usage appears focused on Travel/Beauty.\")\n",
    "        # Pie chart for Puspita-Bandhan\n",
    "        fig_pb_cat = px.pie(puspita_bandhan_df, names='category', title='Puspita-Bandhan Spending by Category', hole=0.3)\n",
    "        fig_pb_cat.update_traces(textinfo='percent+label')\n",
    "        fig_pb_cat.show() # Display inline\n",
    "        # try: fig_pb_cat.write_image(IMG_DIR / \"puspita_bandhan_category_pie.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save Puspita-Bandhan pie plot: {e}\")\n",
    "    else:\n",
    "        logging.info(\"No transactions found for Puspita-Bandhan.\")\n",
    "\n",
    "    # Anirban-ICICI Dominance Check\n",
    "    anirban_df = df[df['user'] == 'Anirban']\n",
    "    if not anirban_df.empty:\n",
    "         total_anirban_spend = anirban_df['amount'].sum()\n",
    "         if total_anirban_spend > 0:\n",
    "              icici_spend = anirban_df[anirban_df['account'] == 'Anirban-ICICI']['amount'].sum()\n",
    "              icici_share = (icici_spend / total_anirban_spend) * 100\n",
    "              print(f\"\\nAnirban-ICICI accounts for {icici_share:.1f}% of Anirban's total spending amount.\")\n",
    "              if icici_share < 60: # Arbitrary threshold\n",
    "                   logging.warning(\"Anirban-ICICI share of Anirban's spending seems lower than expected (<60%).\")\n",
    "              else:\n",
    "                   logging.info(\"Anirban-ICICI appears dominant for Anirban's spending (>=60%).\")\n",
    "         else:\n",
    "              logging.info(\"Anirban has zero total spending.\")\n",
    "    else:\n",
    "         logging.info(\"No transactions found for Anirban.\")\n",
    "else:\n",
    "    print(\"Skipping account usage validation (missing columns).\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 14. Temporal Pattern: Spending Over Month Day\n",
    "\n",
    "Check if Grocery/Shopping spending is concentrated early in the month."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- Intra-Month Spending Pattern (Grocery/Shopping) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Day of Month=%{x}<br>Total Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "textposition": "auto",
         "type": "bar",
         "x": {
          "bdata": "AQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAA",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "7FG4HmWQ9EDNzMzMPDL5QD0K16Po3fFAZmZmZnSsAEGuR+F68LH5QD4K16NIS+dAXI/C9eA14EAK16NwBffrQClcj8LlCdJArkfheuSq20DiehSuZ1bHQArXo3D9i8hA",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Total Grocery/Shopping Spend by Day of Month"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "dtick": 1,
         "tickmode": "linear",
         "title": {
          "text": "Day of Month"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Total Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check bar chart: Is spending clearly higher in the first ~10 days?\n",
      "INFO: Spending concentration early in the month observed (First 10 days: ~₹687,435 vs Last 10 days: ~₹0).\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- Intra-Month Spending Pattern (Grocery/Shopping) ---\")\n",
    "    df['day_of_month'] = df['date_dt'].dt.day\n",
    "    # Filter for relevant categories AND non-fixed amounts (exclude large monthly rent etc. if miscategorized)\n",
    "    monthly_pattern_df = df[\n",
    "        df['category'].isin(['Grocery', 'Shopping']) & (df['amount'] < 20000) # Avoid huge one-offs like Furniture if in Shopping\n",
    "    ]\n",
    "\n",
    "    if not monthly_pattern_df.empty:\n",
    "        daily_total = monthly_pattern_df.groupby('day_of_month')['amount'].sum().reset_index() # Look at SUM not mean per day\n",
    "\n",
    "        fig_month_day = px.bar(daily_total, x='day_of_month', y='amount',\n",
    "                               title='Total Grocery/Shopping Spend by Day of Month',\n",
    "                               labels={'day_of_month': 'Day of Month', 'amount': 'Total Amount (INR)'},\n",
    "                               height=400)\n",
    "        fig_month_day.update_layout(xaxis=dict(tickmode='linear', dtick=1)) # Ensure all days are shown\n",
    "        fig_month_day.show() # Display inline\n",
    "        # try: fig_month_day.write_image(IMG_DIR / \"monthly_day_spend_pattern.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save monthly pattern plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection + Quantitative)\n",
    "        logging.info(\"Check bar chart: Is spending clearly higher in the first ~10 days?\")\n",
    "        total_first_10 = daily_total[daily_total['day_of_month'] <= 10]['amount'].sum()\n",
    "        total_last_10 = daily_total[daily_total['day_of_month'] >= 22]['amount'].sum()\n",
    "        total_overall = daily_total['amount'].sum()\n",
    "\n",
    "        if total_overall > 0 and total_first_10 > total_last_10 * 1.3: # Check if first 10 days sum is >30% higher than last 10\n",
    "             logging.info(f\"Spending concentration early in the month observed (First 10 days: ~₹{total_first_10:,.0f} vs Last 10 days: ~₹{total_last_10:,.0f}).\")\n",
    "        elif total_overall > 0:\n",
    "             logging.warning(f\"Grocery/Shopping spending doesn't seem strongly concentrated early in the month (First 10: ~₹{total_first_10:,.0f} vs Last 10: ~₹{total_last_10:,.0f}).\")\n",
    "        else:\n",
    "            logging.info(\"Not enough spending data to assess intra-month pattern.\")\n",
    "\n",
    "    else:\n",
    "        logging.info(\"No relevant Grocery or Shopping data found for monthly pattern analysis.\")\n",
    "    # Clean up added column\n",
    "    if 'day_of_month' in df.columns: df.drop(columns=['day_of_month'], inplace=True)\n",
    "else:\n",
    "    print(\"Skipping intra-month pattern analysis.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 15. ML Suitability Check: Regression Potential (Flight Cost vs Month)\n",
    "\n",
    "Explore potential relationship for regression model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Regression Potential (Flight Cost vs Month) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "hovertemplate": "Month (1-12)=%{x}<br>Flight Amount (INR)=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "markers",
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "AgAAAAMAAAADAAAABQAAAAUAAAAFAAAABwAAAAcAAAAIAAAACAAAAAsAAAAMAAAADAAAAAEAAAACAAAAAwAAAAMAAAAFAAAABgAAAAwAAAACAAAAAwAAAA==",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "FK5H4foNxkBI4XoUrnytQLgeheuRgMZAhetRuF7EvkDXo3A9iuu9QDMzMzNztrdAKVyPwhWRw0CF61G43jm1QArXo3A91q1AH4XrUbgUxEDsUbgeZUTIQBSuR+G6eshAXI/C9SgAq0AK16NwvR3HQLgehetxUsJA16NwPYrLvEBI4XoUDjLFQFyPwvW45dBAMzMzMzP/rEAfhetRuEe+QHE9CtejLL1A4XoUrscfwEA=",
          "dtype": "f8"
         },
         "yaxis": "y"
        },
        {
         "hovertemplate": "<b>OLS trendline</b><br>amount = -103.772 * month_num + 9230.12<br>R<sup>2</sup>=0.010861<br><br>Month (1-12)=%{x}<br>Flight Amount (INR)=%{y} <b>(trend)</b><extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "lines",
         "name": "",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "AQAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAADAAAABQAAAAUAAAAFAAAABQAAAAYAAAAHAAAABwAAAAgAAAAIAAAACwAAAAwAAAAMAAAADAAAAA==",
          "dtype": "i4"
         },
         "xaxis": "x",
         "y": {
          "bdata": "h+uCrSzTwUDbw6nbSZ/BQNvDqdtJn8FA28Op20mfwUAwnNAJZ2vBQDCc0Alna8FAMJzQCWdrwUAwnNAJZ2vBQDCc0Alna8FA2UweZqEDwUDZTB5moQPBQNlMHmahA8FA2UweZqEDwUAuJUWUvs/AQIP9a8Lbm8BAg/1rwtubwEDX1ZLw+GfAQNfVkvD4Z8BAqr0O9qCYv0BUblxS2zC/QFRuXFLbML9AVG5cUtswv0A=",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Flight Cost vs. Month of Booking"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickmode": "array",
         "tickvals": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12
         ],
         "title": {
          "text": "Month (1-12)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Flight Amount (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check scatter plot: Is there a visible trend (even slight)? Are outliers plausible flight costs?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns and 'sub_category' in df.columns:\n",
    "    print(\"\\n--- ML Check: Regression Potential (Flight Cost vs Month) ---\")\n",
    "    flight_df = df[df['sub_category'] == 'Flight'].copy()\n",
    "\n",
    "    if not flight_df.empty:\n",
    "        flight_df['month_num'] = flight_df['date_dt'].dt.month\n",
    "        fig_scatter_flight = px.scatter(flight_df, x='month_num', y='amount',\n",
    "                                        title='Flight Cost vs. Month of Booking',\n",
    "                                        labels={'month_num': 'Month (1-12)', 'amount': 'Flight Amount (INR)'},\n",
    "                                        trendline='ols', # Ordinary Least Squares trendline\n",
    "                                        height=400)\n",
    "        fig_scatter_flight.update_layout(xaxis = dict(tickmode = 'array', tickvals = list(range(1,13)))) # Show all months 1-12\n",
    "        fig_scatter_flight.show() # Display inline\n",
    "        # try: fig_scatter_flight.write_image(IMG_DIR / \"flight_cost_vs_month_scatter.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save flight scatter plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check scatter plot: Is there a visible trend (even slight)? Are outliers plausible flight costs?\")\n",
    "    else:\n",
    "        logging.info(\"No flight data found for regression check.\")\n",
    "else:\n",
    "    print(\"Skipping regression potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 16. ML Suitability Check: Classification Potential (Restaurant Spend Dist.)\n",
    "\n",
    "Look for potential thresholds to classify meals vs. snacks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Classification Potential (Restaurant Spend Distribution) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "bingroup": "x",
         "hovertemplate": "Amount (INR)=%{x}<br>count=%{y}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "",
         "nbinsx": 50,
         "orientation": "v",
         "showlegend": false,
         "type": "histogram",
         "x": {
          "bdata": "zczMzMyGikBxPQrXo+6OQFyPwvUoGHpAhetRuB7FiEDNzMzMzN+aQHE9CtejOoFArkfhehTslkAzMzMzM9dyQClcj8L1cHxACtejcD3EgkAAAAAAABx7QNejcD0KV6FASOF6FK5bnUDXo3A9Ch9oQOxRuB6FqaFAmpmZmZkJVUCkcD0KV+akQM3MzMzMrJNAcT0K16NgZECamZmZmRl3QD0K16Nwh5VApHA9CtfDnkA9CtejcC1nQJqZmZmZAX1A9ihcj8J2nUAfhetRuOehQOxRuB6F82BAexSuR+GicECuR+F6FEp8QArXo3A9wIJAw/UoXI8OekBxPQrXo+h6QNejcD0Kz5tACtejcL2Ao0A9CtejcAOPQOxRuB6Fs3xAcT0K16OllUApXI/C9Ux/QPYoXI/CzWVAMzMzMzPQmkCuR+F6FAZuQClcj8L1K59AH4XrUbjeT0BSuB6F68+fQM3MzMzM9HpAKVyPwvXJm0DhehSuR+mBQKRwPQrX62JAj8L1KFyqmUD2KFyPwmFzQHsUrkfhBntAKVyPwvUYWEDXo3A9CtWWQLgehetRUHlAXI/C9SikaEAUrkfheiSDQClcj8L1WGlAFK5H4Xr0iUDsUbgehRteQKRwPQrXMZJASOF6FK4bfkCF61G4niirQMP1KFyP/nFAZmZmZmbMiUAfhetRuL5jQI/C9ShcaYJAj8L1KFwYpEBcj8L1KCxyQBSuR+H6BKNAZmZmZmYieUCuR+F6FHiEQOF6FK5HwYFAXI/C9Si8dkDhehSuR1mpQBSuR+F6AoBApHA9CtdDWkBcj8L1KESZQGZmZmZm+odAmpmZmZkTjkA=",
          "dtype": "f8"
         },
         "xaxis": "x",
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "relative",
        "height": 400,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Distribution of Restaurant Transaction Amounts"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Amount (INR)"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "count"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check histogram: Is there a clear separation or multiple peaks suggesting distinct groups (e.g., snacks vs meals)? Or is it one large peak skewed right?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'category' in df.columns and 'amount' in df.columns:\n",
    "    print(\"\\n--- ML Check: Classification Potential (Restaurant Spend Distribution) ---\")\n",
    "    resto_df = df[df['category'] == 'Restaurant']\n",
    "\n",
    "    if not resto_df.empty:\n",
    "        fig_hist_resto = px.histogram(resto_df, x='amount', nbins=50, # More bins might show detail\n",
    "                                     title='Distribution of Restaurant Transaction Amounts',\n",
    "                                     labels={'amount': 'Amount (INR)'}, height=400)\n",
    "        fig_hist_resto.show() # Display inline\n",
    "        # try: fig_hist_resto.write_image(IMG_DIR / \"restaurant_amount_histogram.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save restaurant histogram: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check histogram: Is there a clear separation or multiple peaks suggesting distinct groups (e.g., snacks vs meals)? Or is it one large peak skewed right?\")\n",
    "    else:\n",
    "        logging.info(\"No Restaurant data found for classification check.\")\n",
    "else:\n",
    "    print(\"Skipping classification potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 17. ML Suitability Check: Segmentation Potential (Weekday vs Weekend)\n",
    "\n",
    "Compare spending profiles across predefined day type segments."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Segmentation Potential (Weekday vs Weekend Profiles) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "alignmentgroup": "True",
         "hovertemplate": "day_type=Weekday<br>Category=%{x}<br>% of Segment Total Spend=%{y}<extra></extra>",
         "legendgroup": "Weekday",
         "marker": {
          "color": "#636efa",
          "pattern": {
           "shape": ""
          }
         },
         "name": "Weekday",
         "offsetgroup": "Weekday",
         "orientation": "v",
         "showlegend": true,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "Beauty",
          "Connectivity",
          "Education",
          "Entertainment",
          "Gifts & Donations",
          "Grocery",
          "Health",
          "Household",
          "Insurance Premium",
          "Investment",
          "Rent",
          "Restaurant",
          "Shopping",
          "Travel",
          "Waste"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "goQGR+vxEEAtumvUOvW7P4Iv4KHr+PU//WykTU1R+z9CwrZ5uPv5P2llXDgG1ARAynD1AcRCEkCsHyyt72UpQHiBOd/40CtAB1k7t0B8AUC4eZbZjMM0QJN54Aopmvw/LBiyWbaLMEAf8gAvvKEvQMwZBrzcPrM/",
          "dtype": "f8"
         },
         "yaxis": "y"
        },
        {
         "alignmentgroup": "True",
         "hovertemplate": "day_type=Weekend<br>Category=%{x}<br>% of Segment Total Spend=%{y}<extra></extra>",
         "legendgroup": "Weekend",
         "marker": {
          "color": "#EF553B",
          "pattern": {
           "shape": ""
          }
         },
         "name": "Weekend",
         "offsetgroup": "Weekend",
         "orientation": "v",
         "showlegend": true,
         "textposition": "auto",
         "type": "bar",
         "x": [
          "Beauty",
          "Connectivity",
          "Education",
          "Entertainment",
          "Gifts & Donations",
          "Grocery",
          "Health",
          "Household",
          "Insurance Premium",
          "Investment",
          "Rent",
          "Restaurant",
          "Shopping",
          "Travel",
          "Waste"
         ],
         "xaxis": "x",
         "y": {
          "bdata": "TW00Mo8rCkDIx10ruszBP175tRdjkfs/LIxVb5c++D8L0dcRip0BQENTOVdJGgxArSwV/rUjEUBxNmhN3oMyQAH2+5ifywxAZyGhXsTPAUD5lhIlLAw5QOoPCdiuCANAGDTRNwWJK0AW7jz5yHUxQGQQXa0rzdY/",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "barmode": "group",
        "height": 500,
        "legend": {
         "title": {
          "text": "Day Type"
         },
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Category Spending %: Weekday vs. Weekend"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "tickangle": -90,
         "title": {
          "text": "Category"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "% of Segment Spending"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check grouped bar chart: Are % allocations significantly different (e.g., higher Restaurant/Entertainment % on Weekends)?\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'day_of_week' in df.columns and 'category' in df.columns:\n",
    "    print(\"\\n--- ML Check: Segmentation Potential (Weekday vs Weekend Profiles) ---\")\n",
    "    df['day_type'] = df['day_of_week'].apply(lambda x: 'Weekend' if x in ['Saturday', 'Sunday'] else 'Weekday')\n",
    "\n",
    "    # Compare category distribution using normalized values within each segment\n",
    "    segment_cat_dist = df.groupby(['day_type', 'category'])['amount'].sum().unstack(fill_value=0)\n",
    "    segment_cat_dist_perc = segment_cat_dist.apply(lambda x: x / x.sum() * 100, axis=1).stack().reset_index(name='percentage')\n",
    "\n",
    "    fig_segment_bar = px.bar(segment_cat_dist_perc, x='category', y='percentage', color='day_type',\n",
    "                             barmode='group',\n",
    "                             title='Category Spending %: Weekday vs. Weekend',\n",
    "                             labels={'category': 'Category', 'percentage': '% of Segment Total Spend'},\n",
    "                             height=500)\n",
    "    fig_segment_bar.update_layout(xaxis_tickangle=-90, yaxis_title='% of Segment Spending', legend_title=\"Day Type\")\n",
    "    fig_segment_bar.show() # Display inline\n",
    "    # try: fig_segment_bar.write_image(IMG_DIR / \"weekday_weekend_segment_compare.png\") # Commented out\n",
    "    # except Exception as e: logging.error(f\"Failed to save segmentation comparison plot: {e}\")\n",
    "\n",
    "\n",
    "    # Discrepancy Check (Visual Inspection)\n",
    "    logging.info(\"Check grouped bar chart: Are % allocations significantly different (e.g., higher Restaurant/Entertainment % on Weekends)?\")\n",
    "\n",
    "    # Clean up added column\n",
    "    if 'day_type' in df.columns: df.drop(columns=['day_type'], inplace=True)\n",
    "\n",
    "else:\n",
    "    print(\"Skipping segmentation potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 18. ML Suitability Check: Clustering Potential (Daily Spend/Activity)\n",
    "\n",
    "Visualize daily aggregates to see if natural clusters appear."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- ML Check: Clustering Potential (Daily Spend vs. Activity) ---\n"
     ]
    },
    {
     "data": {
      "application/vnd.plotly.v1+json": {
       "config": {
        "plotlyServerURL": "https://plot.ly"
       },
       "data": [
        {
         "customdata": [
          [
           "2023-01-01"
          ],
          [
           "2023-01-02"
          ],
          [
           "2023-01-03"
          ],
          [
           "2023-01-04"
          ],
          [
           "2023-01-05"
          ],
          [
           "2023-01-06"
          ],
          [
           "2023-01-07"
          ],
          [
           "2023-01-08"
          ],
          [
           "2023-01-09"
          ],
          [
           "2023-01-10"
          ],
          [
           "2023-01-11"
          ],
          [
           "2023-01-12"
          ],
          [
           "2023-01-15"
          ],
          [
           "2023-02-01"
          ],
          [
           "2023-02-02"
          ],
          [
           "2023-02-03"
          ],
          [
           "2023-02-04"
          ],
          [
           "2023-02-05"
          ],
          [
           "2023-02-06"
          ],
          [
           "2023-02-07"
          ],
          [
           "2023-02-08"
          ],
          [
           "2023-02-10"
          ],
          [
           "2023-02-15"
          ],
          [
           "2023-03-01"
          ],
          [
           "2023-03-02"
          ],
          [
           "2023-03-03"
          ],
          [
           "2023-03-04"
          ],
          [
           "2023-03-05"
          ],
          [
           "2023-03-06"
          ],
          [
           "2023-03-10"
          ],
          [
           "2023-03-15"
          ],
          [
           "2023-03-20"
          ],
          [
           "2023-04-01"
          ],
          [
           "2023-04-02"
          ],
          [
           "2023-04-03"
          ],
          [
           "2023-04-04"
          ],
          [
           "2023-04-05"
          ],
          [
           "2023-04-10"
          ],
          [
           "2023-04-15"
          ],
          [
           "2023-05-01"
          ],
          [
           "2023-05-02"
          ],
          [
           "2023-05-03"
          ],
          [
           "2023-05-04"
          ],
          [
           "2023-05-05"
          ],
          [
           "2023-05-06"
          ],
          [
           "2023-05-07"
          ],
          [
           "2023-05-10"
          ],
          [
           "2023-05-15"
          ],
          [
           "2023-06-01"
          ],
          [
           "2023-06-02"
          ],
          [
           "2023-06-03"
          ],
          [
           "2023-06-04"
          ],
          [
           "2023-06-05"
          ],
          [
           "2023-06-06"
          ],
          [
           "2023-06-10"
          ],
          [
           "2023-06-15"
          ],
          [
           "2023-07-01"
          ],
          [
           "2023-07-02"
          ],
          [
           "2023-07-03"
          ],
          [
           "2023-07-04"
          ],
          [
           "2023-07-05"
          ],
          [
           "2023-07-10"
          ],
          [
           "2023-07-15"
          ],
          [
           "2023-08-01"
          ],
          [
           "2023-08-02"
          ],
          [
           "2023-08-03"
          ],
          [
           "2023-08-04"
          ],
          [
           "2023-08-05"
          ],
          [
           "2023-08-06"
          ],
          [
           "2023-08-07"
          ],
          [
           "2023-08-08"
          ],
          [
           "2023-08-09"
          ],
          [
           "2023-08-10"
          ],
          [
           "2023-08-15"
          ],
          [
           "2023-09-01"
          ],
          [
           "2023-09-02"
          ],
          [
           "2023-09-03"
          ],
          [
           "2023-09-04"
          ],
          [
           "2023-09-05"
          ],
          [
           "2023-09-06"
          ],
          [
           "2023-09-07"
          ],
          [
           "2023-09-08"
          ],
          [
           "2023-09-09"
          ],
          [
           "2023-09-10"
          ],
          [
           "2023-09-11"
          ],
          [
           "2023-09-15"
          ],
          [
           "2023-09-20"
          ],
          [
           "2023-10-01"
          ],
          [
           "2023-10-02"
          ],
          [
           "2023-10-03"
          ],
          [
           "2023-10-04"
          ],
          [
           "2023-10-05"
          ],
          [
           "2023-10-06"
          ],
          [
           "2023-10-07"
          ],
          [
           "2023-10-08"
          ],
          [
           "2023-10-09"
          ],
          [
           "2023-10-10"
          ],
          [
           "2023-10-15"
          ],
          [
           "2023-11-01"
          ],
          [
           "2023-11-02"
          ],
          [
           "2023-11-03"
          ],
          [
           "2023-11-04"
          ],
          [
           "2023-11-05"
          ],
          [
           "2023-11-06"
          ],
          [
           "2023-11-07"
          ],
          [
           "2023-11-08"
          ],
          [
           "2023-11-09"
          ],
          [
           "2023-11-10"
          ],
          [
           "2023-11-15"
          ],
          [
           "2023-12-01"
          ],
          [
           "2023-12-02"
          ],
          [
           "2023-12-03"
          ],
          [
           "2023-12-04"
          ],
          [
           "2023-12-05"
          ],
          [
           "2023-12-06"
          ],
          [
           "2023-12-10"
          ],
          [
           "2023-12-15"
          ],
          [
           "2024-01-01"
          ],
          [
           "2024-01-02"
          ],
          [
           "2024-01-03"
          ],
          [
           "2024-01-04"
          ],
          [
           "2024-01-05"
          ],
          [
           "2024-01-06"
          ],
          [
           "2024-01-07"
          ],
          [
           "2024-01-08"
          ],
          [
           "2024-01-09"
          ],
          [
           "2024-01-10"
          ],
          [
           "2024-01-15"
          ],
          [
           "2024-02-01"
          ],
          [
           "2024-02-02"
          ],
          [
           "2024-02-03"
          ],
          [
           "2024-02-04"
          ],
          [
           "2024-02-05"
          ],
          [
           "2024-02-10"
          ],
          [
           "2024-02-15"
          ],
          [
           "2024-03-01"
          ],
          [
           "2024-03-02"
          ],
          [
           "2024-03-03"
          ],
          [
           "2024-03-04"
          ],
          [
           "2024-03-05"
          ],
          [
           "2024-03-06"
          ],
          [
           "2024-03-07"
          ],
          [
           "2024-03-08"
          ],
          [
           "2024-03-10"
          ],
          [
           "2024-03-15"
          ],
          [
           "2024-03-20"
          ],
          [
           "2024-04-01"
          ],
          [
           "2024-04-02"
          ],
          [
           "2024-04-03"
          ],
          [
           "2024-04-04"
          ],
          [
           "2024-04-05"
          ],
          [
           "2024-04-10"
          ],
          [
           "2024-04-15"
          ],
          [
           "2024-05-01"
          ],
          [
           "2024-05-02"
          ],
          [
           "2024-05-03"
          ],
          [
           "2024-05-04"
          ],
          [
           "2024-05-05"
          ],
          [
           "2024-05-10"
          ],
          [
           "2024-05-15"
          ],
          [
           "2024-06-01"
          ],
          [
           "2024-06-02"
          ],
          [
           "2024-06-03"
          ],
          [
           "2024-06-04"
          ],
          [
           "2024-06-05"
          ],
          [
           "2024-06-06"
          ],
          [
           "2024-06-07"
          ],
          [
           "2024-06-10"
          ],
          [
           "2024-06-15"
          ],
          [
           "2024-07-01"
          ],
          [
           "2024-07-02"
          ],
          [
           "2024-07-03"
          ],
          [
           "2024-07-04"
          ],
          [
           "2024-07-05"
          ],
          [
           "2024-07-06"
          ],
          [
           "2024-07-10"
          ],
          [
           "2024-07-15"
          ],
          [
           "2024-08-01"
          ],
          [
           "2024-08-02"
          ],
          [
           "2024-08-03"
          ],
          [
           "2024-08-04"
          ],
          [
           "2024-08-05"
          ],
          [
           "2024-08-06"
          ],
          [
           "2024-08-07"
          ],
          [
           "2024-08-08"
          ],
          [
           "2024-08-09"
          ],
          [
           "2024-08-10"
          ],
          [
           "2024-08-15"
          ],
          [
           "2024-09-01"
          ],
          [
           "2024-09-02"
          ],
          [
           "2024-09-03"
          ],
          [
           "2024-09-04"
          ],
          [
           "2024-09-05"
          ],
          [
           "2024-09-06"
          ],
          [
           "2024-09-07"
          ],
          [
           "2024-09-08"
          ],
          [
           "2024-09-09"
          ],
          [
           "2024-09-10"
          ],
          [
           "2024-09-15"
          ],
          [
           "2024-09-20"
          ],
          [
           "2024-10-01"
          ],
          [
           "2024-10-02"
          ],
          [
           "2024-10-03"
          ],
          [
           "2024-10-04"
          ],
          [
           "2024-10-05"
          ],
          [
           "2024-10-06"
          ],
          [
           "2024-10-07"
          ],
          [
           "2024-10-08"
          ],
          [
           "2024-10-09"
          ],
          [
           "2024-10-10"
          ],
          [
           "2024-10-15"
          ],
          [
           "2024-11-01"
          ],
          [
           "2024-11-02"
          ],
          [
           "2024-11-03"
          ],
          [
           "2024-11-04"
          ],
          [
           "2024-11-05"
          ],
          [
           "2024-11-06"
          ],
          [
           "2024-11-07"
          ],
          [
           "2024-11-10"
          ],
          [
           "2024-11-15"
          ],
          [
           "2024-12-01"
          ],
          [
           "2024-12-02"
          ],
          [
           "2024-12-03"
          ],
          [
           "2024-12-04"
          ],
          [
           "2024-12-05"
          ],
          [
           "2024-12-06"
          ],
          [
           "2024-12-07"
          ],
          [
           "2024-12-08"
          ],
          [
           "2024-12-09"
          ],
          [
           "2024-12-10"
          ],
          [
           "2024-12-11"
          ],
          [
           "2024-12-15"
          ],
          [
           "2025-01-01"
          ],
          [
           "2025-01-02"
          ],
          [
           "2025-01-03"
          ],
          [
           "2025-01-04"
          ],
          [
           "2025-01-05"
          ],
          [
           "2025-01-06"
          ],
          [
           "2025-01-10"
          ],
          [
           "2025-01-15"
          ],
          [
           "2025-02-01"
          ],
          [
           "2025-02-02"
          ],
          [
           "2025-02-03"
          ],
          [
           "2025-02-04"
          ],
          [
           "2025-02-05"
          ],
          [
           "2025-02-06"
          ],
          [
           "2025-02-07"
          ],
          [
           "2025-02-08"
          ],
          [
           "2025-02-09"
          ],
          [
           "2025-02-10"
          ],
          [
           "2025-02-15"
          ],
          [
           "2025-03-01"
          ],
          [
           "2025-03-02"
          ],
          [
           "2025-03-03"
          ],
          [
           "2025-03-04"
          ],
          [
           "2025-03-05"
          ],
          [
           "2025-03-06"
          ],
          [
           "2025-03-07"
          ],
          [
           "2025-03-08"
          ],
          [
           "2025-03-09"
          ],
          [
           "2025-03-10"
          ],
          [
           "2025-03-11"
          ],
          [
           "2025-03-12"
          ],
          [
           "2025-03-15"
          ],
          [
           "2025-03-20"
          ],
          [
           "2025-04-01"
          ],
          [
           "2025-04-02"
          ],
          [
           "2025-04-03"
          ],
          [
           "2025-04-04"
          ],
          [
           "2025-04-05"
          ],
          [
           "2025-04-06"
          ],
          [
           "2025-04-10"
          ],
          [
           "2025-04-15"
          ]
         ],
         "hovertemplate": "Number of Transactions=%{x}<br>Total Amount Spent (INR)=%{y}<br>date=%{customdata[0]}<extra></extra>",
         "legendgroup": "",
         "marker": {
          "color": "#636efa",
          "symbol": "circle"
         },
         "mode": "markers",
         "name": "",
         "orientation": "v",
         "showlegend": false,
         "type": "scatter",
         "x": {
          "bdata": "BQQHBQUCAwQBAgUCAgUBBwMGBwUBAQEGBgUGBgMBAQEDBgcHAgEBBwcBBgUDBAEBBgUBBAUDAQEJBgQFAwEBCAYFBQQDBAEBAQEEBwYBBwMDAgMCAQEBBgIHAwUEBAUBAQEGBAEEBAYCAQEBAQkFBAIIBAEBBQEHBQQBAgEBAQIHBQYGAgEBBAQBAQcBBAcBAQEGBgQEBAEBBwQGAwcBAQMEBgcGAwMBAQkEBQQIAgEBBAECAQICBAICBwEDBAEEAwcCBwQBAQEFAgIGBgEFAQYDAQkFAwIFBgEBAQQCBAEDAwICBQgCAQQCBwUFBAECBQIGBwQBBAMFAgEJAwIBBAIDAwIDAwYBAQUFBwUGAQEB",
          "dtype": "i1"
         },
         "xaxis": "x",
         "y": {
          "bdata": "4XoUrn/44UBmZmZm5kmuQClcj8I16tBAXI/C9SjnxEDsUbgeJSrFQClcj8L11rNAcT0K16NFt0C4HoXrUWPAQM3MzMzM35pArkfhelTHsUAK16NwPS++QIXrUbg+MsRAAAAAAAAWpUAUrkfhMmrhQOF6FK7HmqZAzczMzIzzxUC4HoXrEVa0QIXrUbhuvNtAXI/C9Si30UCkcD0KN0vHQArXo3D9779AAAAAAABAr0AAAAAAAMCSQLgehevJ/ONAuB6F61GFz0AVrkfhOsLGQM3MzMxs6dBAAAAAABD70kCF61G4Hg7PQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQLgeheupLeFAZmZmZnbq00CZmZmZKWXbQHE9CtdzE9FASOF6FH4w1EAAAAAAAECvQAAAAAAAwJJAhetRuI7U6ED2KFyPIi3SQArXo3A9ml1A16NwPeoPyEBcj8L1SGzTQGZmZmZmF71APQrXo7AJxkAAAAAAAECvQAAAAAAAwJJA4XoUroev5UDXo3A96hrFQB+F61H4VcpA16NwPRpL20BwPQrXw+XLQBWuR+H6BMhAAAAAAABAr0AAAAAAAMCSQLgeheshg+pACtejcM3I2kBwPQrXgxTLQArXo3A9r9BAwvUoXM/4wkAAAAAAAECvQAAAAAAAwJJASOF6FPZ05EDXo3A9iojDQKRwPQqnG9dAXI/C9YitxUBcj8L1CF3TQHA9Ctdjd7ZA4noUrkfpsUCkcD0K1/2lQKRwPQrXjqxAAAAAAABAr0AAAAAAAMCSQLgehetZI+FAZmZmZiZlxkCuR+F61GDDQClcj8L1cIJAkML1KPyczUAfhetReBDDQD4K16MwnbRAwvUoXO9y0kApXI/CdTapQD4K16PwtrxA7FG4HsUZwEAAAAAAAMCSQAAAAAAA2+pApHA9CjeD5EBmZmZm5r2gQMP1KFyvuMBAuB6F69Gap0D2KFyP0rHbQNejcD3qI8NApHA9CleXw0AzMzMzEyjNQNejcD0KH6dAAAAAAABAr0AAAAAAAMCSQFK4HoWrh+ZAPgrXo3BOyUB7FK5HIWXDQAAAAACA3LZApHA9CjcX3EB7FK5HwVnDQIbrUbgeMKNAw/UoXI+SrUDhehSuR0SmQAAAAAAAQK9AAAAAAADAkkAK16NwNTzpQB6F61H4Zc1AmZmZmalF0EDsUbgeRWW0QClcj8JlItpAzczMzExStUAAAAAAAECvQAAAAAAAwJJAH4XrUVhV4UAK16NwvR3HQNejcD3qqs5AH4XrUTjEzkDiehSuZzzDQBSuR+G61dpAkML1KNzKp0AAAAAAAGKGQB+F61F4+LVAAAAAAABAr0AAAAAAABalQFyPwvVYOutAZmZmZnbB2UCPwvUofM7GQMP1KFxvKtZAFK5H4fpxuUAAAAAAAECvQAAAAAAAwJJAj8L1KOTf4kD2KFyPwsXAQFK4HoXrUKZAUrgehetNlECamZmZmQDQQPYoXI9izs9AuB6F65EkvkAAAAAAAJ3eQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQKRwPQr/g+NAXI/C9eDp4UD1KFyPQinLQLgehesBzNNAAAAAACDRy0AAAAAAAECvQAAAAAAAwJJAw/UoXDdA70C4HoXrkWG+QJmZmZn5idlA4noUrsciokBSuB6FO3bUQAAAAAAAQK9AAAAAAADAkkAzMzMzc67hQK5H4XqUiMZApHA9Chc2w0AfhetRaJ/hQGZmZmbGIdFANDMzMzNPl0DsUbgeJXrCQAAAAAAAQK9AAAAAAADAkkA9CtejULnnQIXrUbg+ZM1AkML1KOxe1UA+CtejMGzIQEjhehTu+dRAPgrXo/DFpUAAAAAAAECvQAAAAAAAwJJASOF6FIbG4EAK16NwPTypQNejcD0KV5pAzczMzMwojECPwvUoHEywQB+F61G4krVA9ihcj8L7sUAehetR+P+xQLgehetx38tAUrgehXP/5kAAAAAAAMCSQJqZmZkhU+BAcT0K1+Nw1kDNzMzMzHx6QEjhehTuQ7pAwvUoXI+axECF61G4bnXSQI/C9SjcPqFA7FG4HpVw0kCuR+F6NGPAQAAAAAAAQK9AAAAAAADAkkAAAAAAANvqQB+F61GQ2eBAUrgehasW1kCPwvUoXNipQClcj8KVH8RAMzMzM1PlxkAAAAAAAM2VQDQzMzNz4slAmpmZmRklq0BI4XoULi26QFK4HoVrDMlAAAAAAADAkkDhehSuz0/xQArXo3DNI9FAhetRuB6PukBmZmZmZraVQIXrUbj+Uc5AFK5H4bo/uEDhehSuR5evQAAAAAAAQK9AAAAAAADAkkDXo3A9ekzgQB6F61E48KdAKVyPwtWCyEDXo3A9Sgm3QOF6FK5HCsZAAAAAAIBIpEC4HoXrUXOTQM3MzMxMRaBA9ihcjwLPuUB7FK5HMXLiQKRwPQrXHbhAAAAAAADAkkC4HoXrcTnkQPYoXI9CFLRAhetRuL59z0DC9ShcjyLKQKRwPQp3Qc9AXI/C9bjg20AAAAAAAECvQAAAAAAAFqVAXI/C9YiL6kDsUbgehQemQHE9CtejRrlAZmZmZoZtwUD2KFyPgm/BQI/C9ShcaYJACtejcO0C0UAAAAAAwKC5QNijcD2KAr9AuB6F65FVv0AAAAAAAMCSQKRwPQqvAexAcT0K12P+u0ApXI/C9VCZQK5H4XoUBaJAwvUoXM9uwUDXo3A9ikalQJDC9ShchaVAKVyPwuXZ0kA+CtejcGKiQD0K16OwsrFAXI/C9SgumkB6FK5HgbvKQAAAAAAAwJJAAAAAAADb6kD2KFyP+vPiQIXrUbhuoddAPQrXo3C02EDXo3A9atzHQNejcD3qbMBAcT0K1yO4xkAAAAAAAECvQAAAAAAAwJJA",
          "dtype": "f8"
         },
         "yaxis": "y"
        }
       ],
       "layout": {
        "height": 500,
        "legend": {
         "tracegroupgap": 0
        },
        "template": {
         "data": {
          "bar": [
           {
            "error_x": {
             "color": "#2a3f5f"
            },
            "error_y": {
             "color": "#2a3f5f"
            },
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "bar"
           }
          ],
          "barpolar": [
           {
            "marker": {
             "line": {
              "color": "#E5ECF6",
              "width": 0.5
             },
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "barpolar"
           }
          ],
          "carpet": [
           {
            "aaxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "baxis": {
             "endlinecolor": "#2a3f5f",
             "gridcolor": "white",
             "linecolor": "white",
             "minorgridcolor": "white",
             "startlinecolor": "#2a3f5f"
            },
            "type": "carpet"
           }
          ],
          "choropleth": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "choropleth"
           }
          ],
          "contour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "contour"
           }
          ],
          "contourcarpet": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "contourcarpet"
           }
          ],
          "heatmap": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "heatmap"
           }
          ],
          "histogram": [
           {
            "marker": {
             "pattern": {
              "fillmode": "overlay",
              "size": 10,
              "solidity": 0.2
             }
            },
            "type": "histogram"
           }
          ],
          "histogram2d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2d"
           }
          ],
          "histogram2dcontour": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "histogram2dcontour"
           }
          ],
          "mesh3d": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "type": "mesh3d"
           }
          ],
          "parcoords": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "parcoords"
           }
          ],
          "pie": [
           {
            "automargin": true,
            "type": "pie"
           }
          ],
          "scatter": [
           {
            "fillpattern": {
             "fillmode": "overlay",
             "size": 10,
             "solidity": 0.2
            },
            "type": "scatter"
           }
          ],
          "scatter3d": [
           {
            "line": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatter3d"
           }
          ],
          "scattercarpet": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattercarpet"
           }
          ],
          "scattergeo": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergeo"
           }
          ],
          "scattergl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattergl"
           }
          ],
          "scattermap": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermap"
           }
          ],
          "scattermapbox": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scattermapbox"
           }
          ],
          "scatterpolar": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolar"
           }
          ],
          "scatterpolargl": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterpolargl"
           }
          ],
          "scatterternary": [
           {
            "marker": {
             "colorbar": {
              "outlinewidth": 0,
              "ticks": ""
             }
            },
            "type": "scatterternary"
           }
          ],
          "surface": [
           {
            "colorbar": {
             "outlinewidth": 0,
             "ticks": ""
            },
            "colorscale": [
             [
              0,
              "#0d0887"
             ],
             [
              0.1111111111111111,
              "#46039f"
             ],
             [
              0.2222222222222222,
              "#7201a8"
             ],
             [
              0.3333333333333333,
              "#9c179e"
             ],
             [
              0.4444444444444444,
              "#bd3786"
             ],
             [
              0.5555555555555556,
              "#d8576b"
             ],
             [
              0.6666666666666666,
              "#ed7953"
             ],
             [
              0.7777777777777778,
              "#fb9f3a"
             ],
             [
              0.8888888888888888,
              "#fdca26"
             ],
             [
              1,
              "#f0f921"
             ]
            ],
            "type": "surface"
           }
          ],
          "table": [
           {
            "cells": {
             "fill": {
              "color": "#EBF0F8"
             },
             "line": {
              "color": "white"
             }
            },
            "header": {
             "fill": {
              "color": "#C8D4E3"
             },
             "line": {
              "color": "white"
             }
            },
            "type": "table"
           }
          ]
         },
         "layout": {
          "annotationdefaults": {
           "arrowcolor": "#2a3f5f",
           "arrowhead": 0,
           "arrowwidth": 1
          },
          "autotypenumbers": "strict",
          "coloraxis": {
           "colorbar": {
            "outlinewidth": 0,
            "ticks": ""
           }
          },
          "colorscale": {
           "diverging": [
            [
             0,
             "#8e0152"
            ],
            [
             0.1,
             "#c51b7d"
            ],
            [
             0.2,
             "#de77ae"
            ],
            [
             0.3,
             "#f1b6da"
            ],
            [
             0.4,
             "#fde0ef"
            ],
            [
             0.5,
             "#f7f7f7"
            ],
            [
             0.6,
             "#e6f5d0"
            ],
            [
             0.7,
             "#b8e186"
            ],
            [
             0.8,
             "#7fbc41"
            ],
            [
             0.9,
             "#4d9221"
            ],
            [
             1,
             "#276419"
            ]
           ],
           "sequential": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ],
           "sequentialminus": [
            [
             0,
             "#0d0887"
            ],
            [
             0.1111111111111111,
             "#46039f"
            ],
            [
             0.2222222222222222,
             "#7201a8"
            ],
            [
             0.3333333333333333,
             "#9c179e"
            ],
            [
             0.4444444444444444,
             "#bd3786"
            ],
            [
             0.5555555555555556,
             "#d8576b"
            ],
            [
             0.6666666666666666,
             "#ed7953"
            ],
            [
             0.7777777777777778,
             "#fb9f3a"
            ],
            [
             0.8888888888888888,
             "#fdca26"
            ],
            [
             1,
             "#f0f921"
            ]
           ]
          },
          "colorway": [
           "#636efa",
           "#EF553B",
           "#00cc96",
           "#ab63fa",
           "#FFA15A",
           "#19d3f3",
           "#FF6692",
           "#B6E880",
           "#FF97FF",
           "#FECB52"
          ],
          "font": {
           "color": "#2a3f5f"
          },
          "geo": {
           "bgcolor": "white",
           "lakecolor": "white",
           "landcolor": "#E5ECF6",
           "showlakes": true,
           "showland": true,
           "subunitcolor": "white"
          },
          "hoverlabel": {
           "align": "left"
          },
          "hovermode": "closest",
          "mapbox": {
           "style": "light"
          },
          "paper_bgcolor": "white",
          "plot_bgcolor": "#E5ECF6",
          "polar": {
           "angularaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "radialaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "scene": {
           "xaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "yaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           },
           "zaxis": {
            "backgroundcolor": "#E5ECF6",
            "gridcolor": "white",
            "gridwidth": 2,
            "linecolor": "white",
            "showbackground": true,
            "ticks": "",
            "zerolinecolor": "white"
           }
          },
          "shapedefaults": {
           "line": {
            "color": "#2a3f5f"
           }
          },
          "ternary": {
           "aaxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "baxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           },
           "bgcolor": "#E5ECF6",
           "caxis": {
            "gridcolor": "white",
            "linecolor": "white",
            "ticks": ""
           }
          },
          "title": {
           "x": 0.05
          },
          "xaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          },
          "yaxis": {
           "automargin": true,
           "gridcolor": "white",
           "linecolor": "white",
           "ticks": "",
           "title": {
            "standoff": 15
           },
           "zerolinecolor": "white",
           "zerolinewidth": 2
          }
         }
        },
        "title": {
         "text": "Daily Spending vs. Number of Transactions"
        },
        "xaxis": {
         "anchor": "y",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Number of Transactions"
         }
        },
        "yaxis": {
         "anchor": "x",
         "domain": [
          0,
          1
         ],
         "title": {
          "text": "Total Amount Spent (INR)"
         }
        }
       }
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Check scatter plot: Do distinct visual groups (clusters) appear based on density? (e.g., low-count/low-spend corner, high-spend outliers, high-activity band).\n"
     ]
    }
   ],
   "source": [
    "if not df.empty and 'date_dt' in df.columns:\n",
    "    print(\"\\n--- ML Check: Clustering Potential (Daily Spend vs. Activity) ---\")\n",
    "    # Aggregate total amount and count transactions per day\n",
    "    # Need a unique identifier per row if 'id' isn't reliably generated/present; using index as fallback.\n",
    "    if 'id' not in df.columns: df['id_temp'] = df.index # Temporary ID if needed\n",
    "    else: df['id_temp'] = df['id'] # Use existing id if present\n",
    "\n",
    "    daily_summary = df.groupby(df['date_dt'].dt.date).agg(\n",
    "        total_amount=('amount', 'sum'),\n",
    "        transaction_count=('id_temp', 'nunique') # Count unique transactions per day\n",
    "    ).reset_index().rename(columns={'date_dt': 'date'})\n",
    "\n",
    "\n",
    "    # Clean up temp id column\n",
    "    if 'id_temp' in df.columns: df.drop(columns=['id_temp'], inplace=True)\n",
    "\n",
    "    if not daily_summary.empty:\n",
    "        fig_scatter_cluster = px.scatter(daily_summary, x='transaction_count', y='total_amount',\n",
    "                                        title='Daily Spending vs. Number of Transactions',\n",
    "                                        labels={'transaction_count': 'Number of Transactions', 'total_amount': 'Total Amount Spent (INR)'},\n",
    "                                        hover_data=['date'],\n",
    "                                        height=500)\n",
    "        fig_scatter_cluster.show() # Display inline\n",
    "        # try: fig_scatter_cluster.write_image(IMG_DIR / \"daily_spend_activity_scatter.png\") # Commented out\n",
    "        # except Exception as e: logging.error(f\"Failed to save daily cluster scatter plot: {e}\")\n",
    "\n",
    "        # Discrepancy Check (Visual Inspection)\n",
    "        logging.info(\"Check scatter plot: Do distinct visual groups (clusters) appear based on density? (e.g., low-count/low-spend corner, high-spend outliers, high-activity band).\")\n",
    "    else:\n",
    "        logging.info(\"Could not generate daily summary for clustering check.\")\n",
    "else:\n",
    "    print(\"Skipping clustering potential check.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 19. Overall Summary & Conclusion\n",
    "\n",
    "Final assessment based on the EDA checks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "INFO: Review the logs and plots above for ERRORs or WARNINGs indicating discrepancies.\n",
      "INFO: Key areas checked: Data loading, date range/formats, nulls, row/amount constraints, User/Account mapping, Category/SubCat mapping, fixed expense accuracy, variable amount distributions, ad-hoc frequencies, account usage bias, temporal patterns, and basic visual checks for ML suitability.\n",
      "INFO: Address critical ERRORs (e.g., mapping inconsistencies, constraint violations) by refining data generation script/rules and regenerating.\n",
      "INFO: Consider if WARNINGs (e.g., slight constraint overshoot, weaker-than-expected patterns) are acceptable or require tuning.\n",
      "INFO: Overall assessment: [MANUALLY ADD ASSESSMENT HERE - e.g., 'Data generated successfully and largely adheres to rules. Minor warnings noted for monthly totals. Suitable for Phase 2 development.', OR 'Critical errors found in mappings and frequencies; regeneration required.']\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "--- EDA Summary ---\n"
     ]
    }
   ],
   "source": [
    "print(\"\\n--- EDA Summary ---\")\n",
    "logging.info(\"Review the logs and plots above for ERRORs or WARNINGs indicating discrepancies.\")\n",
    "logging.info(\"Key areas checked: Data loading, date range/formats, nulls, row/amount constraints, User/Account mapping, Category/SubCat mapping, fixed expense accuracy, variable amount distributions, ad-hoc frequencies, account usage bias, temporal patterns, and basic visual checks for ML suitability.\")\n",
    "logging.info(\"Address critical ERRORs (e.g., mapping inconsistencies, constraint violations) by refining data generation script/rules and regenerating.\")\n",
    "logging.info(\"Consider if WARNINGs (e.g., slight constraint overshoot, weaker-than-expected patterns) are acceptable or require tuning.\")\n",
    "logging.info(\"Overall assessment: [MANUALLY ADD ASSESSMENT HERE - e.g., 'Data generated successfully and largely adheres to rules. Minor warnings noted for monthly totals. Suitable for Phase 2 development.', OR 'Critical errors found in mappings and frequencies; regeneration required.']\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "genai",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

"""

File: expenses_sample.csv
Location: reference\expenses_sample.csv
Summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes payments for house rent, maid salary, groceries, and a restaurant takeaway. The transactions are categorized by account, category, sub-category, type, user, and amount.
Code: """
      date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
01-01-2023  2023 2023-01 2023-W52      Sunday   Puspita-SBI  Household             Maid        Monthly Maid Salary Puspita  2500.00
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI    Grocery            Other         Meat/Fish Purchase Anirban   534.04
01-01-2023  2023 2023-01 2023-W52      Sunday   Puspita-SBI    Grocery Flipkart Grocery         FK Quick Groceries Puspita  2921.10
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI Restaurant         Takeaway               Lunch Parcel Anirban   848.85
"""

File: generate_data.py
Location: reference\generate_data.py
Summary: The script generates realistic expense data using predefined rules from 'sample_data_generation.csv' and outputs transactions to 'dummy_expenses_generated.csv' for the period 2023-01-01 to 2025-04-20. It handles fixed and ad-hoc transactions, ensuring monthly constraints are met, and logs progress and results.
Code: """
# reference/create_file_data.py
"""
Generates realistic expense data based on predefined rules and constraints.

Reads rules from 'sample_data_generation.csv' (in project root) and
outputs transactions to 'dummy_expenses_generated.csv' (in project root)
covering the period from 2023-01-01 to 2025-04-20.
"""

import pandas as pd
import numpy as np
import random
from datetime import datetime, timedelta
from pathlib import Path
import logging
from tqdm import tqdm # For progress bar
from typing import List, Dict, Any, Optional

# --- Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- File Paths (CRITICAL CHANGE) ---
# Get the directory where THIS script lives (reference/)
SCRIPT_DIR = Path(__file__).parent
# Get the parent directory (project root: app-personal-finance/)
PROJECT_ROOT = SCRIPT_DIR.parent

# Define paths relative to the PROJECT_ROOT
RULES_FILE = PROJECT_ROOT / "sample_data_generation.csv"
OUTPUT_FILE = PROJECT_ROOT / "dummy_expenses_generated.csv"
METADATA_FILE = PROJECT_ROOT / "expense_metadata.json" # Optional, for validation/reference

# Date Range
START_DATE = datetime(2023, 1, 1)
END_DATE = datetime(2025, 4, 20)

# Constraints
MONTHLY_MIN_TOTAL = 60000
MONTHLY_MAX_TOTAL = 120000
MONTHLY_MAX_ROWS = 100

# Ad-hoc Transaction Generation Parameters
AVG_ADHOC_PER_DAY = 4 # Average number of ad-hoc transactions per day
ADHOC_RANGE = (1, 7) # Min/Max ad-hoc transactions per day (adjust as needed)

# --- Helper Functions (No changes needed inside functions) ---

def load_rules(filepath: Path) -> Optional[pd.DataFrame]:
    """Loads and preprocesses the ruleset CSV."""
    if not filepath.exists():
        logging.error(f"Rules file not found: {filepath}")
        return None
    try:
        df_rules = pd.read_csv(filepath)
        df_rules.columns = [col.strip() for col in df_rules.columns]
        df_rules['Valid-expense-types'] = df_rules['Valid-expense-types'].str.split('|')
        for col in ['Min-expenses-amount', 'Max-expenses-amount', 'Max-times-per-month']:
            df_rules[col] = pd.to_numeric(df_rules[col], errors='coerce')
        df_rules['Max-times-per-month'].fillna(5, inplace=True)
        df_rules['Max-times-per-month'] = df_rules['Max-times-per-month'].astype(int)
        df_rules.dropna(subset=['Category', 'Sub-category', 'User', 'Account', 'Expense-Frequency', 'Min-expenses-amount', 'Max-expenses-amount'], inplace=True)
        logging.info(f"Loaded {len(df_rules)} rules from {filepath}")
        return df_rules
    except Exception as e:
        logging.error(f"Error loading or processing rules file {filepath}: {e}", exc_info=True)
        return None

def get_date_parts(date_obj: datetime) -> Dict[str, Any]:
    """Calculates derived date columns."""
    return {
        "date_dt": date_obj,
        "date": date_obj.strftime('%d-%m-%Y'),
        "year": date_obj.year,
        "month": date_obj.strftime('%Y-%m'),
        "week": date_obj.strftime('%Y-W%V'),
        "day_of_week": date_obj.strftime('%A')
    }

def generate_fixed_transaction(rule: pd.Series, date_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Generates a dictionary for a fixed transaction based on a rule."""
    if rule['Min-expenses-amount'] != rule['Max-expenses-amount']:
        logging.warning(f"Rule marked as fixed frequency but Min!=Max: {rule.to_dict()}")
        return None
    amount = rule['Min-expenses-amount']
    valid_types = rule['Valid-expense-types']
    selected_type = valid_types[0] if isinstance(valid_types, list) and valid_types else "Fixed Expense"
    return {
        **date_info, "account": rule['Account'], "category": rule['Category'],
        "sub_category": rule['Sub-category'], "type": selected_type,
        "user": rule['User'], "amount": amount
    }

def generate_adhoc_transaction(rule: pd.Series, date_info: Dict[str, Any]) -> Dict[str, Any]:
    """Generates a dictionary for an ad-hoc transaction based on a rule."""
    amount = round(random.uniform(rule['Min-expenses-amount'], rule['Max-expenses-amount']), 2)
    selected_type = random.choice(rule['Valid-expense-types']) if isinstance(rule['Valid-expense-types'], list) and rule['Valid-expense-types'] else "Ad-hoc Expense"
    return {
        **date_info, "account": rule['Account'], "category": rule['Category'],
        "sub_category": rule['Sub-category'], "type": selected_type,
        "user": rule['User'], "amount": amount
    }

def check_fixed_conditions(rule: pd.Series, current_date: datetime) -> bool:
    """Checks if a fixed/recurring rule should trigger on the current date."""
    freq = rule['Expense-Frequency']
    day = current_date.day
    month = current_date.month

    if freq == 'monthly':
        if rule['Category'] == 'Rent' and day == 1: return True
        if rule['Category'] == 'Household' and rule['Sub-category'] == 'Maid' and day == 1: return True
        if rule['Category'] == 'Investment' and rule['Sub-category'] == 'SIP' and day == 5: return True
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'ULIP' and day == 10: return True
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'Health Insurance' and day == 15: return True
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Netflix' and day == 20: return True # Example day for monthly connectivity
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Water' and day == 7: return True # Example day
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Maintenance' and day == 6: return True # Example day
        if rule['Category'] == 'Utilities' and rule['Sub-category'] == 'Garbage Collection' and day == 3: return True # Example day
        return False
    elif freq == 'bi-monthly': # Odd months, day 2
        return month % 2 != 0 and day == 2
    elif freq == 'once every 3 months': # Jan, Apr, Jul, Oct, day 3
        return month in [1, 4, 7, 10] and day == 3
    elif freq == 'once every 6 months': # Jan, Jul, day 4
        return month in [1, 7] and day == 4
    elif freq == 'bi-annually': # Mar 20, Sep 20
        return (month == 3 and day == 20) or (month == 9 and day == 20)
    elif freq == 'annually': # Jan 15
         # Handle specific annual items
        if rule['Category'] == 'Insurance Premium' and rule['Sub-category'] == 'Vehicle Insurance': return month == 2 and day == 25 # Example Date
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Prime Video': return month == 1 and day == 15 # Example Date
        if rule['Category'] == 'Connectivity' and rule['Sub-category'] == 'Disney+ Hotstar': return month == 1 and day == 16 # Example Date
        return False # Only trigger specific annuals
    return False

# --- Main Generation Logic (No changes needed inside function) ---
def generate_data():
    """Main function to generate the expense data."""
    logging.info("--- Starting Data Generation ---")
    logging.info(f"Looking for rules file at: {RULES_FILE}")
    logging.info(f"Output will be saved to: {OUTPUT_FILE}")

    df_rules = load_rules(RULES_FILE)
    if df_rules is None:
        return

    fixed_rules = df_rules[df_rules['Expense-Frequency'] != 'ad-hoc'].copy()
    adhoc_rules = df_rules[df_rules['Expense-Frequency'] == 'ad-hoc'].copy()

    all_transactions = []
    current_date = START_DATE
    total_days = (END_DATE - START_DATE).days + 1
    pbar = tqdm(total=total_days, desc="Generating Daily Transactions")

    current_month_str = ""
    current_month_total = 0.0
    current_month_rows = 0
    monthly_rule_counts: Dict[int, int] = {}

    while current_date <= END_DATE:
        date_info = get_date_parts(current_date)

        if date_info['month'] != current_month_str:
            if current_month_str:
                logging.info(f"Month {current_month_str} Summary: Rows={current_month_rows}, Total=₹{current_month_total:.2f}")
                if current_month_total < MONTHLY_MIN_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} BELOW target minimum ₹{MONTHLY_MIN_TOTAL}")
                if current_month_total > MONTHLY_MAX_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} ABOVE target maximum ₹{MONTHLY_MAX_TOTAL}")
                if current_month_rows > MONTHLY_MAX_ROWS: logging.warning(f"Month {current_month_str} rows {current_month_rows} EXCEEDED target maximum {MONTHLY_MAX_ROWS}")
            current_month_str = date_info['month']
            current_month_total = 0.0; current_month_rows = 0; monthly_rule_counts = {}
            logging.debug(f"Starting generation for month: {current_month_str}")

        # 1. Generate Fixed Transactions
        for index, rule in fixed_rules.iterrows():
            if check_fixed_conditions(rule, current_date):
                transaction = generate_fixed_transaction(rule, date_info)
                if transaction and current_month_rows < MONTHLY_MAX_ROWS + 5:
                     all_transactions.append(transaction)
                     current_month_total += transaction['amount']
                     current_month_rows += 1
                     monthly_rule_counts[index] = monthly_rule_counts.get(index, 0) + 1
                     logging.debug(f"Generated fixed: {transaction['category']}/{transaction['sub_category']} on {date_info['date']}")
                elif transaction:
                     logging.warning(f"Skipped fixed {rule['Category']}/{rule['Sub-category']} on {date_info['date']} (Monthly row limit: {current_month_rows})")

        # 2. Generate Ad-hoc Transactions
        num_adhoc_today = random.randint(ADHOC_RANGE[0], ADHOC_RANGE[1])
        adhoc_added_today = 0
        weights = adhoc_rules['Account'].apply(lambda x: 1.5 if x in ['Anirban-ICICI', 'Puspita-SBI'] else 1.0).values
        if weights.sum() > 0: weights = weights / weights.sum()
        else: weights = None

        for _ in range(num_adhoc_today):
            if current_month_total >= MONTHLY_MAX_TOTAL or current_month_rows >= MONTHLY_MAX_ROWS:
                logging.debug(f"Stopping ad-hoc for {date_info['date']} due to limits.")
                break
            if weights is None or adhoc_rules.empty: continue

            rule_selected = False
            for attempt in range(5):
                 try:
                     selected_rule_series = adhoc_rules.sample(n=1, weights=weights).iloc[0]
                     rule_index = selected_rule_series.name
                 except ValueError as e: logging.warning(f"Adhoc sample error: {e}"); continue

                 current_rule_count = monthly_rule_counts.get(rule_index, 0)
                 max_allowed = selected_rule_series['Max-times-per-month']

                 if current_rule_count < max_allowed:
                     transaction = generate_adhoc_transaction(selected_rule_series, date_info)
                     # Further check if adding this exceeds monthly total *drastically*
                     if current_month_total + transaction['amount'] <= MONTHLY_MAX_TOTAL * 1.05: # Allow slight overshoot
                         all_transactions.append(transaction)
                         current_month_total += transaction['amount']
                         current_month_rows += 1
                         monthly_rule_counts[rule_index] = current_rule_count + 1
                         adhoc_added_today += 1
                         rule_selected = True
                         logging.debug(f"Generated adhoc: {transaction['category']}/{transaction['sub_category']} on {date_info['date']}")
                         break # Exit retry loop
                     else:
                         logging.debug(f"Skipping adhoc {selected_rule_series['Category']}/{selected_rule_series['Sub-category']} to avoid exceeding monthly total drastically.")
                         # Don't break, allow trying another rule maybe
                 else:
                     logging.debug(f"Rule {rule_index} hit monthly limit ({max_allowed}). Retrying...")

            if not rule_selected: logging.debug(f"Could not find valid ad-hoc rule for {date_info['date']} after retries.")

        current_date += timedelta(days=1)
        pbar.update(1)

    pbar.close()
    # Log summary for the very last month
    if current_month_str:
        logging.info(f"Month {current_month_str} Summary: Rows={current_month_rows}, Total=₹{current_month_total:.2f}")
        if current_month_total < MONTHLY_MIN_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} BELOW target minimum ₹{MONTHLY_MIN_TOTAL}")
        if current_month_total > MONTHLY_MAX_TOTAL: logging.warning(f"Month {current_month_str} total ₹{current_month_total:.2f} ABOVE target maximum ₹{MONTHLY_MAX_TOTAL}")
        if current_month_rows > MONTHLY_MAX_ROWS: logging.warning(f"Month {current_month_str} rows {current_month_rows} EXCEEDED target maximum {MONTHLY_MAX_ROWS}")


    if not all_transactions:
        logging.warning("No transactions were generated.")
        return

    df_final = pd.DataFrame(all_transactions)
    output_columns = ['date', 'year', 'month', 'week', 'day_of_week', 'account', 'category', 'sub_category', 'type', 'user', 'amount']
    df_final = df_final[output_columns]

    logging.info(f"--- Data Generation Complete ---")
    logging.info(f"Total transactions generated: {len(df_final)}")

    try:
        df_final.to_csv(OUTPUT_FILE, index=False, encoding='utf-8')
        logging.info(f"Successfully saved generated data to: {OUTPUT_FILE}")
    except Exception as e:
        logging.error(f"Error saving output CSV file {OUTPUT_FILE}: {e}", exc_info=True)

# --- Execution Guard ---
if __name__ == "__main__":
    generate_data()
"""

File: generate_db.py
Location: reference\generate_db.py
Summary: The script processes 'data/expenses.csv' by reconstructing missing 'date' entries using 'year', 'month', and 'day_of_week', adds UUIDs, and saves the data to 'data/expenses.db'. It ensures required columns are present, converts dates, and writes the processed data to an SQLite database.
Code: """
# create_db.py
"""
This script reads 'data/expenses.csv', reconstructs missing 'date' entries using 'year', 'month', and 'day_of_week',
adds UUIDs, and saves the result into 'data/expenses.db'.
"""

import sqlite3
import pandas as pd
import uuid
from pathlib import Path
import calendar
from datetime import datetime

# Define paths
ROOT_DIR = Path(__file__).parent
DATA_DIR = ROOT_DIR / "data"
CSV_PATH = DATA_DIR / "expenses.csv"
DB_PATH = DATA_DIR / "expenses.db"

# Ensure data directory exists
DATA_DIR.mkdir(parents=True, exist_ok=True)

# Load CSV
df = pd.read_csv(CSV_PATH)

# Normalize column names
df.columns = (
    df.columns
    .str.strip()
    .str.lower()
    .str.replace("-", "_")
    .str.replace(" ", "_")
)

# Check if 'date' column exists; if not, create it
if 'date' not in df.columns:
    df['date'] = pd.NaT

# Convert 'date' column to datetime
df['date'] = pd.to_datetime(df['date'], errors='coerce')

# Identify rows with missing 'date' values
missing_date_mask = df['date'].isnull()

# Function to reconstruct date
def reconstruct_date(row):
    year = int(row['year'])
    month = int(row['month'].split('-')[1]) if isinstance(row['month'], str) and '-' in row['month'] else int(row['month'])
    day_name = row['day_of_week']
    # Get all days in the month
    month_calendar = calendar.monthcalendar(year, month)
    # Find the first occurrence of the specified day_of_week
    for week in month_calendar:
        for i, day in enumerate(week):
            if day != 0 and calendar.day_name[i] == day_name:
                return datetime(year, month, day)
    return pd.NaT

# Apply reconstruction to missing dates
df.loc[missing_date_mask, 'date'] = df[missing_date_mask].apply(reconstruct_date, axis=1)

# Check if any 'date' entries are still missing
still_missing = df['date'].isnull().sum()
if still_missing > 0:
    print(f"⚠️ Warning: {still_missing} 'date' entries could not be reconstructed and will be dropped.")
    df = df.dropna(subset=['date'])

# Generate derived date columns
df['month'] = df['date'].dt.to_period('M').astype(str)
df['week'] = df['date'].dt.strftime('%G-W%V')  # ISO week format
df['day_of_week'] = df['date'].dt.day_name()

# Format 'date' as string
df['date'] = df['date'].dt.strftime('%Y-%m-%d')

# Add UUID as primary key
df['id'] = [str(uuid.uuid4()) for _ in range(len(df))]

# Final schema validation
required_columns = {
    'date', 'account', 'category', 'sub_category', 'type',
    'user', 'amount', 'month', 'week', 'day_of_week'
}
missing_cols = required_columns - set(df.columns)
if missing_cols:
    raise ValueError(f"❌ Missing required column(s) after processing: {missing_cols}")

# Write to SQLite database
with sqlite3.connect(DB_PATH) as conn:
    df.to_sql("expenses", conn, if_exists="replace", index=False)

print(f"\n✅ Database successfully created at: {DB_PATH.resolve()}")
print(f"📊 Total records written: {len(df)}")

"""

File: generate_summary.py
Location: reference\generate_summary.py
Summary: The `generate_summary.py` script generates documentation for the `app-personal-finance` by combining functionalities from three scripts. It retrieves relevant files, reads and summarizes their content using OpenAI's API, compresses code details, and generates a folder tree. It excludes specified directories, files, and extensions during processing.
Code: """
#!/usr/bin/env python3
"""
generate_summary.py - Combined documentation generator for app-personal-finance
Combines functionality from:
- generate_code_details.py
- generate_code_details_compressed.py 
- generate_tree.py
"""

import os
import logging
from pathlib import Path
from dotenv import load_dotenv
from typing import List
import pandas as pd
from openai import OpenAI
from tenacity import retry, wait_random_exponential, stop_after_attempt
import tiktoken

# --- Configuration ---
load_dotenv()
SCRIPT_DIR = Path(__file__).resolve().parent
ROOT_DIR = SCRIPT_DIR.parent
REFERENCE_DIR = ROOT_DIR / "reference"

# File paths
CODE_DETAILS_PATH = REFERENCE_DIR / "instruction_code_details.txt"
COMPRESSED_PATH = REFERENCE_DIR / "instruction_code_details_compressed.txt"
TREE_PATH = REFERENCE_DIR / "instruction_file_tree.txt"

# Exclusion lists (combined from original scripts)
EXCLUDED_DIRS = {'.git', '__pycache__', '.vscode', '.idea', '.venv', 'venv', 
                '.mypy_cache', '.pytest_cache', '.git', '.vscode', '.idea', 'venv', '.github'}
EXCLUDED_FILES = {'.env', '.log', '.gitignore', '.env', '.gitignore'}
EXCLUDED_EXTENSIONS = {'.pyc', '.log', '.env', '.db', '.codespellignore'}

# OpenAI setup
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# --- Shared Functions from generate_code_details.py ---
def get_all_relevant_files(directory: Path) -> List[Path]:
    files = []
    for root, dirs, filenames in os.walk(directory):
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
        for fname in filenames:
            fpath = Path(root) / fname
            if (fpath.suffix.lower() not in EXCLUDED_EXTENSIONS and 
                fpath.name not in EXCLUDED_FILES):
                files.append(fpath)
    return files

def read_file_content(file_path: Path) -> str:
    try:
        if file_path.suffix.lower() == '.csv':
            df = pd.read_csv(file_path)
            return df.head().to_string(index=False)
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        logging.error(f"Error reading file {file_path}: {e}")
        return "Unable to read file."

@retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(6))
def summarize_content(content: str, model: str = "gpt-4o") -> str:
    try:
        encoding = tiktoken.encoding_for_model(model)
        tokens = encoding.encode(content)
        if len(tokens) > 12000:
            content = encoding.decode(tokens[:8000])
        response = client.chat.completions.create(
            model=model,
            messages=[{
                "role": "system",
                "content": "You are an assistant that summarizes code files."
            }, {
                "role": "user",
                "content": f"Summarize the following file in no more than 50 words:\n\n{content}"
            }],
            temperature=0.3,
            max_tokens=100
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        logging.error(f"OpenAI API error: {e}")
        return "Summary could not be generated."

# --- Compression Logic from generate_code_details_compressed.py ---
def compress_code_details():
    current_block = []
    in_code_block = False
    file_ext = None
    
    with open(CODE_DETAILS_PATH, 'r', encoding='utf-8') as infile, \
         open(COMPRESSED_PATH, 'w', encoding='utf-8') as outfile:
        
        for line in infile:
            line = line.strip()
            
            if line.startswith("File: "):
                if current_block:
                    _write_compressed_block(current_block, file_ext, outfile)
                    current_block = []
                current_block.append(f"# {line[6:]}")
            
            elif line.startswith("Location: "):
                path = line[10:]
                file_ext = Path(path).suffix.lower()
                current_block.append(f"@path: {path}")
            
            elif line.startswith("Summary: "):
                current_block.append(f"@summary: {line[9:]}")
            
            elif line == 'Code: """':
                in_code_block = True
                code_lines = []
            
            elif line == '"""' and in_code_block:
                in_code_block = False
                code = '\n'.join(code_lines)
                truncated = code[:6000] + ('[...]' if len(code) > 6000 else '') \
                    if file_ext == '.py' else code[:300] + ('[...]' if len(code) > 300 else '')
                current_block.append(f"@code:\n{truncated}")
            
            elif in_code_block:
                code_lines.append(line)
        
        if current_block:
            _write_compressed_block(current_block, file_ext, outfile)

def _write_compressed_block(block: list, ext: str, outfile):
    compressed = '\n'.join(block)
    marker = "#PY " if ext == '.py' else "#FILE "
    outfile.write(f"\n{compressed.replace('# ', marker)}\n")

# --- Tree Generation from generate_tree.py ---
def generate_folder_tree():
    with open(TREE_PATH, 'w', encoding='utf-8') as f:
        for root, dirs, files in os.walk(ROOT_DIR, topdown=True):
            dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
            level = root.replace(str(ROOT_DIR), '').count(os.sep)
            indent = ' ' * 4 * level
            
            if root == str(ROOT_DIR):
                f.write(f'{ROOT_DIR.name}/\n')
            else:
                f.write(f'{indent}{os.path.basename(root)}/\n')
            
            subindent = ' ' * 4 * (level + 1)
            for file in files:
                if file not in EXCLUDED_FILES:
                    f.write(f'{subindent}{file}\n')

# --- Main Execution Flow ---
def main():
    REFERENCE_DIR.mkdir(parents=True, exist_ok=True)
    
    # Step 1: Generate code details
    with open(CODE_DETAILS_PATH, 'w', encoding='utf-8') as out:
        out.write("# instruction_code_details.txt\n\"\"\"\nDescribes the functionality of each file...\n\"\"\"\n\n")
        for fpath in get_all_relevant_files(ROOT_DIR):
            rel_path = fpath.relative_to(ROOT_DIR)
            content = read_file_content(fpath)
            summary = summarize_content(content if fpath.suffix == '.py' else content[:1000])
            out.write(f"File: {fpath.name}\nLocation: {rel_path}\nSummary: {summary}\nCode: \"\"\"\n{content}\n\"\"\"\n\n")
    
    # Step 2: Compress code details
    compress_code_details()
    
    # Step 3: Generate folder tree
    generate_folder_tree()
    
    print(f"✅ Summary files generated in {REFERENCE_DIR}")

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()
"""

File: instruction_advanced_question_types.txt
Location: reference\instruction_advanced_question_types.txt
Summary: The file outlines how the Data Science Sub Agent (DSA) categorizes user questions into five advanced machine learning types: Regression, Forecasting, Classification, Segmentation, and Unsupervised Clustering. It provides detailed reasoning and examples for each type, specifically for a personal finance advisor app, emphasizing the unique focus of each ML approach.
Code: """
These are sample user questions.These are the questions which the DATA SCIENCE SUB AGENT (DSA) needs to answer. The DSA will categorize questions in one of the 5 advanced question types:Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering. Here we have detailed reasoning for 5 example question across each of the 5 ML types (Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering), specifically tailored for my 2-person personal finance advisor app.

1. Regression Questions (Predicting Specific Numerical Values)

	Goal: Predict a continuous numerical value (usually Amount) for a specific event or instance based on its characteristics.

	Why Regression (vs. Forecasting)? Focuses on the relationship between features of a single instance and its numerical outcome, rather than predicting the next value in a sequence based primarily on past values and time patterns.

	Question: "Predict the cost (Amount) of the next 'Household Repair' (Plumbing, Electrical, Appliance) needed, based on the specific type of repair (Sub-category) and the month it occurs?"

	Reasoning: This predicts a single numerical value (cost) for an often irregular event. Key predictors are the features of that specific event (type of repair, seasonality via month), not necessarily the cost of the last repair (as that could have been entirely different). It's not a time series prediction of monthly repair totals.

	Benefit: Helps anticipate costs for necessary but unpredictable maintenance.

	Question: "Estimate the Amount Anirban is likely to spend on a single 'Shopping' transaction at 'Amazon' or 'Flipkart', considering the platform (Sub-category), the month (for potential sales events), and the day of the week?"

	Reasoning: Predicts the value of one shopping instance. The platform (Amazon vs. Flipkart), time of year (sales), and whether it's a weekend might influence the basket size more directly than the amount spent on the previous online order. This models the characteristics-to-amount relationship for a specific event.

	Benefit: Understands typical spending per online shopping session on major platforms.

	Question: "What is the predicted Amount for a 'Food Delivery' order, based on the User ordering, the DayOfWeek, and potentially the restaurant mentioned in 'Type' (requires NLP)?"

	Reasoning: Focuses on predicting the cost of a single food delivery event. The user (different preferences/order sizes), day (weekend vs. weekday), and restaurant choice (if extractable) are direct features influencing the cost of that specific order, distinguishing it from forecasting total monthly food delivery spend.

	Benefit: Provides insight into typical meal costs when ordering in, varying by person and context.

	Question: "Predict the Amount Puspita will spend on her next 'Flight' booking, based on the month of booking and the account used ('Puspita-Bandhan' vs. 'Puspita-SBI')?"

	Reasoning: Predicts the cost of one specific, potentially high-value, and infrequent event. While seasonal factors (Month) matter, the model uses features associated with the booking event (like which account is used, potentially reflecting different trip types/budgets associated with that account) rather than forecasting a sequence of flight costs.

	Benefit: Helps plan for significant, variable travel expenses often associated with specific accounts or times of year.

	Question: "Estimate the Amount of a 'Gifts & Donations' transaction, based on the Sub-category ('Family', 'Friends', 'Charity', 'Temple') and the User making the transaction?"

	Reasoning: Predicts the value of a single gifting/donation instance. The recipient/purpose (Sub-category) and who is giving (User) are likely the primary drivers of the amount for that specific transaction, rather than forming a predictable time series pattern.

	Benefit: Understands typical spending levels for different types of gifts or donations, varying by person and occasion/recipient.

2. Forecasting Questions (Predicting Future Values in a Time Series)

	Goal: Predict future values (often numerical aggregates) of a variable that evolves sequentially over time.

	Why Forecasting (vs. Regression)? Focuses explicitly on the temporal dependencies – trend, seasonality, and autocorrelation (how past values influence future values) – inherent in the time series data itself. The primary input is the historical sequence.

	Question: "What is the forecasted total combined spending (Anirban + Puspita) across all categories for the next calendar month?"

	Reasoning: This predicts an aggregate value over a future time period (next month). The prediction relies primarily on the historical sequence of total monthly spending, capturing overall trends (e.g., lifestyle inflation) and seasonality (e.g., higher spending near holidays). This is a classic time series forecasting problem.

	Benefit: High-level budget planning and cash flow projection for the household.

	Question: "Forecast the total amount we are likely to spend on 'Groceries' in the next 4 weeks (providing a weekly breakdown)."

	Reasoning: Predicts an aggregate spend for a specific category over multiple future time periods (next 4 weeks). Grocery spending often has weekly cycles (stock-ups) and monthly patterns. Forecasting models explicitly handle these temporal patterns based on the history of weekly/monthly grocery totals.

	Benefit: Detailed near-term budget planning for a major, recurring expense category.

	Question: "What is the predicted total monthly spending attributed to Puspita for the next 3 months?"

	Reasoning: Treats Puspita's total personal spending as a time series. It forecasts the future aggregate monthly values based on her historical spending patterns, trends, and seasonality, distinct from predicting a single future transaction's amount based on its features (which would be regression).

	Benefit: Helps track and plan individual spending contributions and budgets over the medium term.

	Question: "Forecast the combined monthly spending specifically on the 'Waste' category (Smoke, Alcohol) for the next month."

	Reasoning: This involves predicting the aggregate amount for a specific (potentially sensitive) category over the next time period. Even if irregular, if there's any underlying trend or seasonality in this combined category total over months, forecasting attempts to capture it from the historical sequence.

	Benefit: Helps monitor and potentially manage spending in non-essential/habitual categories by predicting the near-term outlay based on past patterns.

	Question: "Predict the total number of transactions (count, not amount) we are likely to make as a couple in the next week."

	Reasoning: This forecasts a count over a future time period. Transaction frequency itself can be treated as a time series. It depends on the historical pattern of weekly transaction counts, including any day-of-week or intra-month effects. Regression wouldn't typically predict a count for a future period based on the sequence.

	Benefit: Provides insight into the activity level of spending, complementing amount-based forecasts. High frequency might indicate many small purchases.

3. Classification Questions (Predicting Predefined Labels)

	Goal: Assign an instance (e.g., a transaction, a day) to one of several predefined, discrete classes based on its features.

	Why Classification (vs. Segmentation/Clustering)? We are predicting membership in known, predefined categories (like Essential/Discretionary). We are not defining the segments themselves (Segmentation) or discovering unknown groups (Clustering).

	Question: "Classify each transaction as 'Essential' or 'Discretionary' based on its Category/Sub-category." (Requires a predefined mapping rule).

	Reasoning: Assigns each transaction instance to one of two predefined labels. This is the canonical classification task. It's not segmentation because we aren't analyzing the characteristics of the 'Essential' group vs. 'Discretionary' group, but rather labeling individual items. It's not clustering because the labels are known beforehand.

	Benefit: Automatic categorization for budget analysis (Needs vs. Wants).

	Question: "Based on amount, time of day, and day of week, classify a 'Restaurant' transaction as 'Meal' (likely lunch/dinner cost) or 'Snack/Coffee' (lower cost, typical cafe/snack times)?"

	Reasoning: Assigns restaurant transactions to one of two predefined functional categories ('Meal'/'Snack') based on their features. The rules/model defines the boundary between these known classes. It differs from clustering, which might discover different groupings automatically.

	Benefit: Provides more context to restaurant spending beyond just the total amount.

	Question: "Classify each month as a 'High Travel Spending Month' (Yes/No) based on whether total Travel category spending exceeds a certain threshold (e.g., ₹15,000 combined)?"

	Reasoning: Assigns a predefined binary label ('High Travel' / 'Normal Travel') to each month based on a rule applied to aggregated data for that month. It's classification because the label is predefined. It's not segmentation because the focus is labeling the month, not analyzing the characteristics of all 'High Travel Months' together.

	Benefit: Quickly identifies periods dominated by significant travel costs.

	Question: "Predict if a 'Shopping' transaction made by Anirban is likely for 'Electronics' (Yes/No) based on the Sub-category (Amazon, Flipkart, Purple, Lifestyle, Max, Myntra) and the Amount (higher amounts might suggest electronics)?"

	Reasoning: Assigns a predefined label ('Electronics'/'Not Electronics') to individual shopping transactions. This requires defining which sub-categories can sell electronics and potentially learning from amount patterns. It's classification because the target label is known.

	Benefit: Helps infer the purpose of shopping transactions on general platforms where the sub-category alone isn't specific enough.

	Question: "Classify a day as having 'Anomalous Spending' (Yes/No) if the total daily spend is significantly higher (e.g., > 3 standard deviations above the rolling monthly average) than usual for that day of the week?"

	Reasoning: Assigns a predefined binary label ('Anomalous'/'Normal') to each day based on a statistical rule comparing its spend to its historical context. It's classification because the label is defined by the rule. It differs from clustering which might find groups of 'high spending days' without the context of deviation from the norm.

	Benefit: Automatically flags days with unusually high expenditure for review.

4. Segmentation Questions (Analyzing Predefined Groups)

	Goal: Divide data into meaningful, predefined groups based on rules or shared characteristics, and then analyze and compare these segments.

	Why Segmentation (vs. Classification/Clustering)? The primary focus is on defining the groups first based on domain knowledge or specific criteria, and then describing or comparing the data within those defined segments. It's not predicting a label for new instances (Classification) or discovering unknown groups (Clustering).

	Question: "Compare the spending patterns (top categories, avg. transaction amount, user split) within two defined segments: 'Planned Recurring Expenses' (Rent, SIP, ULIP, Insurance Premiums) vs. 'Variable & Discretionary Expenses' (all other categories)."

	Reasoning: We first define segments based on category purpose ('Planned Recurring' vs. 'Variable/Discretionary'). The analysis then compares the characteristics of transactions falling into these predefined groups. This is segmentation analysis, not classification (not predicting segment for a new transaction) or clustering (segments are predefined).

	Benefit: Clearly separates committed outflows from flexible spending for high-level budget understanding.

	Question: "Analyze the 'High-Frequency Spending' segment (transactions under ₹300). What are the dominant categories, sub-categories, and users within this segment? Does its total monthly value change significantly?"

	Reasoning: We define a segment based on a rule (Amount < 300). The analysis then describes the composition (categories, users) and tracks the aggregate behavior (total value over time) of this specific, predefined segment.

	Benefit: Highlights where small, frequent purchases are occurring, often an area for potential budget leaks ("death by a thousand cuts").

	Question: "Segment monthly spending into 'Pay Week 1', 'Week 2', 'Week 3', 'Week 4+'. How does the distribution of spending across categories (e.g., % on Grocery vs. % on Entertainment) differ between these predefined intra-month time segments?"

	Reasoning: Segments are defined based on the week of the month (assuming a monthly pay cycle context). The analysis then compares the category breakdown across these predefined time-based segments.

	Benefit: Reveals spending patterns tied to pay cycles (e.g., more discretionary spending early in the month, bills later).

	Question: "Create user-based segments ('Anirban's Spending' vs. 'Puspita's Spending'). What are the key differences in their top 5 spending categories, average transaction values, and preferred accounts within their respective segments?"

	Reasoning: Segments are simply defined by the User field. The analysis then performs a comparative characterization between these two predefined segments.

	Benefit: Directly compares the financial habits and priorities of both individuals based on their tracked expenses.

	Question: "Define a 'Travel Mode Segment' (Flight, Train, Cab/Commute, Other Travel). What is the average cost, frequency, and associated user/account for transactions within each of these predefined travel sub-segments?"

	Reasoning: Segments are defined by grouping specific travel Sub-category values. The analysis then describes the typical financial characteristics associated with each defined travel mode.

	Benefit: Provides a clear cost and usage comparison between different forms of travel used by the couple.

5. Unsupervised Clustering Questions (Discovering Unknown Groups)

	Goal: Allow an algorithm to automatically discover natural groupings (clusters) within the data based on similarity across features, without using predefined labels.

	Why Clustering (vs. Classification/Segmentation)? The key is the discovery of groups. We don't know the optimal or 'correct' groupings beforehand. We want the algorithm to reveal structures or archetypes based purely on the data patterns, unlike classification (predicting known labels) or segmentation (analyzing predefined groups).

	Question: "Cluster our days based on the combination of total amount spent and the number of transactions that day. What kind of 'daily activity' clusters emerge (e.g., 'Low Spend/Low Activity', 'High Spend/Low Activity (single big purchase?)', 'Moderate Spend/High Activity (many small purchases?)')?"

	Reasoning: We don't predefine what makes a 'type' of day. We feed features (total daily amount, total daily transaction count) into a clustering algorithm (like K-Means) and let it find groups of days that are mathematically similar based on these two dimensions. We then interpret the resulting clusters.

	Benefit: Discovers data-driven daily spending styles beyond simple high/low thresholds.

	Question: "Based on the vector of monthly spending across all major categories, can we cluster the months? Do distinct 'financial character' months emerge automatically (e.g., months focused heavily on Investment, months dominated by Travel, 'balanced' months)?"

	Reasoning: We represent each month by its spending profile across categories (a vector of numbers). Clustering groups months with similar spending distributions, regardless of the absolute total spend. This might reveal patterns like "Holiday Prep Month" or "Saving Drive Month" without us defining those labels first.

	Benefit: Identifies seasonality or periods defined by shifting financial priorities across the board, discovered from the data itself.

	Question: "Cluster individual 'Grocery' transactions based on Amount, Store/Sub-category, and TimeOfDay (if available). What natural groupings of grocery runs are discovered (e.g., weekday morning top-ups at Local Store, large weekend BigBasket orders, late-night Zepto snacks)?"

	Reasoning: Aims to find inherent patterns within grocery shopping without pre-labeling runs as 'Stock-up' or 'Top-up'. The algorithm groups similar grocery transaction events based on cost, place, and potentially time.

	Benefit: May reveal more nuanced grocery shopping habits or contexts than simple rule-based classification.

	Question: "Can we cluster weeks based on the proportion of spending allocated to Needs (e.g., Rent, Grocery, Utilities) vs. Wants (e.g., Restaurant, Shopping, Entertainment)? Do weeks with distinct Needs/Wants balance ratios emerge?"

	Reasoning: We calculate features (proportion of spend on Needs, proportion on Wants) for each week and ask the clustering algorithm to group weeks with similar proportions, discovering different types of weekly budget allocations automatically.

	Benefit: Finds weeks characterized by different financial discipline levels or priorities based on the needs/wants balance, identified by the algorithm.

	Question: "Cluster Anirban's 'Shopping' transactions based on Amount and Platform/Sub-category. Are there distinct clusters representing, perhaps, 'Small Amazon Buys', 'Large Electronics Purchases (Flipkart/Amazon)', 'Clothing Hauls (Myntra/Lifestyle/Max)' that the data naturally separates?"

	Reasoning: Applies clustering specifically to Anirban's shopping data using amount and store type as features. The goal is to see if the algorithm discovers groupings that align with intuitive shopping purposes without us predefining them.

	Benefit: Data-driven identification of distinct shopping behavior types for a specific user, potentially revealing patterns not immediately obvious.
"""


"""

File: instruction_code_details_compressed.txt
Location: reference\instruction_code_details_compressed.txt
Summary: The `expense_metadata.json` file defines a transaction record format with a date and account options for Anirban and Puspita across various banks. It categorizes expenses into Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
Code: """

#FILE expense_metadata.json
@path: expense_metadata.json
@summary: The file outlines a transaction record format, including a date field and account options for Anirban and Puspita across various banks. It categorizes expenses into Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
@code:
{
"Date": "Date of the transaction (format: YYYY-MM-DD)",
"Account": [
"Anirban-SBI",
"Anirban-ICICI",
"Puspita-SBI",
"Puspita-Bandhan"
],
"categories": {
"Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
"Rent": ["House Rent"],
"Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "[...]

#FILE requirements-v2.0.txt
@path: requirements-v2.0.txt
@summary: The file is a list of dependencies for a core application, database, and GenAI & embeddings. It includes libraries like Streamlit, Pandas, NumPy, SQLAlchemy, and LangChain. Some dependencies are commented out, indicating they are not currently in use. Specific versions are kept for certain libraries like `python-dotenv` and `aiosqlite`.
@code:
#FILE Core Application
streamlit
pandas
numpy #FILE Removed specific version for now, let pip resolve
python-dateutil
python-dotenv==1.0.1 #FILE Keep specific version
requests

#FILE Database
aiosqlite==0.21.0         #FILE async SQLite support
#FILE faiss-cpu==1.10.0       #FILE Can be commented out if not used for metadata s[...]

#FILE .codespellignore
@path: assistant\finance-assistant\.codespellignore
@summary: Certainly! Please provide the content of the file you'd like summarized.
@code:


#FILE .env.example
@path: assistant\finance-assistant\.env.example
@summary: This file sets up environment variables for a project named "new-agent" to manage application traces. It includes API keys for different language model providers: Anthropic, Fireworks, and OpenAI, allowing the user to choose their preferred LLM configuration.
@code:
#FILE To separate your traces from other application
LANGSMITH_PROJECT=new-agent

#FILE The following depend on your selected configuration

##FILE LLM choice:
ANTHROPIC_API_KEY=....
FIREWORKS_API_KEY=...
OPENAI_API_KEY=...


#FILE langgraph.json
@path: assistant\finance-assistant\langgraph.json
@summary: This file specifies a configuration for a project, indicating dependencies located in the current directory, a graph definition for an "agent" located in `./src/agent/graph.py` with the entry point `graph`, and an environment configuration file named `.env`.
@code:
{
"dependencies": ["."],
"graphs": {
"agent": "./src/agent/graph.py:graph"
},
"env": ".env"
}


#FILE LICENSE
@path: assistant\finance-assistant\LICENSE
@summary: The file contains the MIT License for LangChain's 2024 software, allowing free use, modification, and distribution with attribution. It disclaims warranties and limits liability for damages.
@code:
MIT License

Copyright (c) 2024 LangChain

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, mer[...]

#FILE Makefile
@path: assistant\finance-assistant\Makefile
@summary: This Makefile defines targets for running tests, including unit, integration, and extended tests, using pytest. It also includes commands for test watching and profiling. Additionally, it provides targets for linting and formatting Python and notebook files, with specific configurations for different file sets. The default target is `help`.
@code:
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

#FILE Default target executed when no arguments are given to make.
all: help

#FILE Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
python -m pytest $(TEST_FILE)

integration_tes[...]

#FILE pyproject.toml
@path: assistant\finance-assistant\pyproject.toml
@summary: This file is a configuration for a Python project named "agent" version 0.0.1. It specifies project metadata, dependencies, and build settings. The project requires Python 3.9 or higher and includes optional development dependencies. It uses setuptools for packaging, and Ruff for linting with specific rules selected and ignored.
@code:
[project]
name = "agent"
version = "0.0.1"
description = "Starter template for making a new agent LangGraph."
authors = [
{ name = "William Fu-Hinthorn", email = "13333726+hinthornw@users.noreply.github.com" },
]
readme = "README.md"
license = { text = "MIT" }
requires-python = ">=3.9"
dependencies [...]

#FILE README.md
@path: assistant\finance-assistant\README.md
@summary: The "New LangGraph Project" repository on GitHub includes badges for continuous integration (CI) and integration tests, indicating automated testing workflows. It also features a badge to open the project in LangGraph Studio, suggesting a focus on graph-related functionalities. The project appears to be actively maintained with a structured testing process.
@code:
#FILE New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actio[...]

#FILE integration-tests.yml
@path: assistant\finance-assistant\.github\workflows\integration-tests.yml
@summary: The file is a GitHub Actions workflow named "Integration Tests" that runs daily at 7:37 AM Pacific Time. It supports manual triggers and cancels overlapping runs. The job tests on Ubuntu with Python versions 3.11 and 3.12, setting up Python and installing dependencies using a script.
@code:
#FILE This workflow will run integration tests for the current project once per day

name: Integration Tests

on:
schedule:
- cron: "37 14 * * *" #FILE Run at 7:37 AM Pacific Time (14:37 UTC) every day
workflow_dispatch: #FILE Allows triggering the workflow manually in GitHub UI

#FILE If another scheduled run star[...]

#FILE unit-tests.yml
@path: assistant\finance-assistant\.github\workflows\unit-tests.yml
@summary: This GitHub Actions workflow, named "CI," runs unit tests on the "main" branch upon push, pull requests, or manual dispatch. It uses a concurrency strategy to cancel previous runs if a new push occurs. The workflow tests on Ubuntu with Python versions 3.11 and 3.12, setting up Python, installing dependencies, and running tests.
@code:
#FILE This workflow will run unit tests for the current project

name: CI

on:
push:
branches: ["main"]
pull_request:
workflow_dispatch: #FILE Allows triggering the workflow manually in GitHub UI

#FILE If another push to the same PR or branch happens while this workflow is still running,
#FILE cancel the earlier r[...]

#PY configuration.py
@path: assistant\finance-assistant\src\agent\configuration.py
@summary: This code defines a `Configuration` class for an agent using Python's `dataclass`. It includes a configurable parameter `my_configurable_param` with a default value of "changeme". The class method `from_runnable_config` creates a `Configuration` instance from a `RunnableConfig` object.
@code:
"""Define the configurable parameters for the agent."""

from __future__ import annotations

from dataclasses import dataclass, fields
from typing import Optional

from langchain_core.runnables import RunnableConfig


@dataclass(kw_only=True)
class Configuration:
"""The configuration for the agent."""

#PY Changeme: Add configurable values here!
#PY these values can be pre-set when you
#PY create assistants (https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/)
#PY and when you invoke the graph
my_configurable_param: str = "changeme"

@classmethod
def from_runnable_config(
cls, config: Optional[RunnableConfig] = None
) -> Configuration:
"""Create a Configuration instance from a RunnableConfig object."""
configurable = (config.get("configurable") or {}) if config else {}
_fields = {f.name for f in fields(cls) if f.init}
return cls(**{k: v for k, v in configurable.items() if k in _fields})


#PY graph.py
@path: assistant\finance-assistant\src\agent\graph.py
@summary: The file defines a simple chatbot agent using a predefined response mechanism without a large language model. It sets up a state graph with a node called `my_node` that processes input using a configuration. The graph is compiled and named "New Graph" for execution.
@code:
"""Define a simple chatbot agent.

This agent returns a predefined response without using an actual LLM.

#PY state.py
@path: assistant\finance-assistant\src\agent\state.py
@summary: The file defines a `State` class using Python's `dataclass` to represent the input state for an agent, providing a structured interface to external data. The class includes a single attribute, `changeme`, initialized to "example". More details can be found at the provided Langchain documentation link.
@code:
"""Define the state structures for the agent."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class State:
"""Defines the input state for the agent, representing a narrower interface to the outside world.

This class is used to define the initial state and structure of incoming data.
See: https://langchain-ai.github.io/langgraph/concepts/low_level/#state
for more information.

#PY __init__.py
@path: assistant\finance-assistant\src\agent\__init__.py
@summary: The file defines a new module for a custom graph called "LangGraph Agent" by importing and exposing the "graph" component from the "agent.graph" module.
@code:
"""New LangGraph Agent.

This module defines a custom graph.

#FILE studio_ui.png
@path: assistant\finance-assistant\static\studio_ui.png
@summary: I'm unable to access the content of the file to summarize it. Please provide the text or key details from the file for a summary.
@code:
Unable to read file.

#PY test_graph.py
@path: assistant\finance-assistant\tests\integration_tests\test_graph.py
@summary: The file is a test script using `pytest` and `langsmith` to perform an asynchronous test on the `graph.ainvoke` function from the `agent` module. The test, `test_agent_simple_passthrough`, checks that the function returns a non-`None` result when invoked with a specific input.
@code:
import pytest
from langsmith import unit

from agent import graph


@pytest.mark.asyncio
@unit
async def test_agent_simple_passthrough() -> None:
res = await graph.ainvoke({"changeme": "some_val"})
assert res is not None


#PY __init__.py
@path: assistant\finance-assistant\tests\integration_tests\__init__.py
@summary: This file is a placeholder or instruction indicating that integration tests should be defined in the specified directory.
@code:
"""Define any integration tests you want in this directory."""


#PY test_configuration.py
@path: assistant\finance-assistant\tests\unit_tests\test_configuration.py
@summary: This code defines a test function `test_configuration_empty` that creates a `Configuration` object using an empty dictionary by calling the `from_runnable_config` method from the `Configuration` class.
@code:
from agent.configuration import Configuration


def test_configuration_empty() -> None:
Configuration.from_runnable_config({})


#PY __init__.py
@path: assistant\finance-assistant\tests\unit_tests\__init__.py
@summary: The file is a placeholder or instruction for defining unit tests within the directory, suggesting that any necessary test cases should be created here to ensure code functionality and reliability.
@code:
"""Define any unit tests you may want in this directory."""


#FILE expenses.csv
@path: data\expenses.csv
@summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes transactions for rent, household, grocery, and restaurant categories, with specific sub-categories like house rent, maid salary, and takeaway. The users involved are Anirban and Puspita, with amounts specified for each transaction.
@code:
date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
2023-01-01  2023 2023-01 2023-W52      Sun[...]

#FILE expenses_metadata_detailed.yaml
@path: metadata\expenses_metadata_detailed.yaml
@summary: The `expenses` table records financial transactions for users Anirban and Puspita, with each row representing a single expense. It tracks spending patterns and budget adherence. The primary key is `id`. Relationships map accounts to users, ensuring transactions are associated with the correct user based on account identifiers.
@code:
table_name: expenses
description: "Stores all recorded financial transactions for users Anirban and Puspita. Each row represents a single expense event. Used to track spending patterns, budget adherence, and answer financial queries."
primary_key: id #FILE Assuming 'id' is a UUID added during DB creatio[...]

#FILE expense_metadata.json
@path: metadata\expense_metadata.json
@summary: This file outlines a transaction record system, detailing transaction dates and associated accounts (e.g., Anirban-SBI, Puspita-Bandhan). It categorizes expenses into areas like Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, with specific subcategories for each.
@code:
{
"Date": "Date of the transaction (format: YYYY-MM-DD)",
"Account": [
"Anirban-SBI",
"Anirban-ICICI",
"Puspita-SBI",
"Puspita-Bandhan"
],
"categories": {
"Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
"Rent": ["House Rent"],
"Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "[...]

#FILE agentic_ds_app_prep.txt
@path: reference\agentic_ds_app_prep.txt
@summary: The file outlines a step for implementing agentic AI, focusing on generating additional data similar to a sample CSV. It specifies the data columns required, including date, year, month, week, day of the week, account, category, sub-category, transaction type, user, and transaction amount, with specific formats and constraints.
@code:
##FILE THINGS TO DO BEFORE AGENTIC AI IMPLEMENTATION

STEP 1: GENERATE MORE DATA
- Generate more data, similar to the sample dummy_expenses.csv, from 2023.01.01 - 2025.04.20 (current date). Important considerations for data generation:
- SUPER IMPORTANT: columns:
1. date: dd-mm-yyyy
2. year: yyyy
3. mon[...]

#FILE data_analysis.ipynb
@path: reference\data_analysis.ipynb
@summary: The file outlines an Exploratory Data Analysis (EDA) process for personal finance data, specifically focusing on analyzing a generated expense dataset (`dummy_expenses_generated.csv`). The objective is to validate the data's structure, adherence to rules, realism, and suitability for AI/ML tasks, using inline plots for visualization.
@code:
{
"cells": [
{
"cell_type": "markdown",
"metadata": {},
"source": [
"#FILE Exploratory Data Analysis (EDA) for Personal Finance Data (v2)\n",
"\n",
"**Objective:** Analyze the generated expense data (`dummy_expenses_generated.csv`) to validate its structure, adherence to generation rules, realism, and s[...]

#FILE expenses_sample.csv
@path: reference\expenses_sample.csv
@summary: The file logs financial transactions on 01-01-2023, detailing expenses by Anirban and Puspita across categories like rent, household, grocery, and restaurant. It includes transaction details such as account, category, sub-category, type, user, and amount spent.
@code:
date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
01-01-2023  2023 2023-01 2023-W52      Sun[...]

#PY generate_data.py
@path: reference\generate_data.py
@summary: The script generates realistic expense data using predefined rules from 'sample_data_generation.csv' and outputs transactions to 'dummy_expenses_generated.csv' for the period 2023-01-01 to 2025-04-20. It handles fixed and ad-hoc transactions, ensuring monthly constraints on totals and row counts are respected.
@code:
#PY reference/create_file_data.py

#PY generate_db.py
@path: reference\generate_db.py
@summary: The script processes 'data/expenses.csv' by reconstructing missing 'date' entries using 'year', 'month', and 'day_of_week', adds UUIDs, and saves the data to 'data/expenses.db'. It ensures required columns are present, formats dates, and handles missing data, ultimately writing the cleaned data to an SQLite database.
@code:
#PY create_db.py

#PY generate_summary.py
@path: reference\generate_summary.py
@summary: The script `generate_summary.py` generates documentation for the `app-personal-finance` by combining functionalities from three other scripts. It retrieves relevant files, reads their content, summarizes using OpenAI, compresses code details, and generates a folder tree. It excludes specified directories, files, and extensions during processing.
@code:
#!/usr/bin/env python3

#FILE instruction_advanced_question_types.txt
@path: reference\instruction_advanced_question_types.txt
@summary: The file outlines sample user questions for a Data Science Sub Agent (DSA) to categorize into five advanced machine learning types: Regression, Forecasting, Classification, Segmentation, and Unsupervised Clustering. It includes detailed reasoning for each type, with examples tailored for a personal finance advisor app.
@code:
These are sample user questions.These are the questions which the DATA SCIENCE SUB AGENT (DSA) needs to answer. The DSA will categorize questions in one of the 5 advanced question types:Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering. Here we have detailed reasoning fo[...]

#FILE instruction_code_details.txt
@path: reference\instruction_code_details.txt
@summary: The file `expense_metadata.json` specifies a transaction record format with a date field and account options for Anirban and Puspita across different banks. It categorizes expenses into Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
@code:
#FILE instruction_code_details.txt

#FILE expense_metadata.json
@path: expense_metadata.json
@summary: The file outlines a transaction record format, including a date field and account options for Anirban and Puspita across various banks. It categorizes expenses into Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, detailing specific items under each category.
@code:
{
"Date": "Date of the transaction (format: YYYY-MM-DD)",
"Account": [
"Anirban-SBI",
"Anirban-ICICI",
"Puspita-SBI",
"Puspita-Bandhan"
],
"categories": {
"Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
"Rent": ["House Rent"],
"Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "[...]

#FILE requirements-v2.0.txt
@path: requirements-v2.0.txt
@summary: The file is a list of dependencies for a core application, database, and GenAI & embeddings. It includes libraries like Streamlit, Pandas, NumPy, SQLAlchemy, and LangChain. Some dependencies are commented out, indicating they are not currently in use. Specific versions are kept for certain libraries like `python-dotenv` and `aiosqlite`.
@code:
#FILE Core Application
streamlit
pandas
numpy #FILE Removed specific version for now, let pip resolve
python-dateutil
python-dotenv==1.0.1 #FILE Keep specific version
requests

#FILE Database
aiosqlite==0.21.0         #FILE async SQLite support
#FILE faiss-cpu==1.10.0       #FILE Can be commented out if not used for metadata s[...]

#FILE .codespellignore
@path: assistant\finance-assistant\.codespellignore
@summary: Certainly! Please provide the content of the file you'd like summarized.
@code:


#FILE .env.example
@path: assistant\finance-assistant\.env.example
@summary: This file sets up environment variables for a project named "new-agent" to manage application traces. It includes API keys for different language model providers: Anthropic, Fireworks, and OpenAI, allowing the user to choose their preferred LLM configuration.
@code:
#FILE To separate your traces from other application
LANGSMITH_PROJECT=new-agent

#FILE The following depend on your selected configuration

##FILE LLM choice:
ANTHROPIC_API_KEY=....
FIREWORKS_API_KEY=...
OPENAI_API_KEY=...


#FILE langgraph.json
@path: assistant\finance-assistant\langgraph.json
@summary: This file specifies a configuration for a project, indicating dependencies located in the current directory, a graph definition for an "agent" located in `./src/agent/graph.py` with the entry point `graph`, and an environment configuration file named `.env`.
@code:
{
"dependencies": ["."],
"graphs": {
"agent": "./src/agent/graph.py:graph"
},
"env": ".env"
}


#FILE LICENSE
@path: assistant\finance-assistant\LICENSE
@summary: The file contains the MIT License for LangChain's 2024 software, allowing free use, modification, and distribution with attribution. It disclaims warranties and limits liability for damages.
@code:
MIT License

Copyright (c) 2024 LangChain

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, mer[...]

#FILE Makefile
@path: assistant\finance-assistant\Makefile
@summary: This Makefile defines targets for running tests, including unit, integration, and extended tests, using pytest. It also includes commands for test watching and profiling. Additionally, it provides targets for linting and formatting Python and notebook files, with specific configurations for different file sets. The default target is `help`.
@code:
.PHONY: all format lint test tests test_watch integration_tests docker_tests help extended_tests

#FILE Default target executed when no arguments are given to make.
all: help

#FILE Define a variable for the test file path.
TEST_FILE ?= tests/unit_tests/

test:
python -m pytest $(TEST_FILE)

integration_tes[...]

#FILE pyproject.toml
@path: assistant\finance-assistant\pyproject.toml
@summary: This file is a configuration for a Python project named "agent" version 0.0.1. It specifies project metadata, dependencies, and build settings. The project requires Python 3.9 or higher and includes optional development dependencies. It uses setuptools for packaging, and Ruff for linting with specific rules selected and ignored.
@code:
[project]
name = "agent"
version = "0.0.1"
description = "Starter template for making a new agent LangGraph."
authors = [
{ name = "William Fu-Hinthorn", email = "13333726+hinthornw@users.noreply.github.com" },
]
readme = "README.md"
license = { text = "MIT" }
requires-python = ">=3.9"
dependencies [...]

#FILE README.md
@path: assistant\finance-assistant\README.md
@summary: The "New LangGraph Project" repository on GitHub includes badges for continuous integration (CI) and integration tests, indicating automated testing workflows. It also features a badge to open the project in LangGraph Studio, suggesting a focus on graph-related functionalities. The project appears to be actively maintained with a structured testing process.
@code:
#FILE New LangGraph Project

[![CI](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml/badge.svg)](https://github.com/langchain-ai/new-langgraph-project/actions/workflows/unit-tests.yml)
[![Integration Tests](https://github.com/langchain-ai/new-langgraph-project/actio[...]

#FILE integration-tests.yml
@path: assistant\finance-assistant\.github\workflows\integration-tests.yml
@summary: The file is a GitHub Actions workflow named "Integration Tests" that runs daily at 7:37 AM Pacific Time. It supports manual triggers and cancels overlapping runs. The job tests on Ubuntu with Python versions 3.11 and 3.12, setting up Python and installing dependencies using a script.
@code:
#FILE This workflow will run integration tests for the current project once per day

name: Integration Tests

on:
schedule:
- cron: "37 14 * * *" #FILE Run at 7:37 AM Pacific Time (14:37 UTC) every day
workflow_dispatch: #FILE Allows triggering the workflow manually in GitHub UI

#FILE If another scheduled run star[...]

#FILE unit-tests.yml
@path: assistant\finance-assistant\.github\workflows\unit-tests.yml
@summary: This GitHub Actions workflow, named "CI," runs unit tests on the "main" branch upon push, pull requests, or manual dispatch. It uses a concurrency strategy to cancel previous runs if a new push occurs. The workflow tests on Ubuntu with Python versions 3.11 and 3.12, setting up Python, installing dependencies, and running tests.
@code:
#FILE This workflow will run unit tests for the current project

name: CI

on:
push:
branches: ["main"]
pull_request:
workflow_dispatch: #FILE Allows triggering the workflow manually in GitHub UI

#FILE If another push to the same PR or branch happens while this workflow is still running,
#FILE cancel the earlier r[...]

#PY configuration.py
@path: assistant\finance-assistant\src\agent\configuration.py
@summary: This code defines a `Configuration` class for an agent using Python's `dataclass`. It includes a configurable parameter `my_configurable_param` with a default value of "changeme". The class method `from_runnable_config` creates a `Configuration` instance from a `RunnableConfig` object.
@code:
"""Define the configurable parameters for the agent."""

from __future__ import annotations

from dataclasses import dataclass, fields
from typing import Optional

from langchain_core.runnables import RunnableConfig


@dataclass(kw_only=True)
class Configuration:
"""The configuration for the agent."""

#PY Changeme: Add configurable values here!
#PY these values can be pre-set when you
#PY create assistants (https://langchain-ai.github.io/langgraph/cloud/how-tos/configuration_cloud/)
#PY and when you invoke the graph
my_configurable_param: str = "changeme"

@classmethod
def from_runnable_config(
cls, config: Optional[RunnableConfig] = None
) -> Configuration:
"""Create a Configuration instance from a RunnableConfig object."""
configurable = (config.get("configurable") or {}) if config else {}
_fields = {f.name for f in fields(cls) if f.init}
return cls(**{k: v for k, v in configurable.items() if k in _fields})


#PY graph.py
@path: assistant\finance-assistant\src\agent\graph.py
@summary: The file defines a simple chatbot agent using a predefined response mechanism without a large language model. It sets up a state graph with a node called `my_node` that processes input using a configuration. The graph is compiled and named "New Graph" for execution.
@code:
"""Define a simple chatbot agent.

This agent returns a predefined response without using an actual LLM.

#PY state.py
@path: assistant\finance-assistant\src\agent\state.py
@summary: The file defines a `State` class using Python's `dataclass` to represent the input state for an agent, providing a structured interface to external data. The class includes a single attribute, `changeme`, initialized to "example". More details can be found at the provided Langchain documentation link.
@code:
"""Define the state structures for the agent."""

from __future__ import annotations

from dataclasses import dataclass


@dataclass
class State:
"""Defines the input state for the agent, representing a narrower interface to the outside world.

This class is used to define the initial state and structure of incoming data.
See: https://langchain-ai.github.io/langgraph/concepts/low_level/#state
for more information.

#PY __init__.py
@path: assistant\finance-assistant\src\agent\__init__.py
@summary: The file defines a new module for a custom graph called "LangGraph Agent" by importing and exposing the "graph" component from the "agent.graph" module.
@code:
"""New LangGraph Agent.

This module defines a custom graph.

#FILE studio_ui.png
@path: assistant\finance-assistant\static\studio_ui.png
@summary: I'm unable to access the content of the file to summarize it. Please provide the text or key details from the file for a summary.
@code:
Unable to read file.

#PY test_graph.py
@path: assistant\finance-assistant\tests\integration_tests\test_graph.py
@summary: The file is a test script using `pytest` and `langsmith` to perform an asynchronous test on the `graph.ainvoke` function from the `agent` module. The test, `test_agent_simple_passthrough`, checks that the function returns a non-`None` result when invoked with a specific input.
@code:
import pytest
from langsmith import unit

from agent import graph


@pytest.mark.asyncio
@unit
async def test_agent_simple_passthrough() -> None:
res = await graph.ainvoke({"changeme": "some_val"})
assert res is not None


#PY __init__.py
@path: assistant\finance-assistant\tests\integration_tests\__init__.py
@summary: This file is a placeholder or instruction indicating that integration tests should be defined in the specified directory.
@code:
"""Define any integration tests you want in this directory."""


#PY test_configuration.py
@path: assistant\finance-assistant\tests\unit_tests\test_configuration.py
@summary: This code defines a test function `test_configuration_empty` that creates a `Configuration` object using an empty dictionary by calling the `from_runnable_config` method from the `Configuration` class.
@code:
from agent.configuration import Configuration


def test_configuration_empty() -> None:
Configuration.from_runnable_config({})


#PY __init__.py
@path: assistant\finance-assistant\tests\unit_tests\__init__.py
@summary: The file is a placeholder or instruction for defining unit tests within the directory, suggesting that any necessary test cases should be created here to ensure code functionality and reliability.
@code:
"""Define any unit tests you may want in this directory."""


#FILE expenses.csv
@path: data\expenses.csv
@summary: The file is a financial transaction log detailing expenses on January 1, 2023. It includes transactions for rent, household, grocery, and restaurant categories, with specific sub-categories like house rent, maid salary, and takeaway. The users involved are Anirban and Puspita, with amounts specified for each transaction.
@code:
date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
2023-01-01  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
2023-01-01  2023 2023-01 2023-W52      Sun[...]

#FILE expenses_metadata_detailed.yaml
@path: metadata\expenses_metadata_detailed.yaml
@summary: The `expenses` table records financial transactions for users Anirban and Puspita, with each row representing a single expense. It tracks spending patterns and budget adherence. The primary key is `id`. Relationships map accounts to users, ensuring transactions are associated with the correct user based on account identifiers.
@code:
table_name: expenses
description: "Stores all recorded financial transactions for users Anirban and Puspita. Each row represents a single expense event. Used to track spending patterns, budget adherence, and answer financial queries."
primary_key: id #FILE Assuming 'id' is a UUID added during DB creatio[...]

#FILE expense_metadata.json
@path: metadata\expense_metadata.json
@summary: This file outlines a transaction record system, detailing transaction dates and associated accounts (e.g., Anirban-SBI, Puspita-Bandhan). It categorizes expenses into areas like Investment, Rent, Travel, Restaurant, Insurance Premium, Household, Connectivity, and Waste, with specific subcategories for each.
@code:
{
"Date": "Date of the transaction (format: YYYY-MM-DD)",
"Account": [
"Anirban-SBI",
"Anirban-ICICI",
"Puspita-SBI",
"Puspita-Bandhan"
],
"categories": {
"Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
"Rent": ["House Rent"],
"Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "[...]

#FILE agentic_ds_app_prep.txt
@path: reference\agentic_ds_app_prep.txt
@summary: The file outlines a step for implementing agentic AI, focusing on generating additional data similar to a sample CSV. It specifies the data columns required, including date, year, month, week, day of the week, account, category, sub-category, transaction type, user, and transaction amount, with specific formats and constraints.
@code:
##FILE THINGS TO DO BEFORE AGENTIC AI IMPLEMENTATION

STEP 1: GENERATE MORE DATA
- Generate more data, similar to the sample dummy_expenses.csv, from 2023.01.01 - 2025.04.20 (current date). Important considerations for data generation:
- SUPER IMPORTANT: columns:
1. date: dd-mm-yyyy
2. year: yyyy
3. mon[...]

#FILE data_analysis.ipynb
@path: reference\data_analysis.ipynb
@summary: The file outlines an Exploratory Data Analysis (EDA) process for personal finance data, specifically focusing on analyzing a generated expense dataset (`dummy_expenses_generated.csv`). The objective is to validate the data's structure, adherence to rules, realism, and suitability for AI/ML tasks, using inline plots for visualization.
@code:
{
"cells": [
{
"cell_type": "markdown",
"metadata": {},
"source": [
"#FILE Exploratory Data Analysis (EDA) for Personal Finance Data (v2)\n",
"\n",
"**Objective:** Analyze the generated expense data (`dummy_expenses_generated.csv`) to validate its structure, adherence to generation rules, realism, and s[...]

#FILE expenses_sample.csv
@path: reference\expenses_sample.csv
@summary: The file logs financial transactions on 01-01-2023, detailing expenses by Anirban and Puspita across categories like rent, household, grocery, and restaurant. It includes transaction details such as account, category, sub-category, type, user, and amount spent.
@code:
date  year   month     week day_of_week       account   category     sub_category                       type    user   amount
01-01-2023  2023 2023-01 2023-W52      Sunday Anirban-ICICI       Rent       House Rent Monthly House Rent Payment Anirban 30000.00
01-01-2023  2023 2023-01 2023-W52      Sun[...]

#PY generate_data.py
@path: reference\generate_data.py
@summary: The script generates realistic expense data using predefined rules from 'sample_data_generation.csv' and outputs transactions to 'dummy_expenses_generated.csv' for the period 2023-01-01 to 2025-04-20. It handles fixed and ad-hoc transactions, ensuring monthly constraints on totals and row counts are respected.
@code:
#PY reference/create_file_data.py

#PY generate_db.py
@path: reference\generate_db.py
@summary: The script processes 'data/expenses.csv' by reconstructing missing 'date' entries using 'year', 'month', and 'day_of_week', adds UUIDs, and saves the data to 'data/expenses.db'. It ensures required columns are present, formats dates, and handles missing data, ultimately writing the cleaned data to an SQLite database.
@code:
#PY create_db.py

#PY generate_summary.py
@path: reference\generate_summary.py
@summary: The script `generate_summary.py` generates documentation for the `app-personal-finance` by combining functionalities from three other scripts. It retrieves relevant files, reads their content, summarizes using OpenAI, compresses code details, and generates a folder tree. It excludes specified directories, files, and extensions during processing.
@code:
#!/usr/bin/env python3

#FILE instruction_advanced_question_types.txt
@path: reference\instruction_advanced_question_types.txt
@summary: The file outlines sample user questions for a Data Science Sub Agent (DSA) to categorize into five advanced machine learning types: Regression, Forecasting, Classification, Segmentation, and Unsupervised Clustering. It includes detailed reasoning for each type, with examples tailored for a personal finance advisor app.
@code:
These are sample user questions.These are the questions which the DATA SCIENCE SUB AGENT (DSA) needs to answer. The DSA will categorize questions in one of the 5 advanced question types:Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering. Here we have detailed reasoning fo[...]

#FILE instruction_code_details_compressed.txt
@path: reference\instruction_code_details_compressed.txt
@summary: The `expense_metadata.json` file defines a financial transaction record system, detailing transaction dates and accounts for Anirban and Puspita. It categorizes expenses into areas like Investment, Rent, Travel, and more, specifying items in each category. The `requirements-v2.0.txt` file lists project dependencies, including tools for core application, database, and data science tasks.
@code:

#FILE expense_metadata.json
@path: expense_metadata.json
@summary: The file outlines a financial transaction record system, including transaction dates and accounts for Anirban and Puspita. It categorizes expenses into areas such as Investment, Rent, Travel, Restaurant, Insurance Premium, Household[...]

#FILE instruction_file_tree.txt
@path: reference\instruction_file_tree.txt
@summary: The file structure outlines a personal finance application with components for data management, analysis, and a Streamlit interface. It includes scripts for data generation, analysis notebooks, and various instructions. The Streamlit app features utilities, styling, and tabs for adding expenses, generating reports, and visualizations.
@code:
app-personal-finance/
expense_metadata.json
requirements-v2.0.txt
data/
expenses.csv
expenses.db
metadata/
expense_metadata.json
reference/
agentic_ds_app_prep.txt
data_analysis.ipynb
expenses_sample.csv
generate_data.py
generate_db.py
generate_summary.py
instruction_advanced_question_types.txt
inst[...]

#FILE instruction_llm.txt
@path: reference\instruction_llm.txt
@summary: The file outlines instructions for building an autonomous, multi-agent data science assistant for a personal finance app. It emphasizes the transition from initial to current requirements, focusing on code generation and brainstorming. The project involves understanding the current requirement phase, project structure, and codebase, with resources provided for context.
@code:
Uploading the necessary files and reference links for context, read and understand:

INSTRUCTION_LLM: Specific instructions for you to follow: instruction_llm.txt, *THIS FILE*
INITIAL_REQUIREMENT (PHASE 1: DONE): requirement_v1_streamlit_app.txt - PHASE 1: This is the INITIAL REQUIREMENT. FOR UNDERS[...]

#FILE requirement_v1_streamlit_app.txt
@path: reference\requirement_v1_streamlit_app.txt
@summary: The document outlines the initial requirements for a personal finance app being developed by a couple in Bangalore. The app, intended for personal use, will be built using Python, SQLite3, and Streamlit. Its primary function is to track expenses, categorized into investment, rent, travel, restaurant, and insurance premium.
@code:
PHASE 1: This is the INITIAL REQUIREMENT. FOR UNDERSTANDING INITIAL SCOPE ONLY. CURRENT IMPLEMENTATION HAS CHANGED. REFER TO CODEBASE FOR CURRENT STATE.

PUBLIC GIT REPO LINK: https://github.com/AnirbanDattaTech/App-Personal-Finance.git

1. INITIAL PROMPT
my wife and i are building a personal financ[...]

#FILE requirement_v2_ds_assistant.txt
@path: reference\requirement_v2_ds_assistant.txt
@summary: The file outlines the development of a chatbot for querying data and providing insights related to exploratory data analysis (EDA) and data science. It will handle advanced statistical and machine learning questions using an SQLite database. The chatbot will remember conversation history within a session but not across sessions.
@code:
PHASE 2: This is the CURRENT REQUIREMENT.

PUBLIC GIT REPO LINK: https://github.com/AnirbanDattaTech/App-Personal-Finance.git

We will now start the development for a chatbot that can query the data and answer data insights, eda and data science related questions, to cover all areas a person might b[...]

#PY test_llm_gemini.py
@path: reference\test_llm_gemini.py
@summary: The script tests LangGraph and Gemini integration using Google Generative AI SDK. It configures the API, lists available models, loads sample data, and defines a workflow with nodes for fetching user questions and generating answers. It runs a test to analyze expense data, invoking the LangGraph with a sample question.
@code:
#PY reference/test_llm_gemini.py

#PY test_llm_openai.py
@path: reference\test_llm_openai.py
@summary: The file `test_llm_openai.py` tests the connection to the OpenAI API and lists available models. It sets up logging, loads the API key from environment variables, initializes the OpenAI client, and attempts to fetch and display the list of models. Errors are logged if the API key is missing or if fetching fails.
@code:
#PY FILE: test_llm_openai.py
#PY PURPOSE: Test OpenAI API connection and list available models.

import os
from openai import OpenAI
from dotenv import load_dotenv
import logging

#PY --- Configuration ---
#PY Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def list_openai_models():
"""Connects to OpenAI using the API key from environment variables
and lists the available models.

#PY db_utils.py
@path: streamlit\db_utils.py
@summary: This Python script provides utility functions for managing an SQLite database of expenses. It includes functions to establish database connections, fetch all or specific expenses, insert new expenses, update existing ones, and delete expenses. The script uses logging for error handling and debugging, and ensures database paths are correctly set using `pathlib`.
@code:
#PY streamlit/db_utils.py
import sqlite3
import pandas as pd
from uuid import uuid4
from pathlib import Path #PY Use pathlib
import logging
from typing import Optional, Dict, Any, List

#PY Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

#PY --- ✅ Define DB Path relative to the project root ---
#PY This assumes db_utils.py is in 'app-personal-finance/streamlit/'
#PY Path(__file__) gives the path to db_utils.py
#PY .parent gives 'app-personal-finance/streamlit/'
#PY .parent gives 'app-personal-finance/'
#PY Then we navigate to 'data/expenses.db'
PROJECT_ROOT = Path(__file__).parent.parent
DB_PATH = PROJECT_ROOT / "data" / "expenses.db"

#PY --- Optional: Check if DB exists and log ---
if not DB_PATH.exists():
logging.error(f"DATABASE NOT FOUND at expected location: {DB_PATH.resolve()}")
#PY Indicate the expected path based on calculation
logging.error(f"(Calculated from: {__file__})")
#PY You might want to raise an error or handle this case differently in a real app
else:
#PY Print statement removed as logging is now configured
logging.info(f"Using database at: {DB_PATH.resolve()}")
#PY ---

def get_connection() -> Optional[sqlite3.Connection]:

#PY main.py
@path: streamlit\main.py
@summary: The file `main.py` is the main application script for a Personal Expense Tracker using Streamlit. It configures the app's layout, handles page navigation, and calls rendering functions for different tabs: "Add Expenses," "Reports," "Visualizations," and a placeholder "Assistant." It also manages data export functionality and includes error handling for data loading.
@code:
#PY streamlit/main.py

#FILE styles.css
@path: streamlit\styles.css
@summary: The CSS file imports the 'Roboto' font and defines a set of light theme variables for a web application. These include colors for backgrounds, text, accents, borders, and states like success and warning, as well as a border radius and font family settings.
@code:
/* styles.css */

/* --- Base Font --- */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

/* --- Light Theme Variables --- */
:root {
--primary-bg-color: #FFFFFF;       /* White main background */
--secondary-bg-color: #F8F9FA;   /* Very light grey [...]

#PY style_utils.py
@path: streamlit\style_utils.py
@summary: The file defines a function `load_css()` that loads CSS from a `styles.css` file located in the same directory. It uses Streamlit to apply the styles and includes error handling with logging for file reading issues. If the CSS file is missing, a warning is logged.
@code:
#PY streamlit/style_utils.py
import streamlit as st
import logging
from pathlib import Path #PY Use pathlib for robust path handling

#PY --- Assume styles.css is in the same directory as this script ---
CSS_FILE = Path(__file__).parent / "styles.css"

def load_css():
"""Loads CSS from the styles.css file located in the same directory."""
if CSS_FILE.is_file():
try:
with open(CSS_FILE, "r") as f:
css = f.read()
st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)
#PY logging.info(f"Successfully loaded CSS from {CSS_FILE}") #PY Optional: for debugging
except Exception as e:
logging.error(f"Error reading CSS file {CSS_FILE}: {e}")
st.error("Failed to load page styles.")
else:
logging.warning(f"CSS file not found at expected location: {CSS_FILE}")
#PY st.warning("Page styling may be incomplete (CSS not found).")

#PY __init__.py
@path: streamlit\__init__.py
@summary: Certainly! Please provide the content of the file you would like summarized.
@code:


#PY add_expense.py
@path: streamlit\tabs\add_expense.py
@summary: The file `add_expense.py` is a Streamlit application module for adding and displaying expenses. It loads metadata, validates user inputs, and inserts expense data into a database. It also displays the last 10 expenses, highlighting the most recent addition. Error handling and logging are implemented for metadata loading and data operations.
@code:
#PY streamlit/tabs/add_expense.py
import streamlit as st
import pandas as pd
from db_utils import insert_expense, fetch_last_expenses #PY Use direct import based on previous findings
import json
import datetime
from typing import Dict, Any, Optional
import logging
import time
from pathlib import Path

#PY Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
"""Loads metadata from the project's metadata directory."""
if not METADATA_FILE_PATH.is_file():
logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
return None
try:
with open(METADATA_FILE_PATH, "r") as f:
metadata = json.load(f)
logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
return metadata
except json.JSONDecodeError as e:
logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted.")
return None
except Exception as e:
logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
st.error("Critical application error: An unexpected error occurred while loading metadata.")
return None

def render():
"""Renders the Add Expense page."""
if "trigger_rerun" in st.session_state and time.time() > st.session_state["trigger_rerun"]:
st.session_state.pop("trigger_rerun", None)
st.rerun()

st.subheader("Add New Expense")

metadata = load_metadata()
if metadata is None:
return

#PY Extract metadata components safely
all_accounts = metadata.get("Account", [])
category_map = metadata.get("categories", {})
all_categories = sorted(list(category_map.keys()))
user_map = metadata.get("User", {})

if not all_accounts or not all_categories or not category_map or not user_map:
st.error("Metadata structure is invalid or incomplete. Cannot proceed.")
logging.error("Invalid metadata structure detected after loading.")
return

#PY --- Inputs outside the form ---
expense_date = st.date_input("Date of Expense", value=datetime.date.today(), key="add_date")
selected_category = st.selectbox("Category", options=all_categories, index=0, key="add_category")
available_subcategories = sorted(category_map.get(selected_category, []))

#PY --- Input Form ---
with st.form("expense_form", clear_on_submit=True):
#PY Use columns for side-by-side layout
col1, col2 = st.columns(2)

#PY --- Widgets in Columns ---
#PY It's important that the order matches visually top-to-bottom
with col1:
selected_account = st.selectbox("Account", options=all_accounts, key="add_account")
subcat_disabled = not bool(available_subcategories)
selected_sub_category = st.selectbox(
"Sub-category",
options=available_subcategories,
key="add_sub_category", #PY Key remains the same
disabled=subcat_disabled,
help="Select a sub-category if applicable." if not subcat_disabled else "No sub-categories for this category."
)

with col2:
expense_type = st.text_input("Type (Description)", max_chars=60, key="add_type", help="Enter a brief description of the expense.")
expense_amount = st.number_input("Amount (INR)", min_value=0.01, format="%.2f", step=10.0, key="add_amount") #PY Key remains the same

#PY --- Form Submission Button ---
submitted = st.form_submit_button("Add Expense")

#PY --- Submission Logic ---
if submitted:
is_valid = True
expense_user = user_map.get(selected_account, "Unknown") #PY Derive user here
if not expense_type.strip():
st.toast("⚠️ Please enter a Type/Description.", icon="⚠️"); is_valid = False
if expense_amount <= 0:
st.toast("⚠️ Amount must be greater than zero.", icon="⚠️"); is_valid = False
if available_subcategories and not selected_sub_category:
st.toast("⚠️ Please select a Sub-category.", icon="⚠️"); is_valid = False

if is_valid:
final_sub_category = selected_sub_category if available_subcategories else ""
dt = pd.to_datetime(expense_date)
expense_data = {
"date": dt.strftime("%Y-%m-%d"), "year": dt.year,
"month": dt.to_period("M").strftime("%Y-%m"), "week": dt.strftime("%G-W%V"),
"day_of_week": dt.day_name(), "account": selected_account,
"category": selected_category, "sub_category": final_sub_category,
"type": expense_type.strip(), "user": expense_user, "amount": expense_amount
}
success = insert_expense(expense_data)
if success:
st.toast("✅ Expense added successfully!", icon="✅")
st.session_state["last_added"] = expense_data
st.session_state["highlight_time"] = time.time()
else:
st.toast("❌ Failed to save expense to the database.", icon="❌")

#PY --- Display Recent Entries ---
if "last_added" in st.session_state and "highlight_time" in st.session_state:
#PY Check if highlight time has expired
if time.time() - st.session_state["highlight_time"] <= 5:
st.success("Entry saved successfully!") #PY Show success message briefly
else:
#PY Clear state after timeout
st.session_state.pop("last_added", None)
st.session_state.pop("highlight_time", None)

st.markdown("---")
st.subheader("Last 10 Expenses Added")
try:
df = fetch_last_expenses(10)
if df.empty:
st.info("No recent expenses recorded yet.")
else:
highlight_index = None
last_added_data = st.session_state.get("last_added")
highlight_start_time = st.session_state.get("highlight_time")

if highlight_start_time and (time.time() - highlight_start_time > 5):
st.session_state.pop("last_added", None)
st.session_state.pop("highlight_time", None)
last_added_data = None

if last_added_data:
match = df[
(df["date"].dt.strftime('%Y-%m-%d') == last_added_data["date"]) &
(df["account"] == last_added_data["account"]) &
(df["category"] == last_added_data["category"]) &
(df["sub_category"].fillna("") == last_added_data["sub_category"]) &
(df["type"] == last_added_data["type"]) &
(df["user"] == last_added_data["user"]) &
(df["amount"].round(2) == round(float(last_added_data["amount"])[...]

#PY reports.py
@path: streamlit\tabs\reports.py
@summary: The `reports.py` file in a Streamlit application manages an expense report page. It loads metadata, fetches and filters expense data, and allows users to view, edit, or delete expenses. It includes functions for loading metadata, converting data to CSV, and rendering the main report view with filtering options. The file also handles user interactions for editing or deleting expenses, with appropriate validation and feedback.
@code:
#PY streamlit/tabs/reports.py
import streamlit as st
import pandas as pd
import datetime
import json
import logging
from typing import Dict, Any, Optional
#PY Assuming db_utils is importable from streamlit/
from db_utils import fetch_all_expenses, fetch_expense_by_id, update_expense, delete_expense
from pathlib import Path
import time #PY Keep for short sleep after successful edit/delete

#PY Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

#PY Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
"""Loads metadata from the project's metadata directory."""
if not METADATA_FILE_PATH.is_file():
logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
return None
try:
with open(METADATA_FILE_PATH, "r") as f:
metadata = json.load(f)
logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
return metadata
except json.JSONDecodeError as e:
logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted. Please check its format.")
return None
except Exception as e:
logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
st.error("Critical application error: An unexpected error occurred while loading metadata.")
return None

@st.cache_data
def convert_df_to_csv(df: pd.DataFrame) -> bytes:
"""Converts a DataFrame to CSV bytes."""
try:
if 'Date' in df.columns and pd.api.types.is_datetime64_any_dtype(df['Date']):
df_copy = df.copy()
df_copy['Date'] = df_copy['Date'].dt.strftime('%Y-%m-%d')
return df_copy.to_csv(index=False).encode("utf-8")
else:
return df.to_csv(index=False).encode("utf-8")
except Exception as e:
logging.error(f"CSV conversion failed: {e}")
st.error("Failed to generate CSV data.")
return b""

#PY ==============================================================================
#PY Main Rendering Function
#PY ==============================================================================
def render():
"""Renders the Reports page, handling view, edit, and delete modes."""
st.session_state.setdefault("edit_mode", False)
st.session_state.setdefault("delete_confirm", False)
st.session_state.setdefault("selected_expense_id", None)
st.session_state.setdefault("force_refresh", False)

metadata = load_metadata()
if metadata is None:
return

#PY --- ✅ Handle Refresh Request at the Top ---
#PY If flag is set from previous run (e.g., after edit/delete/button press)
if st.session_state.get("force_refresh", False):
st.session_state["force_refresh"] = False #PY Reset the flag immediately
st.cache_data.clear() #PY Clear cache to ensure fresh data fetch
#PY No explicit message needed, just let the page reload below
#PY The rerun itself is triggered by button clicks or state changes that set the flag

#PY --- Mode Handling ---
if st.session_state.edit_mode:
if st.session_state.selected_expense_id:
expense = fetch_expense_by_id(st.session_state.selected_expense_id)
if expense:
display_edit_form(expense, metadata)
else:
st.error(f"Could not load expense with ID {st.session_state.selected_expense_id} to edit.")
st.session_state.edit_mode = False
st.session_state.selected_expense_id = None
if st.button("Back to Report"): st.rerun()
return

elif st.session_state.delete_confirm:
if st.session_state.selected_expense_id:
expense = fetch_expense_by_id(st.session_state.selected_expense_id)
if expense:
display_delete_confirmation(expense)
else:
st.error(f"Could not load expense with ID {st.session_state.selected_expense_id} to delete.")
st.session_state.delete_confirm = False
st.session_state.selected_expense_id = None
if st.button("Back to Report"): st.rerun()
return

#PY --- Default Mode: Render Report View ---
render_report_view(metadata)

#PY ==============================================================================
#PY Report View Rendering Function
#PY ==============================================================================
def render_report_view(metadata: Dict[str, Any]):
"""Displays the main report view with filters and data table."""
st.subheader("Expense Report")

#PY --- Fetch Data ---
#PY This fetch happens on initial load or after a rerun triggered by refresh/edit/delete
df_all = fetch_all_expenses()

if df_all.empty:
st.info("No expense data available to display.")
return

#PY --- Prepare Data and Filter Options ---
try:
if not pd.api.types.is_datetime64_any_dtype(df_all['date']):
df_all['date'] = pd.to_datetime(df_all['date'], errors='coerce')
df_all.dropna(subset=['date'], inplace=True)

if 'month' not in df_all.columns and 'date' in df_all.columns:
df_all['month'] = df_all['date'].dt.strftime('%Y-%m')

required_cols = ['date', 'month', 'account', 'category', 'sub_category', 'user', 'amount', 'id', 'type']
if not all(col in df_all.columns for col in required_cols):
missing = [col for col in required_cols if col not in df_all.columns]
st.error(f"Database is missing required columns: {', '.join(missing)}. Cannot generate report.")
logging.error(f"Missing columns in fetched data: {missing}")
return

all_months = ["All"] + sorted(df_all['month'].unique(), reverse=True)
all_accounts = ["All"] + sorted(metadata.get("Account", []))
all_categories = ["All"] + sorted(list(metadata.get("categories", {}).keys()))
all_users = ["All"] + sorted(list(set(metadata.get("User", {}).values())))
category_map = metadata.get("categories", {})
except Exception as e:
st.error(f"Error preparing data or filter options: {e}")
logging.exception("Error during data preparation in reports tab.")
return


#PY --- Filter UI ---
st.markdown("####PY Filter Options")
month_selected = st.selectbox(
"Filter by Month", options[...]

#PY visuals.py
@path: streamlit\tabs\visuals.py
@summary: The file defines a Streamlit app module for visualizing expense data. It loads metadata, fetches expenses, and displays a 2x2 grid of charts: pie, bar, line, and horizontal bar charts. These charts visualize spending by category, trend over time, and top expense types, with interactive filters for customization.
@code:
#PY streamlit/tabs/visuals.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import json
import datetime
#PY Assuming db_utils is importable from streamlit/
from db_utils import fetch_all_expenses
from typing import Dict, Any, Optional
import logging
from pathlib import Path

#PY Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

#PY Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
"""Loads metadata from the project's metadata directory."""
if not METADATA_FILE_PATH.is_file():
logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
return None
try:
with open(METADATA_FILE_PATH, "r") as f:
metadata = json.load(f)
logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
return metadata
except json.JSONDecodeError as e:
logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted.")
return None
except Exception as e:
logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
st.error("Critical application error: An unexpected error occurred while loading metadata.")
return None

def get_common_layout_args(chart_title: str, show_legend: bool = False) -> Dict[str, Any]:
"""Generates common layout arguments for Plotly charts."""
return {
"title_text": chart_title,
"title_font_size": 16, "title_x": 0.5,
"margin": dict(l=20, r=20, t=50, b=80 if show_legend else 40),
"legend": dict(orientation="h", yanchor="bottom", y=-0.3, xanchor="center", x=0.5),
"hovermode": "closest",
"showlegend": show_legend
}

def render():
"""Renders the 'Visualizations' page with a 2x2 grid of charts."""
st.subheader("Expense Visualizations")

metadata = load_metadata()
if metadata is None: return

#PY --- Fetch Data ---
df_all = fetch_all_expenses()
if df_all.empty:
st.info("No expense data available for visualization.")
return

#PY --- Prepare Data ---
try:
if not pd.api.types.is_datetime64_any_dtype(df_all['date']):
df_all['date'] = pd.to_datetime(df_all['date'], errors='coerce')
df_all.dropna(subset=['date'], inplace=True)

if 'month' not in df_all.columns and 'date' in df_all.columns:
df_all['month'] = df_all['date'].dt.strftime('%Y-%m') #PY Use 'month' consistently

#PY Rename 'month' to 'YearMonth' for clarity if preferred, or just use 'month'
if 'month' in df_all.columns and 'YearMonth' not in df_all.columns:
df_all['YearMonth'] = df_all['month']

#PY Check for required columns
required_cols = ['YearMonth', 'category', 'amount', 'date', 'account', 'user', 'type', 'sub_category']
if not all(col in df_all.columns for col in ['YearMonth', 'category', 'amount', 'date', 'account', 'user', 'type']):
missing = [col for col in required_cols if col not in df_all.columns]
st.error(f"Required columns missing for visualizations: {missing}")
return

min_date = df_all['date'].min().date()
max_date = df_all['date'].max().date()
all_months = ["All"] + sorted(df_all['YearMonth'].unique(), reverse=True)
all_categories = ["All"] + sorted(list(metadata.get("categories", {}).keys()))
all_users = ["All"] + sorted(list(set(metadata.get("User", {}).values())))
all_accounts = ["All"] + sorted(metadata.get("Account", []))
except Exception as e:
st.error(f"Error preparing data or filter options: {e}")
logging.exception("Error during data preparation in visuals tab.")
return

#PY --- Initialize Session State for Legends ---
if 'legends' not in st.session_state:
st.session_state.legends = {'pie': False, 'bar': False, 'line': False, 'top': False}

#PY --- Layout for Charts ---
st.markdown("####PY Overview Charts")
row1_col1, row1_col2 = st.columns(2)
row2_col1, row2_col2 = st.columns(2)

#PY --- Chart 1: Pie Chart ---
with row1_col1:
st.markdown("######PY By Category (Proportion)")
#PY --- ✅ Updated Expander Label ---
with st.expander("Pie Chart Filters", expanded=False):
pie_month = st.selectbox("Month", all_months, 0, key="pie_month_filter")
pie_cats = st.multiselect("Category", all_categories, ["All"], key="pie_cat_filter")
pie_accounts = st.multiselect("Account", all_accounts, ["All"], key="pie_account_filter")
pie_users = st.multiselect("User", all_users, ["All"], key="pie_user_filter")

if st.button("Toggle Legend - Pie", key="pie_legend_btn"):
st.session_state.legends['pie'] = not st.session_state.legends['pie']

#PY Filter Data
pie_df = df_all.copy()
if pie_month != "All": pie_df = pie_df[pie_df['YearMonth'] == pie_month]
if "All" not in pie_cats: pie_df = pie_df[pie_df['category'].isin(pie_cats)]
if "All" not in pie_accounts: pie_df = pie_df[pie_df['account'].isin(pie_accounts)]
if "All" not in pie_users: pie_df = pie_df[pie_df['user'].isin(pie_users)]

#PY Aggregate and Plot
pie_data = pie_df.groupby('category')['amount'].sum().reset_index()
if not pie_data.empty and pie_data['amount'].sum() > 0:
fig_pie = px.pie(pie_data, values='amount', names='category', hole=0.4)
fig_pie.update_traces(textposition='inside', textinfo='percent+label', hoverinfo='label+percent+value')
fig_pie.update_layout(**get_common_layout_args("Spending by Category", st.session_state.legends['pie']))
st.plotly_chart(fig_pie, use_container_width=True)
elif not pie_df.empty:
st.info("No spending in selected categories/filters for Pie Chart.")
else:
st.info("No data matches filters for Pie Chart.")

#PY --- Chart 2: Bar Chart ---
with row1_col2:
st.markdown("######PY By Category (Absolute)")
with st.expander("Bar Chart Filters", expanded=False):
#PY ... (Filter widgets remain the same) ...
bar_start = st.date_input("Start Date", min_date, key="bar_start_filter")
bar_end = st.date_input("End Dat[...]

#PY __init__.py
@path: streamlit\tabs\__init__.py
@summary: Sure, please provide the content of the file you would like summarized.
@code:


"""

File: instruction_file_tree.txt
Location: reference\instruction_file_tree.txt
Summary: The file structure outlines a personal finance application, including configuration and test files for a finance assistant. Key components include JSON and YAML metadata, Python source code, testing scripts, and workflow configurations. It also contains data files for expenses and a static image for UI reference.
Code: """
app-personal-finance/
    expense_metadata.json
    requirements-v2.0.txt
    assistant/
        finance-assistant/
            .codespellignore
            .env.example
            langgraph.json
            LICENSE
            Makefile
            pyproject.toml
            README.md
            .github/
                workflows/
                    integration-tests.yml
                    unit-tests.yml
            src/
                agent/
                    configuration.py
                    graph.py
                    state.py
                    __init__.py
            static/
                studio_ui.png
            tests/
                integration_tests/
                    test_graph.py
                    __init__.py
                unit_tests/
                    test_configuration.py
                    __init__.py
    data/
        expenses.csv
        expenses.db
    metadata/
        expenses_metadata_detailed.yaml
        expense_metadata.json
    reference/
        agentic_ds_app_prep.txt
        data_analysis.ipynb
        expenses_sample.csv
        generate_data.py
        generate_db.py
        generate_summary.py
        instruction_advanced_question_types.txt
        instruction_code_details.txt
        instruction_code_details_compressed.txt
        instruction_file_tree.txt
        instruction_llm.txt
        requirement_v1_streamlit_app.txt
        requirement_v2_ds_assistant.txt
        test_llm_gemini.py
        test_llm_openai.py
        img/
    streamlit/
        db_utils.py
        main.py
        styles.css
        style_utils.py
        __init__.py
        tabs/
            add_expense.py
            reports.py
            visuals.py
            __init__.py

"""

File: instruction_llm.txt
Location: reference\instruction_llm.txt
Summary: The file outlines instructions for building an autonomous, multi-agent data science assistant for a personal finance app. It emphasizes transitioning from initial to current requirements, focusing on code generation and brainstorming. The project involves understanding the app's evolving scope, structure, and codebase, with resources like sample data and metadata provided for context.
Code: """
Uploading the necessary files and reference links for context, read and understand:

INSTRUCTION_LLM: Specific instructions for you to follow: instruction_llm.txt, *THIS FILE*
INITIAL_REQUIREMENT (PHASE 1: DONE): requirement_v1_streamlit_app.txt - PHASE 1: This is the INITIAL REQUIREMENT. FOR UNDERSTANDING INITIAL SCOPE ONLY. CURRENT IMPLEMENTATION HAS CHANGED. REFER TO CODEBASE FOR CURRENT STATE.
CURRENT_REQUIREMENT (PHASE 2: ONGOING): reference/requirement_v2_ds_assistant.txt - PHASE 2: This is the CURRENT REQUIREMENT.
PROJECT_STRUCTURE: reference/instruction_file_tree.txt
PROJECT_CODE_FILE_CONTENT: reference/instruction_code_details_compressed.txt
SAMPLE_DATA: expenses_sample.csv
SAMPLE_METADATA: expense_metadata.json

REQUIREMENT: Help me build an autonomous, multi agent data science assistant for my personal finances app (Refer: CURRENT_REQUIREMENT) through code generation and brainstorming.

PUBLIC GIT REPO FOR PROJECT: https://github.com/AnirbanDattaTech/App-Personal-Finance.git

Ensure, for all future project steps, code generation and brainstorming:
✅ Code generation - ALWAYS first start with a detailed understanding of the current implemented code (PROJECT_CODE_FILE_CONTENT). Understanding the current implementation and ensuring the generated code is compatible with the current codebase is *CRITICAL*.
✅ Code generation - ALWAYS write code compatible with openai >1.0.0 ENSURE openai current version.
✅ Code generation - Always recommend whether using base python scripts/ml (sklearn etc)/dl (torch etc)/ gen ai (llms) / agentic ai (llm + langgraph etc) will be most efficient for a certain request. Don't automatically follow suggestions. Recommend alternate, more efficient and better options first.
✅ Code generation - Always generate full code block for the .py files
✅ Code generation - Always include detailed explanation of code with remarks / comments in the code file
✅ Code generation - Always include proper python structure and type hints
✅ Code generation - All libraries are installed, imports are correct, versions are latest and no  version conflicts.
✅ Code generation - Ensure all python generated images have proper chart titles, x and y axis names, graphs and charts
✅ Paths-	Always use relative paths correctly (Path(__file__).parent / "...")
✅ Variables-	No undefined variables or misused constants
✅ Imports-	Fully compatible with current langchain, langgraph, langgraph-cli, openai, pydantic versions 
✅ Data Validation-	use Pydantic whereever applicable
✅ Output-	Files are correctly created with headers, even if fallback is needed
✅ File paths-	All file paths and relative paths are correct based on project dir (PROJECT_STRUCTURE)
✅ Prompt files-	all prompt files are referrenced correctly in code
✅ Output dirs-	all dirs (inputs and outputs) are validated
✅ Model- gpt-4o or fallback gpt-3.5-turbo
✅ detailed step by step instructions (dsbsi from now).

FOR ME ----
I will use #context snapshot command in gpt plus to create a snapshot.
I can also do:
	#context snapshot assistant → only assistant design summary
	#context snapshot codebase → current code files in use
	#context snapshot ml → ML modeling or DSA-related setup
	#context snapshot todo → list of pending next steps
"""

File: progress_summary.txt
Location: reference\progress_summary.txt
Summary: The file summarizes the setup progress for a LangGraph-based Finance Assistant in a Personal Finance App. The focus is on creating an agent to handle natural language queries, using Google Gemini for language processing, and integrating it with Streamlit via FastAPI. Key requirements and libraries have been updated.
Code: """
# FILE: session_summary_finance_assistant_setup.txt
# PURPOSE: Summary of progress for setting up the LangGraph-based Finance Assistant

Project Goal: Implement Phase 2 of the Personal Finance App: an autonomous multi-agent Data Science Assistant using LangGraph and Gemini, integrated into a new 'Assistant' tab in the existing Streamlit application.

Current Focus (Initial Implementation):
- Set up a basic agent architecture capable of handling simple natural language queries.
- The flow involves: Classifying the query -> Generating SQL -> Executing SQL -> Generating a Plotly Chart -> Summarizing the results with text.
- Utilize Google Gemini (gemini-1.5-flash-latest) as the LLM.
- Integrate this agent with the Streamlit frontend via an API exposed using LangServe/FastAPI.

Key Steps Completed & Decisions Made:
1.  Requirements Updated: Confirmed requirements-v2.0.txt includes necessary libraries like langgraph, langgraph-cli, langserve, fastapi, uvicorn, langchain-google-genai, plotly, SQLAlchemy, pandas, streamlit, requests, python-dotenv, pydantic, pyyaml.
2.  Project Structure: Utilized `langgraph new finance-assistant --template=1` (minimal template) to create the standard LangGraph CLI structure within an `assistant/` directory in the main project root (`app-personal-finance/`). Agent logic resides in `assistant/finance-assistant/src/agent/`. Server configuration is in `assistant/finance-assistant/app/server.py`.
3.  Environment Setup: Confirmed GOOGLE_API_KEY needs to be present in the root .env file.
4.  Metadata: Created and refined metadata/expenses_metadata_detailed.yaml to provide detailed schema information, including category/sub-category mappings and LLM usage guidance, loaded into the graph script.
5.  Agent State (AgentState): Defined the state structure using TypedDict in src/agent/state.py, including fields for original_query, classification, sql_query, sql_results_str, sql_results_df, chart_json, final_response, and error.
6.  Graph Nodes (src/agent/graph.py): Implemented all necessary node functions:
    - classify_query_node: Classifies query using Gemini.
    - generate_sql_node: Generates SQL using Gemini and loaded metadata.
    - execute_sql_node: Executes SQL using SQLAlchemy and returns DataFrame/string.
    - generate_chart_node: Generates Plotly JSON using heuristics based on DataFrame shape.
    - generate_response_node: Generates final text summary using Gemini, handling errors/results/chart availability (used standard PromptTemplate approach after debugging chat rendering issues).
7.  Graph Edge Logic (src/agent/graph.py): Implemented the should_continue function to route graph flow based on classification and error state.
8.  Graph Compilation (src/agent/graph.py): Defined the StateGraph, added nodes and edges, and compiled it into the required 'graph' variable for LangServe.
9.  API Server (app/server.py): Configured the FastAPI server using LangServe's add_routes to expose the compiled 'graph' at the /assistant endpoint. Defined Pydantic models (AssistantInput, AssistantOutput) for the API contract. Clarified the role of FastAPI/LangServe as the backend API layer separate from the Streamlit frontend.

Current Status:
- The LangGraph agent logic (graph.py) is fully defined.
- The LangServe API server (server.py) is configured to expose the graph.

Next Steps:
1.  Implement the Streamlit 'Assistant' tab (streamlit/tabs/assistant_tab.py) with the required 2-row/2-column layout.
2.  Implement the chat interface logic within the Streamlit tab.
3.  Implement the API call (using `requests`) from Streamlit to the running LangServe backend (http://localhost:8000/assistant/invoke).
4.  Implement logic in Streamlit to parse the API response (AssistantOutput) and display the final_response (chat), chart_json (Plotly chart), and sql_results_str (table/text).
5.  Update streamlit/main.py to include the new 'Assistant' tab.
6.  Perform end-to-end testing by running `langgraph start` and `streamlit run`.
"""

File: requirement_v1_streamlit_app.txt
Location: reference\requirement_v1_streamlit_app.txt
Summary: The file outlines an initial requirement for a personal finance app intended for personal use by a couple in Bangalore. The app will be developed using Python, SQLite3, and Streamlit, focusing on expense tracking. It categorizes expenses into types like Investment, Rent, Travel, Restaurant, and Insurance Premium.
Code: """
PHASE 1: This is the INITIAL REQUIREMENT. FOR UNDERSTANDING INITIAL SCOPE ONLY. CURRENT IMPLEMENTATION HAS CHANGED. REFER TO CODEBASE FOR CURRENT STATE.

PUBLIC GIT REPO LINK: https://github.com/AnirbanDattaTech/App-Personal-Finance.git

1. INITIAL PROMPT
my wife and i are building a personal finance app for just the 2 of us with you. We live in bangalore and use a lot of online platforms. we will build the app using python, sqlite3, streamlit and necessary python packages. It will be for jus the 2 of us to use. Main objective is to track expenses for both of us. So we are thinking to first create a expense category, expense sub-category and expense type.

categories = {
    "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
    "Rent": ["House Rent"],
    "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
    "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
    "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
    "Household": [
        "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
        "Pest Control", "Bike Maintenance", "Car Maintenance", 
        "Furniture", "Kitchen Tools", "Ironing", "Maid"
    ],
    "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
    "Waste": ["Smoke", "Alcohol"],
    "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
    "Beauty": ["Nykaa", "Meesho", "Purplle", "Salon", "Makeup", "Skincare", "Salon"],
    "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
    "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
    "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
    "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
    "Entertainment": ["Movies", "Concerts", "Games"],
    "Education": ["Online Courses", "Books", "Workshops"]
}

-----
I have updated the categories and subcategories. Some additional information: there are only 2 users: 'Anirban' and 'Puspita'. Anirban has the following bank accouts: 'Anirban-SBI' and 'Anirban-ICICI'.  Puspita has the following bank accouts: 'Puspita-SBI' and 'Puspita-Bandhan'. I want to keep the app as simple as possible, so i am thinking of creating a database (sqlite3 / csv) with the following columns: 
'Date': Date of transaction, 
'Account': One of the 4 accounts for me and my wife mentioned above, 
'Category': from the categories dictionary mentioned above, 
'Sub-category': from the categories dictionary mentioned above, 
'Type': Free text, we need to be able to enter it in the steamlit frontend, 
'User': One of the 2 values: 'Anirban', "Puspita" 
'Amount': amount of transaction.

Additional Instructions:
"Currency Format: Just plain numbers, keep it simple!
Frequency of Transactions: minimum: 2(atleat 1 transaction per user), maximum: 20
Expense Bias: Should we simulate more transactions from a specific account or category (e.g., more grocery or restaurant spends)? - Grocery and household are the biggest ones, but they are less than rent. House rent: once a month, fixed, 30000 (Anirban-ICICI). Maid: once a month, fixed, 2500 (Puspita-SBI). I pay house rent, wife pays rent. Puspita uses Puspita-Bandhan only for Travel and beauty categories. For me, most of the daily expenses are from Anirban-ICICI, with some from Anirban-SBI.
Include recurring transactions? Like SIPs, rent, etc. on specific days?SIP: once a month, 3000, fixed. ULIP: once a month, 4000. fixed I pay both from Anirban-ICICI.
match the type to category and sub category. For example, if: Category - household, Subcategory - Ironing, then type has to be ironing. if the cat - Travel and subcat -train, the type has to be something like: bangalore-mysore vande bharat, type can't be 'lab test', In summary, the type has to make sense for category and subcategory. Also, Puspita uses her bandhan for travel and rarely something else. In travel also, she will mainly use it to book train / flight tickets, not pay  parking fees, I pay that. Please regenerate accordingly."


First, please create a metadata file that will help you understand the data so you can understand the app requirement and help me build it. Donwload it to local. Then, create a sample csv file with the above structure and fill it with dummy data from 1 January, 2025 to 15 april, 2025. Refer to the metadata for 'account', 'Category', 'Sub-category', 'User'. Use your imagination for 'type' and 'amount'. Remember, simulate realistic data based on prices in bangalore, india. amouts are to be in inr. There has to be multiple entries per day just like a real scenario. Ask any clarification questions you need because it is very important to get the sample data right for the app. remember today is 15 april, don't confuse current date with your training data. We need this sample data to start building the app.
---------------


I want to to build a personal finance and expense tracker app for me and my wife. The idea is to track monthly spending by entering expenses manually. I have created a metada with an explanation of the data and attributes that will be considered. I also have a sample csv file that has the data in the structure and format that i want. I will upload both for your reference. The data model for the app is as follows: the app should have a table (either in sqlite3 or in csv) with the following columns: 

'Date': Date of transaction, 
'Account': One of the 4 accounts for me and my wife mentioned in the metadata, 
'Category': from the categories dictionary mentioned in the metadata, 
'Sub-category': from the categories dictionary mentioned in the metadata, 
'Type': Free text, we need to be able to enter it in the steamlit frontend, 
'User': One of the 2 values: 'Anirban', "Puspita" 
'Amount': amount of transaction.

Write the code and help me build a streamlit app that can run on my local machine.
Requirement:
	A. Design Requirement:
		1. The app should have 3 main pages / tabs.
			1a. page / tab 1: 'Add Expenses': This tab will have 2 main parts:
				1a1. Add Expenses: Here we will have an input form with the following input fields: 1. Date - filled manually 2. Account - one of the predefined values from the dropdown according to the metadata 3. Category - one of the predefined values from the dropdown according to the metadata, 4. Sub-category - one of the predefined values from the dropdown according to the metadata 5. Type - free text to be entered 6. user - one of the predefined values from the dropdown according to the metadata, 7. Amount - expense amount, to be filled in manually.
				
				1a2. Show last ten expenses from either user (showing 5 rows at a time, scrollable table). It needs to be updated when a new expense is added from the section 1a1. Add Expenses above.
				
			1b. page / tab 2: 'Reports' - This tab will have 2 main parts:
				1b1. Here the entire history report should be visible (up to 10 rows or so at a time, scrollable). It should have the following filters: 1. *Month* - to be extracted from the main data table shown as a checkbox with multi selection with 'all' option for all months in history, 2. *Account* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history 3. *Category* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history, 4. *Sub-category*-  one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history. 5. *User*: one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history. 
				
				The selection boxes / menu for the 5 attributes: Month, Account, Category, Subcategory and User should come first, folling a field showing the *total expenses* for the selected values in the 5 attributes (Month, Account, Category, Subcategory and User), followed by a table (up to 10 rows or so at a time, scrollable). all filters should have 'All' value to select all available values in the filters.

			1c. Page / tab 3: 'Visualizations': this tab will have 2 main parts - 
				1c1. a pie chart for the total expenses based on 4 filters - 
					1.*Month* - to be extracted from the main data table shown as a checkbox,we need to be able to select only one month value or the 'All' value to select all months (only 1 selection from the checkbox - no multi select for this chart) 
					2.*Account* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history 
					3.*Category* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history.
					4.*User* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history
					In this section, a pie chart of the total expenses across categories will be shown based on the selected values for the filters (Month, Account, Category, User)
					
				1c2. A line char showing the trend of the total expenses based on the filters selected: the x axis will have dates (day level) and y axis will have total expense (the sum of the 'amount' column in the data). x axis start data will be the first date in the data and last date will be the latest or most recent date in the data. The chart will be displayed based on the following filters:
					2.*Account* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history 
					3.*Category* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history.
					4.*User* - one of the predefined values according to the metadata, shown as a checkbox with multi selection with 'All' option for all values in history
					In this section, a lne chart of the total expenses across time (dates) will be shown based on the selected values for the filters (Month, Account, Category, User)
					
		2. All charts, reports and total expense values have to be refreshed when a new expense is added in 1a. page / tab 1: 'Add Expenses', or an expense is edited / deleted in 1b. page / tab 2: Reports.
		3. Make the pages nice looking and intuitive, with light yet attractive colours.
		4. Make the charts really nice with headers, axis names, legends etc. For the line chart make it a dotted line like '-o-o-o-'.
		5. Ensure the spacing and margins are nice so the graphs and charts are clearly visible.
		6. Is it possible to create a responsive UI in streamlit? if so, IMPORTANT: Prioritize responsive design. For the 1c. Page / tab 3: 'Visualizations' tab, show the graphs (pie chart and line chart mentioned in 1c.) side by side when in a wide screen, and column wise (Pie chart over the line chart) in a narrower (mobile) screen
		7. It is critical to ensure the data and fonts in the screen are legible, but they are not too big as that will be unattractive. Use a web-friendly font like segue or roboto for the frontend. (Font size around 12 should be fine, we need to experiment).
		8. CRITICAL IMPORTANCE: the options for editing / deleting an expense entry is not needed in this phase. Once an expense is added, no modification / deletion is needed. We will add this feature later.
			
	B. Data requirement: 
		1. We need to keep the app as simple as possible. We will use streamlit for the development, and python libraries for data visualization. The user needs to add expenses as mentioned in A.1.a, and edit / delete a selected expense as mentioned in A.1.b. So we can use sqlite3. Right now this app only needs to run in local system. But my wife and I need to access it from our mobiles throgh an url, so this small app needs to be deployed at a later phase using a free hosting like git. So when choosing csv vs sqlite3, keep the need to update databases and deployment scalability in mind.
		
		2. For now, use the uploaded csv file as a sample data to run the app and experiment with all features like add / delete expenses, chart generation etc.
		3. There is no need to store the charts anywhere at all unless they are absolutely necessary. If needed, give me simple way to periodically delete them and all unnecessary data. IMPORTANT: avoid chart saving if at all possible. Just show the charts.
		4. No need to store any history, snapshot etc, as long as we are able to see the reports, tables and charts,we are good. IMPORTANT: Store additional data only if they are absolutely necessary, else avoid, and use the main data file for all functions.
		5. As the user needs to manually enter date which needs to be stored in the database, and from there the month has to be extracted, ensure data validation to make sure there are no data type related issues anywhere. THey are very annoying.
		6. All 'amount' values will be in INR. Show INR in the frontend where appropriate (like column headers in reports but not inside cells).
		
	C. Development requirment:
		1. I will be using python in a conda environment which should already have most of the dependencies, but doesn't hurt to check ensure there are no version conflicts.
		2. I will use vscode in windows 10 with powershell as my default terminal, so don't suggest anything that is not compatible with windows powershell. If in doubt, try to take a pythonic approach.
		3. Keep the code simple and efficient, i am not a fan of huge and sprawling codebases. 
		4. Remember Phase 1: this phase, we will need to run it in our local machine, Phase 2: future phase: we will deploy the app and create a sharable link. So design and development of the app has to be with deployment in mind.
		5. Ensure there are no key errors when fetching the data and in the code by normalizing the column names to lower case and ensure the same variables are being used across the codebase.
		6. IMPORTANT: Remember, the subcategories are mapped to categories according to the metadata definition, sharing it specifically here for reference:
		
		categories = {
    "Investment": ["SIP", "Mutual Funds", "Stocks", "FD/RD"],
    "Rent": ["House Rent"],
    "Travel": ["Day Trip", "Vacation", "Commute", "Cab", "Train", "Flight", "Hotel/Stay", "Parking Fee"],
    "Restaurant": ["Dine-in", "Takeaway", "Food Delivery", "Snacks", "Cafe", "Drinks"],
    "Insurance Premium": ["Life Insurance", "ULIP", "Health Insurance", "Vehicle Insurance"],
    "Household": [
        "Electricity Bill", "Plumbing", "Electrical Repairs", "Appliance Repair", "Cleaning",
        "Pest Control", "Bike Maintenance", "Car Maintenance", 
        "Furniture", "Kitchen Tools", "Ironing", "Maid"
    ],
    "Connectivity": ["Airtel WiFi", "Jio Recharge", "Airtel Mobile", "Netflix", "Prime Video", "Disney+ Hotstar"],
    "Waste": ["Smoke", "Alcohol"],
    "Grocery": ["BigBasket", "Amazon", "Flipkart Grocery", "Zepto", "Local Store", "Other"],
    "Beauty": ["Nykaa", "Meesho", "Purplle", "Salon", "Makeup", "Skincare", "Salon"],
    "Shopping": ["Amazon", "Flipkart", "Meesho", "Nykaa", "Purple", "Lifestyle", "Max", "Myntra"],
    "Health": ["Doctor Visit", "Medicines", "Lab Test", "Health Checkup"],
    "Utilities": ["Electricity", "Water", "Gas Cylinder", "Maintenance", "Garbage Collection"],
    "Gifts & Donations": ["Family", "Friends", "Charity", "Temple"],
    "Entertainment": ["Movies", "Concerts", "Games"],
    "Education": ["Online Courses", "Books", "Workshops"]
}
	
Initially, all filters of all tabs should have the value 'All' selected whereever applicable. On selecting a category, only a selected set of subcategories based on the above mapping are to be shown in the dropdown / checkbox filters in all tabs whereever applicable.
		7. modularize the code, don't put everything in a huge main.py file to be run in streamlit.
		8. For sqlite3 db creation from csv, give python script with detailed explanation. Do I need to create the db by running a script (say create_db.py) or it will be automatically created when launching streamlit app? running my script makes sense as it is a one time activity, guide step by step with code accordingly.
FINAL INSTRUCTIONS:
	1.Read the above requirement carefully and go through the attched metada and sample data excel file.
	2. Tell me in detail what you understand. Clearly tell me where the requirement is ambiguous and you need to make assumptions. go ahead and make assumptions to run the code.  You need to have the necessary and sufficient information needed to complete the development.
	4. Suggest changes / additions to the requirements based on the following priority in descending order: 1. Error free 2. Simple 3. Prettier 4. Scalable (still with the same data model) for deployment (at phase 2, not now)
	5. Ensure that the code runs correctly
	6. Give me the code and detailed step by step guidance to create a streamlit app in my local conda environment based on above requirement.
			


I have shared with you the detailed requirement and instructions to build a streamlit app to manage my personal finances. Give me detailed step by step instructions along with clean, efficient, error free, modular codebase to implement the streamlit app. Whereever you need to make an assumption, go ahead with your judgement. Running the code successfully in local is the highest priority.

 2. CODE STRUCTURE TREE

app-personal-finance/
    combined_files.txt
    create_db.py
    create_file_data.py
    db_utils.py
    dummy_expenses.csv
    expenses.db
    expense_metadata.json
    folder_tree.txt
    generate_tree.py
    main.py
    requirements.txt
    styles.css
    style_utils.py
    reference/
        plotly_charts.py
        prompts.txt
    tabs/
        add_expense.py
        reports.py
        visuals.py

3. CODE FOR ALL .py FILES


# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\db_utils.py
# db_utils.py
import sqlite3
import pandas as pd
from uuid import uuid4

DB_NAME = "expenses.db"

def get_connection():
    return sqlite3.connect(DB_NAME, check_same_thread=False)

def fetch_all_expenses():
    conn = get_connection()
    df = pd.read_sql("SELECT * FROM expenses", conn)
    conn.close()
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    return df

def insert_expense(data):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
    INSERT INTO expenses (id, date, account, category, sub_category, type, user, amount)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
""", (str(uuid4()), data['date'], data['account'], data['category'], data['sub_category'],
      data['type'], data['user'], data['amount']))
    conn.commit()
    conn.close()

def fetch_last_expenses(n=10):
    conn = get_connection()
    df = pd.read_sql(f"SELECT * FROM expenses ORDER BY date DESC LIMIT {n}", conn)
    conn.close()
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    return df

# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\main.py
# main.py
import streamlit as st
from tabs import add_expense, reports, visuals
from style_utils import load_css 

st.set_page_config(
    layout="wide", 
    page_title="Personal Expense Tracker", 
    page_icon="💰"
)

# Load CSS styles
load_css()

# Navigation in sidebar
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to", 
    ["Add Expenses", "Reports", "Visualizations"],
    label_visibility="collapsed"  # Cleaner look
)

# Render selected page
if page == "Add Expenses":
    add_expense.render()
elif page == "Reports":
    reports.render()
elif page == "Visualizations":
    visuals.render()

# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\style_utils.py
# style_utils.py
import streamlit as st

def load_css(file_path: str = "styles.css"):
    with open(file_path, "r") as f:
        css = f.read()
        st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)


# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\tabs\add_expense.py
# tabs/add_expense.py
import streamlit as st
import pandas as pd
from db_utils import insert_expense, fetch_last_expenses
import json

def load_metadata():
    with open("expense_metadata.json", "r") as f:
        return json.load(f)

def render():
    metadata = load_metadata()
    st.subheader("Add New Expense")

    # --------------------
    # Step 1: Select date before form (UX improvement)
    # --------------------
    date = st.date_input("Date of Expense", help="Format: YYYY-MM-DD")

    # --------------------
    # Step 2: Select category before form to drive sub-category
    # --------------------
    category = st.selectbox("Category", list(metadata["categories"].keys()))
    available_subcategories = metadata["categories"][category]

    # --------------------
    # Step 3: Expense form
    # --------------------
    with st.form("expense_form"):
        col1, col2 = st.columns(2)

        with col1:
            account = st.selectbox("Account", metadata["Account"])
            sub_category = st.selectbox("Sub-category", available_subcategories)

        with col2:
            type_ = st.text_input("Type (≤ 50 chars)", max_chars=50)
            user = metadata["User"][account]
            amount = st.number_input("Amount (INR)", min_value=0.0, format="%.2f")

        submitted = st.form_submit_button("Add Expense")
        if submitted:
            if not type_:
                st.warning("Please enter a valid 'Type' for the expense.")
            elif amount == 0.0:
                st.warning("Amount cannot be zero.")
            elif sub_category not in metadata["categories"][category]:
                st.error("Invalid sub-category for selected category.")
            else:
                insert_expense({
                    "date": date.strftime("%Y-%m-%d"),
                    "account": account,
                    "category": category,
                    "sub_category": sub_category,
                    "type": type_,
                    "user": user,
                    "amount": amount
                })
                st.success("✅ Expense added successfully!")

    # --------------------
    # Step 4: Show recent entries
    # --------------------
    st.markdown("---")
    st.subheader("Last 10 Expenses")
    df = fetch_last_expenses(10)
   
   # Rename columns
    display_df = df.drop(columns=["id"]).rename(columns={
        "date": "Date",
        "account": "Account",
        "category": "Category",
        "sub_category": "Sub Category",
        "type": "Type",
        "user": "User",
        "amount": "Amount"
    })

    st.dataframe(
        display_df.style.format({'Amount': '₹{:.2f}'}),
        use_container_width=True,
        height=240,
        hide_index=True
    )

# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\tabs\reports.py
import streamlit as st
import pandas as pd
from db_utils import fetch_all_expenses
import json

def load_metadata():
    with open("expense_metadata.json", "r") as f:
        return json.load(f)

def render():
    metadata = load_metadata()
    df = fetch_all_expenses()
    df['month'] = df['date'].dt.strftime('%Y-%m')

    st.subheader("Expense Report")

    with st.expander("Filter Options", expanded=True):
        col1, col2, col3 = st.columns(3)
        with col1:
            months = st.multiselect("Month", ["All"] + sorted(df['month'].unique()), default=["All"])
            accounts = st.multiselect("Account", ["All"] + metadata["Account"], default=["All"])
        with col2:
            categories = st.multiselect("Category", ["All"] + list(metadata["categories"].keys()), default=["All"])
            users = st.multiselect("User", ["All", "Anirban", "Puspita"], default=["All"])
        with col3:
            filtered_cats = categories if "All" not in categories else list(metadata["categories"].keys())
            sub_cats = sum([metadata["categories"][cat] for cat in filtered_cats], [])
            subcategories = st.selectbox("Sub-category", ["All"] + sorted(set(sub_cats)))

    # Apply filters
    if "All" not in months: df = df[df['month'].isin(months)]
    if "All" not in accounts: df = df[df['account'].isin(accounts)]
    if "All" not in categories: df = df[df['category'].isin(categories)]
    if subcategories != "All": df = df[df['sub_category'] == subcategories]
    if "All" not in users: df = df[df['user'].isin(users)]

    total = df['amount'].sum()
    st.markdown(f"### Total Expense: ₹{total:,.2f}")
    
    # Rename columns
    display_df = df.drop(columns=["id", "month"]).rename(columns={
        "date": "Date",
        "account": "Account",
        "category": "Category",
        "sub_category": "Sub Category",
        "type": "Type",
        "user": "User",
        "amount": "Amount"
    })

    st.dataframe(
        display_df.sort_values("Date", ascending=False).style.format({'Amount': '₹{:.2f}'}),
        use_container_width=True,
        height=400,
        hide_index=True
    )


# Contents of E:\Code\Projects\App-PersonalFinance\app-personal-finance\tabs\visuals.py
# tabs/visuals.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from db_utils import fetch_all_expenses
import json

def load_metadata():
    with open("expense_metadata.json", "r") as f:
        return json.load(f)

def render():
    metadata = load_metadata()
    df = fetch_all_expenses()
    df['month'] = df['date'].dt.strftime('%Y-%m')

    st.subheader("Visualizations")

    # ----- PIE CHART -----
    st.markdown("### Category-wise Expense Distribution (Pie Chart)")
    with st.expander("Pie Chart Filters", expanded=True):
        pie_month = st.selectbox(
            "Month", ["All"] + sorted(df['month'].unique()), 
            index=0, 
            key="pie_month_select"
        )
        accounts = st.multiselect(
            "Account", ["All"] + metadata["Account"], 
            default=["All"], 
            key="pie_account_select"
        )
        categories = st.multiselect(
            "Category", ["All"] + list(metadata["categories"].keys()), 
            default=["All"], 
            key="pie_category_select"
        )
        users = st.multiselect(
            "User", ["All", "Anirban", "Puspita"], 
            default=["All"], 
            key="pie_user_select"
        )

    # Filter data for pie chart
    pie_df = df.copy()
    if pie_month != "All": pie_df = pie_df[pie_df['month'] == pie_month]
    if "All" not in accounts: pie_df = pie_df[pie_df['account'].isin(accounts)]
    if "All" not in categories: pie_df = pie_df[pie_df['category'].isin(categories)]
    if "All" not in users: pie_df = pie_df[pie_df['user'].isin(users)]

    pie_data = pie_df.groupby('category')['amount'].sum().reset_index()
    fig1 = px.pie(pie_data, values='amount', names='category', title="Expenses by Category", hole=0.4)
    st.plotly_chart(fig1, use_container_width=True)

    # ----- LINE CHART -----
    st.markdown("### Daily Expense Trend (Line Chart)")
    with st.expander("Line Chart Filters", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            accounts_line = st.multiselect(
                "Account", ["All"] + metadata["Account"], 
                default=["All"], 
                key="line_account_select"
            )
            categories_line = st.multiselect(
                "Category", ["All"] + list(metadata["categories"].keys()), 
                default=["All"], 
                key="line_category_select"
            )
        with col2:
            users_line = st.multiselect(
                "User", ["All", "Anirban", "Puspita"], 
                default=["All"], 
                key="line_user_select"
            )
            chart_mode = st.radio(
                "Chart Mode",
                ["Daily", "Cumulative", "Both"],
                index=0,
                key="chart_mode_select"
            )

    # Filter data for line chart
    line_df = df.copy()
    if "All" not in accounts_line: line_df = line_df[line_df['account'].isin(accounts_line)]
    if "All" not in categories_line: line_df = line_df[line_df['category'].isin(categories_line)]
    if "All" not in users_line: line_df = line_df[line_df['user'].isin(users_line)]

    # Prepare data
    daily_data = line_df.groupby('date')['amount'].sum().reset_index().sort_values('date')
    cumulative_data = daily_data.copy()
    cumulative_data['cumulative_amount'] = cumulative_data['amount'].cumsum()

    # Create figure
    fig2 = go.Figure()
    
    if chart_mode in ["Daily", "Both"]:
        fig2.add_trace(go.Scatter(
            x=daily_data['date'],
            y=daily_data['amount'],
            name='Daily Expenses',
            mode='lines+markers',
            line=dict(color='#1f77b4', width=2)
        ))
    
    if chart_mode in ["Cumulative", "Both"]:
        fig2.add_trace(go.Scatter(
            x=cumulative_data['date'],
            y=cumulative_data['cumulative_amount'],
            name='Cumulative Expenses',
            mode='lines+markers',
            line=dict(color='#ff7f0e', width=2, dash='dot')
        ))
    
    fig2.update_layout(
        title='Expense Trends',
        xaxis_title='Date',
        yaxis_title='INR',
        legend_title='Metric',
        hovermode="x unified"
    )
    st.plotly_chart(fig2, use_container_width=True)



















































"""

File: requirement_v2_ds_assistant.txt
Location: reference\requirement_v2_ds_assistant.txt
Summary: The file outlines the development of a chatbot for querying data and providing insights related to exploratory data analysis (EDA) and data science. It will handle advanced statistical and machine learning questions using an SQLite database. The chatbot will remember conversation history within a session but not across sessions.
Code: """
PHASE 2: This is the CURRENT REQUIREMENT.

PUBLIC GIT REPO LINK: https://github.com/AnirbanDattaTech/App-Personal-Finance.git

We will now start the development for a chatbot that can query the data and answer data insights, eda and data science related questions, to cover all areas a person might be interested in insight based on your understanding of the data, metadata and the project structure (what we are trying to do here). So we will keep all questions that require advanced statistical knowledge like probability and distributions, predictive modelling, and ML related questions (classification, regression, forecasting etc) in scope based on the data (expenses.db - sqlite3 file) and metadata.

Here 

REQUIREMENT-
1. DATA STRUCTURE AND HISTORY REQUIREMENT-
	1.1. The chatbot needs to remember the conversation history for a session for subsequent follow up questions, but no long term history needs to be saved. So each time the app is opened, a new conversation can be started where the context can be managed for the duraton of the session only.
	1.2. Currently the project has only 1 data file, the sqlite db table. Consider, based on the requirment, if any additional database needs to be created (such as the metadata) where additional chatbot related data to be stored. Modularize the codebase, creating a new folder for storing all the data files if needed, accordingly. Remember, modularity and simplicity are key requirments. The existing code may need to change to update the location references.
	1.3. I think a metada file with detailed description of all tables and all columns, including their data type, detailed description, unique values(where applicable), special constraints (like rent - once a month only, investment - once a month only) and other relevant information are required. If you agree, generate a metadata_detailed.json file with this info. Modularize the codebase, creating a new folder for storing all the metadata json files if needed, accordingly. Remember, modularity and simplicity are key requirments. The existing code may need to change to update the location references.
	
2. DESIGN REQUIREMENT-
	2.1. The chatbot needs to be in a fourth tab called 'Assistant' after visualization.
	2.2. In the assistant tab, there has to be 2 parts:
		2.2.1. CHAT WINDOW / SECTION - This is where my wife and i will interact with the chat bot through a chat window. there needs to be a simple pre-generated system messge: 'Greetings! What can I help you with?' Followed by a text box where i or my wife (not at the same time) can ask a simple question like 'what is my total spend for april?' and after the chatbot answers, ask 'ok, out of this how much did i spend on resturants?'. The conversation needs to be multiturn so state and session management is important for a single session. For toy example: AI: 'Greetings! What can I help you with?' HUMAN: 'Hey! What was my total spend on the month of march?' AI: 'Sure! Your total spend was inr 25,000.' HUMAN: 'Great! How much of that i spent on household?' AI: 'Out of total spend of inr 25000, you have spent inr 5000 on household.'
		
		2.2.2. VISUALIZATION WINDOW / SECTION - this is a section where, based on the question asked, the ai bot needs to show a relevant visualization. So for example in the previous example sequence: {AI: 'Greetings! What can I help you with?' HUMAN: 'Hey! What was my total spend on the month of march?' AI: 'Sure! Your total spend was inr 25,000.' HUMAN: 'Great! How much of that i spent on household?' AI: 'Out of total spend of inr 25000, you have spent inr 5000 on household.'} - the visualization can be a bar chart showing the spend across each category (because the human asked for the spend for a specific category) for the requested month (march in this example). 
	
3. DEVELOPMENT REQUIREMENT - 
	3.1. We will build a multi agent architecture using openai, langchain and langgraph and langsmith. I will upload the requirement file, pls ensure we have all the necessary dependencies to get started.
	3.2. CRITICAL: The key idea here is to explore autonomous agents and how they collaborate intelligently with a superagent to generate the answer and relevant visualization. If it is a deterministic workflow going from one node to next using prebuilt set of rules, there is no point in building complex agent frameworks. Explore how autonomous agents can be used to fulfill the requirement. Details on the agents follow:
	3.2. I think in the agent architecture, We need the following agents:
		3.2.1 SUPER AGENT (SA) - This is the super agent that interacts with the user and coordinates with the sub-agents.
			REQUIREMENTS - 
				3.2.1.1 Greet the user and get the user question
				3.2.1.2 Classify the question in one of 3 categories -  
					1. CATEGORY 1: SIMPLE - Ex. 1. Question: "What was my total spend last month across categories?" Ex 2. Question: "Who spent more on household last february - me or my wife?" Ex 3. Question: "Who bought that Mixer grinder last week? (refer to spend category-spend subcategory-spend type (free text description), refer data model, schema and metadata)" - simple query, hand over to the DATA ANALYST sub agent for answer
					2. CATEGORY 2: ADVANCED (ML BASED) - 
						Ex 1. Question: "What is the forecasted total combined spending (Anirban + Puspita) across all categories for the next calendar month?" - needs advanced (ml based) logic - hand over to DATA SCIENTIST sub agent after getting the required data from DATA ANALYST agent. 
						Ex 2. Question: ""Estimate the Amount Anirban is likely to spend on a single 'Shopping' transaction at 'Amazon' or 'Flipkart', considering the platform (Sub-category), the month (for potential sales events), and the day of the week?" - needs advanced (ml based) logic - hand over to DATA SCIENTIST sub agent for answer.
						
					3. CATEGORY 3: NOT RELEVANT - Irrelevant for the context of the app (Ex. "How is the weather today?") or out of current scope of the application: (Ex. "what was my totay spend on 2015?" when the data is available only from 2024.) 
				
				A detailed prompt(s) with the best prompting techniques (few shot, CoT) needs to be developed for SUPER AGENT NODES in langgraph super agent graph.
				3.2.1.3 DISAMBIGUATION: Ask clarification questions to correctly identify the question into one of the 3 question categories (simple / advanced (ml based) / not relevant) to trigger the correct agent workflow (SIMPLE > DAA + DVA, ADVANCED > DAA + DSA + DVA, DVA is not necessary for each question - for questions with extremely simple single outputs (EX: "My total spend last month") a single number is sufficient.)
				3.2.1.3 Coordinate with the 'DATA ANALYST' sub agent to get the response to the simple, data related questions in a tabular format
				3.2.1.4 Coordinate with the 'DATA SCIENTIST' sub agent to get the response to advanced, ml based questions (classified as one of the 5 predefined ml question types by the DATA SCIENTIST sub agent) in tabular format, along with model performance summary in a tabular format
				3.2.1.5 Coordinate with the 'DATA VISUALIZATION' agent to get the relevant graph /chart to the data related question - evaluate if chart response is needed for simple questions. If chart generation is not needed based on the DAA response, don't call the chart agent. For advanced (ml type) questions handled by the DSA, charts will always be needed, and DVA will always be called.
				3.2.1.6 Show the answer and relevant chart in the streamlit frontend
				3.2.1.7  Handle follow-up sequential questions based on previous questions
				3.2.1.8 Gently guide the user to ask a relevant question if the user asks an questions irrelevant to the solution such as 'What is the capital of Vietnam?' (handle non-relevant question, terminate after 2 tries)
				3.2.1.9 ADD ANY OTHER RELEVANT STEP HERE BASED ON YOUR UNDERSTANDING AND RECOMMENDATION
				
		3.2.2 DATA ANALYST SUB AGENT (DAA) - This sub-agent is in charge of getting the answer to the data-related user question. A detailed prompt(s) with the best prompting techniques (few shot, CoT) needs to be developed for this AGENT NODES. Do so.
			REQUIREMENTS - 
				1.2.1 Get the question from the SUPER AGENT or DATA SCIENTIST sub agent
				1.2.2 ENTITY EXTRACTION: Extract entities from the question (Date,Account,Category,Sub-category,Type,User,Amount)
				1.2.3 SQL GENERATION: Generate an sql query based on the natural langugage question from super agent (SA) for simple cases and Data Science sub-agent (DSA) for advanced cases
					STEPS to generate SQL QUERY:
						1.2.3.1 SIMILARITY SEARCH:do a similarity search between the entities extracted in the 'ENTITY EXTRACTION' step / NODE above (1.2.2) and the METADATA for tables and columns to find the relevant tables and columns to use for the SQL query
						1.2.3.2 SQL QUERY GENERATION: generate an sql query based on the similar tables / columns found in previous step (SIMILARITY SEARCH)
				1.2.4 SQL VALIDATION: Execute the sql on the expenses.db to get the required results
				1.2.4 SQL EXECUTION: Execute the sql on the expenses.db to get the required results
				1.1.5 ADD ANY OTHER RELEVANT STEP HERE BASED ON YOUR UNDERSTANDING AND RECOMMENDATION
				1.2.6 update the agentstate and Pass the result to the SUPER AGENT and/or the DATA SCIENTIST sub agent 
		
		3.2.3 DATA SCIENTIST SUB AGENT (DSA) - This sub-agent is in charge of answering the more advanced data science related questions. A detailed prompt(s) with the best prompting techniques (few shot, CoT) needs to be developed for this AGENT NODES. Do so.
			REQUIREMENTS - 
				3.2.3.1 Get the question from the SUPER AGENT
				
				3.2.3.2 Classify the advanced question into one of 5 predefined categories: Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering. See below examples of each advanced question type:
					Ex 1. Question: "Can you predict my next week total spend? I have already paid rent, but investment ulip etc are pending (FORECASTING - based on weekly spend from expenses.db, consider fixed monthly payments like rent, investment. Predict future values (often numerical aggregates) of a variable that evolves sequentially over time. Focuses explicitly on the temporal dependencies – trend, seasonality, and autocorrelation (how past values influence future values) – inherent in the time series data itself. The primary input is the historical sequence.)" 
					Ex 2. Question: "Can you tell me the high expense uber rides in the last month? (CLASSIFICATION - classify category: Travel,  subcategory: Cab, spend type: Uber - into high spend and low spend - return high spend rides for last month. Assign an instance (e.g., a transaction, a day) to one of several predefined, discrete classes based on its features.We are predicting membership in known, predefined categories (like Essential/Discretionary). We are not defining the segments themselves (Segmentation) or discovering unknown groups (Clustering).)" 
					Ex 3. Question: "Estimate the Amount Anirban is likely to spend on a single 'Shopping' transaction at 'Amazon' or 'Flipkart', considering the platform (Sub-category), the month (for potential sales events), and the day of the week?" (REGRESSION - Predicts the value of one shopping instance. The platform (Amazon vs. Flipkart), time of year (sales), and whether it's a weekend might influence the basket size more directly than the amount spent on the previous online order. This models the characteristics-to-amount relationship for a specific event. Focuses on the relationship between features of a single instance and its numerical outcome, rather than predicting the next value in a sequence based primarily on past values and time patterns)
					Ex 4. Question: "Analyze the 'High-Frequency Spending' segment (transactions under ₹300). What are the dominant categories, sub-categories, and users within this segment? Does its total monthly value change significantly?" (SEGMENTATION - Divide data into meaningful, predefined groups based on rules or shared characteristics, and then analyze and compare these segments. We define a segment based on a rule (Amount < 300). The analysis then describes the composition (categories, users) and tracks the aggregate behavior (total value over time) of this specific, predefined segment.)
					Ex 5. Question: "Cluster our days based on the combination of total amount spent and the number of transactions that day. What kind of 'daily activity' clusters emerge (e.g., 'Low Spend/Low Activity', 'High Spend/Low Activity (single big purchase?)', 'Moderate Spend/High Activity (many small purchases?)')?" (UNSUPERVISED CLUSTERING - Allow an algorithm to automatically discover natural groupings (clusters) within the data based on similarity across features, without using predefined labels.We don't predefine what makes a 'type' of day. We feed features (total daily amount, total daily transaction count) into a clustering algorithm (like K-Means) and let it find groups of days that are mathematically similar based on these two dimensions. We then interpret the resulting clusters.)
					
				3.2.3.3 Frame a question in natural language along with specific mention of the columns, data slices and logic (JOIN, GROUP BY etc) and send it to the DAA to get the relevant data
				3.2.3.4 Get the SQL query execution results from the DAA
				3.2.3.5 Trigger a pre-defined ml workflow based on the advanced question classification: Regression, Forecasting, Classification, Segmentation, Unsupervised Clustering
				3.2.3.6 Generate model output for the required data mentioned in user question in a tabular format based on advanced question classification
				3.2.3.7 Generate model summary and other relevant information for the trained model based on the required data mentioned in user question in a tabular format, based on advanced question classification
				3.2.3.8 ADD ANY OTHER RELEVANT STEP HERE BASED ON YOUR UNDERSTANDING AND RECOMMENDATION
				3.2.3.9 update the agentstate and Pass the result to the SUPER AGENT
				
		3.2.4. DATA VISUALIZATION SUB AGENT (DVA) -  This sub-agent is responsible for creating a visualization in the 'Chart' section of the 'Assistant' tab in the streamlit UI based on the answer to the user queries generated by the DATA ANALYST SUB AGENT.A detailed prompt(s) with the best prompting techniques (few shot, CoT) needs to be developed for this AGENT NODES. Do so.
			REQUIREMENTS -
				3.2.4.1 Get the user query and the result of the sql query generated by the DATA ANALYST SUB AGENT.
				3.2.4.2 Select one of the predefined set of visualizations based on the natural language user query and the sql generated response. The categories are: {Vertical bar chart, Horizontal bar chart, Scatter plot, Histogram, Line chart, Bubble chart, Pie chart}. One of these chart types MUST be selected. No chart types other than these are to be selected.
				3.2.4.3 Get the x axis values, y axis values and other required values from the expenses.db and the sql generated response (basically get all the data required to generate the chart)
				3.2.4.4 Generate the chart with all the bells and whistles (heading, axis names, legend ticks etc) in the 'Chart' section of the 'Assistant' tab in the streamlit UI
				3.2.4.5 ADD ANY OTHER RELEVANT STEP HERE BASED ON YOUR UNDERSTANDING AND RECOMMENDATION
				3.2.4.6 update the agentstate and Pass the result to the SUPER AGENT

		3.2.5. The above multi-agent architecture is a recommendation. CRITICAL: use your judgement to come up with the multi-agent architecture based on this recommendations. *CRITICAL IMPORTANT*:
			3.2.5.1 Adhere to the business requirement: multi-turn conversation flow, chart generation for each question as appropriate, handling non-relevant or out of scope queries
			3.2.5.2 Implement autonomous agents using above as a references
			3.2.5.3 Refer to these specific online documents for multi-agent flow in Langgraph:
				- https://langchain-ai.github.io/langgraph/how-tos/multi-agent-multi-turn-convo/
				- https://github.com/langchain-ai/langgraph/tree/main/docs/docs/tutorials/multi_agent

		3.2.6 METADATA REQUIREMENT: The metadata for the tables and columns need to be created so that - 1. They are as helpful as possible for the LLM to find the similar table and columns from SIMILARITY SEARCH (DAA step: 1.2.3.1 above) and generate the sql query (DAA step: 1.2.3.2 above), and 2. help LLM avoid ambiguity in selecting tables and columns as much as possible (Examples: 1. "What are my main expenses this month other than rent and insurance?" - The 'main expenses' can be interpreted as expenses across categories, subcategories or expense types. So the 'category' column metadata needs to mention: This column should be used for general questions on overall expense types / patterns across a historical period (last month / last week) etc. 2. "what was my spend on my last electricity bill?" - category "household" has subcategory "Electricity Bill", and the category "Utilities" has subcategory "Electricity". So the "Electricity Bill" subcategory metadata description needs to clearly mention: "Use this column for any questions regarding electricity bill.")
	
	3.3. Only 1 user at a time, no need to worry about concurrent users.
	3.4. focus on modularity and simplicity of the entire codebase based on this new requirement.
	3.5 I want to learn the proper git development workflow with branches and everything, so pls include that in all your guidelines
	3.6 I want to use langsmith for tracing and looking at agent workflows, so include that accordingly
	3.5. carefully consider what impact it will have on the existing data/ code and modify accordingly. Existing functioalities and UI MUST remain as is.
	3.6 These are just *INDICATIVE* steps, understand the requirement and ask as many clarification questions as needed. I will also share with you the updated code content so you are upto speed.
	3.7 please carefully consider the requirment, focusing on error-free running, simlicity, robustness and scalability, and suggest changes to approach, additions, enhancements and recommedations.
	3.8 Finally, suggest a detailed step by step approach to implement the agentic ai chatbot according to requirement. No code necessary, just discuss the approach with me before development.
"""

File: test_llm_gemini.py
Location: reference\test_llm_gemini.py
Summary: The script tests LangGraph and Gemini integration, listing available AI models and loading sample data from a CSV file. It sets up a LangGraph workflow with nodes for fetching user questions and generating responses using Google Generative AI models. The script logs configuration steps and handles errors throughout the process.
Code: """
# reference/test_llm_gemini.py
"""
Basic test script using LangGraph and Gemini. Includes model listing.
"""

import pandas as pd
import os
import logging
from pathlib import Path
from dotenv import load_dotenv
from typing import Dict, TypedDict, Annotated
import operator

# --- ✅ Import Google SDK ---
import google.generativeai as genai

from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import StateGraph, END

# --- Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Load Environment Variables (API Key) ---
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
ENV_PATH = PROJECT_ROOT / ".env"

if ENV_PATH.exists(): load_dotenv(dotenv_path=ENV_PATH); logging.info(".env file loaded.")
else: logging.warning(f".env file not found at {ENV_PATH}.")

# --- Configure API Key and Check ---
api_key = os.getenv("GOOGLE_API_KEY")
if not api_key:
    logging.error("GOOGLE_API_KEY not found. Exiting.")
    exit()
else:
    try:
        # --- ✅ Configure the SDK directly ---
        genai.configure(api_key=api_key)
        logging.info("GOOGLE_API_KEY found and Google AI SDK configured.")
    except Exception as e:
        logging.error(f"Failed to configure Google AI SDK: {e}", exc_info=True)
        exit()

# --- ✅ List Available Models ---
print("\n--- Available Google Generative AI Models (for generateContent) ---")
print("-" * 60)
models_available_for_chat = []
try:
    models_listed = False
    for model in genai.list_models():
        if 'generateContent' in model.supported_generation_methods:
            models_listed = True
            print(f"- {model.name} ({model.display_name})")
            models_available_for_chat.append(model.name) # Store usable model names

    if not models_listed:
        print("No models supporting 'generateContent' found for your API key.")
except Exception as e:
    logging.error(f"Failed to list models: {e}", exc_info=True)
    print(f"\nError: Could not retrieve model list.")
print("-" * 60)
# --- End Model Listing ---


# --- Load Sample Data ---
DATA_FILE = PROJECT_ROOT / "data/expenses.csv"
df = pd.DataFrame()
df_sample = "" # Initialize

try:
    if DATA_FILE.exists():
        df = pd.read_csv(DATA_FILE)
        df_sample = df[['date', 'category', 'sub_category', 'user', 'amount']].head().to_markdown(index=False)
        logging.info(f"Loaded data sample from {DATA_FILE}")
    else:
        logging.error(f"Data file not found at {DATA_FILE}. Cannot proceed with LLM test.")
        # Don't exit immediately, maybe user just wanted to list models
except Exception as e:
    logging.error(f"Error loading data file {DATA_FILE}: {e}", exc_info=True)
    # Don't exit immediately

# --- Define LangGraph State ---
class SimpleAgentState(TypedDict):
    question: str
    data_summary: str
    llm_response: str

# --- Define Graph Nodes ---
def get_user_question(state: SimpleAgentState) -> Dict:
    logging.info("Node: get_user_question")
    # ... (node logic remains the same) ...
    return {}

def call_gemini(state: SimpleAgentState) -> Dict:
    logging.info("Node: call_gemini")
    question = state.get('question', '')
    data_summary = state.get('data_summary', '')

    if not question: return {"llm_response": "Error: Question missing."}
    if not data_summary: logging.warning("Data summary is missing.")

    # --- ✅ Select a model (using the one user specified or default) ---
    # model_to_use = "models/gemini-1.5-flash-latest" # Or use the name from .env / config
    # model_to_use = "models/gemini-pro" # Example alternative
    # Let's stick to the user's current choice for the test run:
    model_to_use = "gemini-1.5-flash" # LangChain often handles the 'models/' prefix
    # model_to_use = "gemini-2.0-flash-thinking-exp"

    # Check if the chosen model is in the list of available ones (optional sanity check)
    full_model_name_check = f"models/{model_to_use}" # Check with prefix
    if models_available_for_chat and full_model_name_check not in models_available_for_chat:
         logging.warning(f"Model '{model_to_use}' (as {full_model_name_check}) was not found in the list of models supporting 'generateContent'. LangChain might still work or might default.")

    try:
        # Use the specific model chosen for the test
        llm = ChatGoogleGenerativeAI(model=model_to_use)
        logging.info(f"Initialized LangChain Gemini model: {llm.model}")
    except Exception as e:
        logging.error(f"Failed to initialize ChatGoogleGenerativeAI model: {e}", exc_info=True)
        return {"llm_response": f"Error: Could not initialize LangChain LLM - {e}"}

    prompt = f"""
You are a helpful assistant analyzing personal expense data.
Answer the following question based *only* on the provided data summary.

Data Summary (First 5 Rows):
{data_summary}

Question: {question}

Answer:
"""
    logging.info(f"Sending prompt to {model_to_use}...")
    try:
        response = llm.invoke(prompt)
        logging.info(f"Received response from {model_to_use}.")
        llm_response_content = response.content if hasattr(response, 'content') else str(response)
        return {"llm_response": llm_response_content}
    except Exception as e:
        logging.error(f"Error during LLM call with {model_to_use}: {e}", exc_info=True)
        return {"llm_response": f"Error: Failed to get response from LLM - {e}"}

# --- Define Graph ---
workflow = StateGraph(SimpleAgentState)
workflow.add_node("fetch_question", get_user_question)
workflow.add_node("generate_answer", call_gemini)
workflow.set_entry_point("fetch_question")
workflow.add_edge("fetch_question", "generate_answer")
workflow.add_edge("generate_answer", END)
app = workflow.compile()
logging.info("LangGraph compiled.")

# --- Run the Test ---
if __name__ == "__main__":
    print("\n" + "-" * 30)
    print("--- Basic LangGraph Gemini Test ---")
    print("-" * 30)

    # Only proceed if data was loaded successfully for the test part
    if df_sample:
        test_question = "List the categories present in the sample data."
        print(f"Test Question: {test_question}")
        initial_state: SimpleAgentState = {
            "question": test_question,
            "data_summary": df_sample,
            "llm_response": ""
        }
        print("\nInvoking LangGraph...")
        try:
            final_state = app.invoke(initial_state)
            print("\n--- Final LLM Response ---")
            print(final_state.get("llm_response", "No response generated."))
        except Exception as e:
            print(f"\nError invoking LangGraph: {e}")
            logging.error("Error during graph invocation", exc_info=True)
    else:
        print("\nSkipping LangGraph invocation as data sample failed to load.")

    print("-" * 30)
"""

File: test_llm_openai.py
Location: reference\test_llm_openai.py
Summary: The file `test_llm_openai.py` is a script to test the OpenAI API connection and list available models. It sets up logging, loads the OpenAI API key from environment variables, initializes the OpenAI client, and attempts to fetch and print the list of available models, handling errors appropriately.
Code: """
# FILE: test_llm_openai.py
# PURPOSE: Test OpenAI API connection and list available models.

import os
from openai import OpenAI
from dotenv import load_dotenv
import logging

# --- Configuration ---
# Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def list_openai_models():
    """Connects to OpenAI using the API key from environment variables
    and lists the available models.
    """
    # --- Load API Key ---
    # Load environment variables from a .env file if it exists
    load_dotenv()
    logging.info("Attempting to load environment variables from .env file.")

    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        logging.error("FATAL: OPENAI_API_KEY environment variable not set.")
        print("\nError: OPENAI_API_KEY not found.")
        print("Please ensure you have the key set in your environment variables or in a .env file.")
        return # Stop execution if key is missing

    logging.info("OPENAI_API_KEY found.")

    # --- Initialize Client ---
    try:
        client = OpenAI(api_key=api_key)
        logging.info("OpenAI client initialized successfully.")
    except Exception as e:
        logging.error(f"Failed to initialize OpenAI client: {e}", exc_info=True)
        print(f"\nError initializing OpenAI client: {e}")
        return # Stop execution if client fails

    # --- Fetch and List Models ---
    try:
        logging.info("Attempting to fetch the list of available models...")
        models_response = client.models.list()
        logging.info(f"Successfully received model list response.") # Type: {type(models_response)}

        print("\nAvailable OpenAI Models:")
        print("-" * 25)

        count = 0
        # The response object is iterable (often openai.pagination.SyncPage)
        for model in models_response:
            # Check if the model object has an 'id' attribute (standard way to get model name)
            if hasattr(model, 'id'):
                print(f"- {model.id}")
                count += 1
            else:
                # Log if an unexpected model format is encountered
                logging.warning(f"Encountered model data without an 'id': {model}")

        print("-" * 25)
        logging.info(f"Successfully listed {count} models.")
        if count == 0:
             print("No models were listed. Check API key permissions or connection.")

    except Exception as e:
        logging.error(f"An error occurred while fetching or listing models: {e}", exc_info=True)
        print(f"\nAn error occurred while fetching models: {e}")
        print("Please check your API key, network connection, and OpenAI service status.")

# --- Main Execution ---
if __name__ == "__main__":
    print("--- Testing OpenAI Model Listing ---")
    list_openai_models()
    print("\n--- Test Complete ---")
"""

File: db_utils.py
Location: streamlit\db_utils.py
Summary: This Python script provides utility functions for managing an SQLite database of expenses. It includes functions to establish a database connection, fetch all expenses, fetch expenses by ID, insert new expenses, update existing expenses, delete expenses, and fetch the last N expenses. Logging is set up for error and info reporting.
Code: """
# streamlit/db_utils.py
import sqlite3
import pandas as pd
from uuid import uuid4
from pathlib import Path # Use pathlib
import logging
from typing import Optional, Dict, Any, List

# Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- ✅ Define DB Path relative to the project root ---
# This assumes db_utils.py is in 'app-personal-finance/streamlit/'
# Path(__file__) gives the path to db_utils.py
# .parent gives 'app-personal-finance/streamlit/'
# .parent gives 'app-personal-finance/'
# Then we navigate to 'data/expenses.db'
PROJECT_ROOT = Path(__file__).parent.parent
DB_PATH = PROJECT_ROOT / "data" / "expenses.db"

# --- Optional: Check if DB exists and log ---
if not DB_PATH.exists():
    logging.error(f"DATABASE NOT FOUND at expected location: {DB_PATH.resolve()}")
    # Indicate the expected path based on calculation
    logging.error(f"(Calculated from: {__file__})")
    # You might want to raise an error or handle this case differently in a real app
else:
    # Print statement removed as logging is now configured
    logging.info(f"Using database at: {DB_PATH.resolve()}")
# ---

def get_connection() -> Optional[sqlite3.Connection]:
    """
    Establishes a connection to the SQLite database.

    Returns:
        Optional[sqlite3.Connection]: A connection object or None if connection fails.
    """
    try:
        # Ensure the path is passed as a string or Path object
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.row_factory = sqlite3.Row  # Return rows as dictionary-like objects
        logging.debug(f"Database connection established to {DB_PATH.resolve()}")
        return conn
    except sqlite3.Error as e:
        # Use logging correctly
        logging.error(f"Database connection error to {DB_PATH.resolve()}: {e}", exc_info=True)
        return None

def fetch_all_expenses() -> pd.DataFrame:
    """Fetches all expenses, ordered by date descending."""
    conn = get_connection()
    if conn is None:
        logging.error("Cannot fetch expenses: Database connection failed.")
        return pd.DataFrame()
    try:
        # Explicitly select columns for clarity and potential future changes
        query = "SELECT id, date, year, month, week, day_of_week, account, category, sub_category, type, user, amount FROM expenses ORDER BY date DESC"
        df = pd.read_sql(query, conn)
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        logging.info(f"Fetched {len(df)} expenses.")
        return df
    except (sqlite3.Error, pd.errors.DatabaseError) as e:
        logging.error(f"Error fetching all expenses: {e}", exc_info=True)
        return pd.DataFrame()
    finally:
        if conn: conn.close()

def fetch_expense_by_id(expense_id: str) -> Optional[Dict[str, Any]]:
    """Fetches a single expense by its ID."""
    conn = get_connection()
    if conn is None:
        logging.error(f"Cannot fetch expense {expense_id}: Database connection failed.")
        return None
    try:
        cursor = conn.cursor()
        # Use parameter binding for safety
        cursor.execute("SELECT * FROM expenses WHERE id = ?", (expense_id,))
        record = cursor.fetchone()
        logging.debug(f"Fetched expense for ID {expense_id}: {'Found' if record else 'Not Found'}")
        # Convert sqlite3.Row to dict if found
        return dict(record) if record else None
    except sqlite3.Error as e:
        logging.error(f"Error fetching expense by ID {expense_id}: {e}", exc_info=True)
        return None
    finally:
        if conn: conn.close()

def insert_expense(data: Dict[str, Any]) -> bool:
    """
    Inserts a new expense record into the database.

    Args:
        data (Dict[str, Any]): Dictionary containing expense details.
                               Must include all required fields.

    Returns:
        bool: True if insertion was successful, False otherwise.
    """
    conn = get_connection()
    if conn is None:
        logging.error("Cannot insert expense: Database connection failed.")
        return False

    # Define expected columns explicitly based on the SQL statement below
    required_fields = ['date', 'year', 'month', 'week', 'day_of_week',
                       'account', 'category', 'sub_category', 'type',
                       'user', 'amount']

    # Check for missing fields *before* trying to insert
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        logging.error(f"Missing required fields for inserting expense: {', '.join(missing_fields)}. Data provided: {list(data.keys())}")
        return False

    sql = """
    INSERT INTO expenses (
        id, date, year, month, week, day_of_week,
        account, category, sub_category, type, user, amount
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """

    try:
        cursor = conn.cursor()
        new_id = str(uuid4()) # Generate UUID here
        # Prepare values in the correct order, ensuring types
        values = (
            new_id,
            data['date'], # Assume already string in 'YYYY-MM-DD' format
            int(data['year']),
            data['month'],
            data['week'],
            data['day_of_week'],
            data['account'],
            data['category'],
            # Handle potentially missing/empty sub_category gracefully
            data.get('sub_category', ''), # Use .get for optional fields if applicable
            data['type'],
            data['user'],
            float(data['amount'])
        )
        cursor.execute(sql, values)
        conn.commit()
        logging.info(f"✅ Expense inserted with ID: {new_id}")
        return True
    except (sqlite3.Error, ValueError, TypeError) as e: # Catch potential type errors too
        logging.error(f"Error inserting expense: {e}", exc_info=True)
        conn.rollback()
        return False
    finally:
        if conn:
            conn.close()


def update_expense(expense_id: str, data: Dict[str, Any]) -> bool:
    """Updates an existing expense based on its ID."""
    conn = get_connection()
    if conn is None:
        logging.error(f"Cannot update expense {expense_id}: Database connection failed.")
        return False

    # Define fields allowed for update (excluding id, maybe others)
    updatable_fields = ['date', 'year', 'month', 'week', 'day_of_week', 'account', 'category', 'sub_category', 'type', 'user', 'amount']
    # Construct SET clause dynamically from provided data, only using allowed fields
    set_parts = []
    values = []
    for field in updatable_fields:
        if field in data:
            set_parts.append(f"{field} = ?")
            # Basic type conversion/validation (more robust needed for production)
            if field in ['year']:
                values.append(int(data[field]))
            elif field in ['amount']:
                values.append(float(data[field]))
            else:
                values.append(data[field])

    if not set_parts:
        logging.warning(f"No valid fields provided for updating expense ID {expense_id}.")
        return False

    set_clause = ", ".join(set_parts)
    sql = f"UPDATE expenses SET {set_clause} WHERE id = ?"
    values.append(expense_id) # Add the ID for the WHERE clause

    try:
        cursor = conn.cursor()
        cursor.execute(sql, tuple(values))
        conn.commit()
        if cursor.rowcount == 0:
            logging.warning(f"No expense found with ID {expense_id} to update.")
            return False
        logging.info(f"Expense {expense_id} updated successfully.")
        return True
    except (sqlite3.Error, ValueError, TypeError) as e:
        logging.error(f"Error updating expense {expense_id}: {e}", exc_info=True)
        conn.rollback()
        return False
    finally:
        if conn: conn.close()

def delete_expense(expense_id: str) -> bool:
    """Deletes an expense record by its ID."""
    conn = get_connection()
    if conn is None:
        logging.error(f"Cannot delete expense {expense_id}: Database connection failed.")
        return False

    sql = "DELETE FROM expenses WHERE id = ?"
    try:
        cursor = conn.cursor()
        cursor.execute(sql, (expense_id,))
        conn.commit()
        if cursor.rowcount == 0:
            logging.warning(f"No expense found with ID {expense_id} to delete.")
            return False
        logging.info(f"Expense {expense_id} deleted successfully.")
        return True
    except sqlite3.Error as e:
        logging.error(f"Error deleting expense {expense_id}: {e}", exc_info=True)
        conn.rollback()
        return False
    finally:
        if conn: conn.close()

def fetch_last_expenses(n: int = 10) -> pd.DataFrame:
    """Fetches the last N expenses, ordered by date then rowid descending."""
    conn = get_connection()
    if conn is None:
        logging.error(f"Cannot fetch last {n} expenses: Database connection failed.")
        return pd.DataFrame()
    try:
        # Order by date descending first, then rowid descending as a tie-breaker
        # Explicitly list columns
        query = f"""
            SELECT id, date, year, month, week, day_of_week, account, category, sub_category, type, user, amount
            FROM expenses
            ORDER BY date DESC, rowid DESC
            LIMIT ?
        """
        df = pd.read_sql(query, conn, params=(n,))
        df['date'] = pd.to_datetime(df['date'], errors='coerce')
        logging.info(f"Fetched last {len(df)} expenses (requested {n}).")
        return df
    except (sqlite3.Error, pd.errors.DatabaseError) as e:
        logging.error(f"Error fetching last {n} expenses: {e}", exc_info=True)
        return pd.DataFrame()
    finally:
        if conn: conn.close()
"""

File: main.py
Location: streamlit\main.py
Summary: The file is the main Streamlit application for a Personal Expense Tracker, managing page navigation and rendering functions for tabs like "Add Expenses," "Reports," and "Visualizations." It configures the page, loads CSS, handles sidebar navigation and data management, and includes a placeholder for an "Assistant" tab.
Code: """
# streamlit/main.py
"""
Main Streamlit application file for the Personal Expense Tracker.
Handles page navigation and calls rendering functions for each tab.
"""
import streamlit as st
# --- ✅ Relative Imports for modules within the 'streamlit' package ---
from tabs import add_expense, reports, visuals
from style_utils import load_css
from db_utils import fetch_all_expenses  # For CSV download
import pandas as pd
import logging
from pathlib import Path # Good practice for path handling

# --- Page Configuration ---
st.set_page_config(
    layout="wide",
    page_title="Personal Expense Tracker",
    page_icon="💰"
)

# --- Load CSS ---
load_css()

# --- Optional: Banner ---
st.markdown(
    '<div class="app-banner">My Personal Finance App</div>',
    unsafe_allow_html=True
) # Consider adding specific styling in styles.css if uncommented

# --- Sidebar Navigation ---
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to",
    # --- ✅ Added 'Assistant' placeholder ---
    ["Add Expenses", "Reports", "Visualizations", "Assistant"],
    label_visibility="collapsed",
    key="main_nav"
)

st.sidebar.markdown("---")

# --- Sidebar Data Management ---
st.sidebar.header("Data Management")
try:
    # Fetch data using the relatively imported function
    df_all = fetch_all_expenses()
    if not df_all.empty:
        # Optional: drop UUID if not needed
        df_export = df_all.drop(columns=["id"], errors="ignore")
        csv_bytes = df_export.to_csv(index=False).encode("utf-8")

        st.sidebar.download_button(
            label="Download Data Backup (.csv)",
            data=csv_bytes,
            file_name="expenses_backup.csv",
            mime="text/csv",
            help="Download the full dataset as a CSV file"
        )
    else:
        st.sidebar.info("No expense data available to download.")
except Exception as e:
    st.sidebar.error("Error loading data for CSV backup.")
    logging.exception("Sidebar CSV export error: %s", e)

# --- Page Rendering ---
if page == "Add Expenses":
    # Call the relatively imported module's function
    add_expense.render()
elif page == "Reports":
    # Call the relatively imported module's function
    reports.render()
elif page == "Visualizations":
    # Call the relatively imported module's function
    visuals.render()
elif page == "Assistant":
     # --- ✅ Placeholder for the new Assistant tab UI ---
     st.subheader("Assistant")
     st.info("Chatbot interface coming soon!")
     # We will create and import streamlit.tabs.assistant_tab later
else:
    st.error("Invalid page selected.")
"""

File: styles.css
Location: streamlit\styles.css
Summary: The `styles.css` file imports the 'Roboto' font and defines CSS variables for a light theme, including colors for backgrounds, text, accents, borders, and success/warning indicators. It also specifies a border radius and uses 'Roboto' as the font family.
Code: """
/* styles.css */

/* --- Base Font --- */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

/* --- Light Theme Variables --- */
:root {
    --primary-bg-color: #FFFFFF;       /* White main background */
    --secondary-bg-color: #F8F9FA;   /* Very light grey for sidebar, tables */
    --widget-bg-color: #FFFFFF;      /* Widget background (White) */
    --text-color: #212529;           /* Dark text color */
    --subtle-text-color: #6C757D;    /* Grey for less important text */
    --accent-color: #007BFF;         /* Standard Blue for buttons, highlights */
    --accent-hover-color: #0056b3;   /* Darker blue on hover */
    --border-color: #DEE2E6;         /* Light grey border */
    --border-focus-color: #80BDFF;   /* Lighter blue for focus rings */
    --border-radius: 4px;            /* Subtle rounded corners */
    --font-family: 'Roboto', sans-serif;

    --success-color: #198754;        /* Bootstrap Green */
    --warning-color: #FFC107;        /* Bootstrap Yellow */
    --error-color: #DC3545;          /* Bootstrap Red */
    --success-bg-color: #D1E7DD;
    --warning-bg-color: #FFF3CD;
    --error-bg-color: #F8D7DA;
}

/* --- General Styles --- */
body {
    color: var(--text-color);
    background-color: var(--primary-bg-color);
    font-family: var(--font-family);
    font-size: 14px; /* Base font size */
}

h1, h2, h3, h4, h5, h6 { color: var(--text-color); font-weight: 500; }
h3 { margin-top: 1.8rem; margin-bottom: 0.8rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color); font-weight: 600; }
a { color: var(--accent-color); text-decoration: none; }
a:hover { color: var(--accent-hover-color); text-decoration: underline; }
hr { border-top: 1px solid var(--border-color); margin-top: 1.5rem; margin-bottom: 1.5rem; }


/* --- App Banner Header Style --- */
.app-banner {
    background-color: #495057;
    color: white;
    padding: 1rem 2.5rem;
    margin: 0 -2.5rem 2rem -2.5rem; /* Adjust negative margins to match block-container padding */
    text-align: center;
    font-size: 1.8rem;
    font-weight: 500;
    border-radius: 0; /* Ensure it spans full width */
}

/* --- Main Content Area --- */
.main .block-container {
    padding-top: 2rem; /* Reset top padding if banner is used */
    padding-bottom: 2rem;
    padding-left: 2.5rem;
    padding-right: 2.5rem;
}

/* --- Sidebar --- */
[data-testid="stSidebar"] { background-color: var(--secondary-bg-color); border-right: 1px solid var(--border-color); }
[data-testid="stSidebar"] h1, [data-testid="stSidebar"] h2, [data-testid="stSidebar"] h3 { color: var(--text-color); font-weight: 600; }
[data-testid="stSidebar"] .stRadio > label { color: var(--text-color); display: block; padding: 0.5rem 0.8rem; margin-bottom: 0.2rem; border-radius: var(--border-radius); transition: background-color 0.2s ease, color 0.2s ease; font-weight: 400; }
[data-testid="stSidebar"] .stRadio > label:hover { background-color: #E9ECEF; color: var(--accent-color); }
[data-testid="stSidebar"] .stRadio [type="radio"]:checked + div > label { color: var(--accent-color); font-weight: 600; background-color: #E9ECEF; }
/* Sidebar Download Button Style */
[data-testid="stSidebar"] .stDownloadButton > button { background-color: var(--success-color); border-color: var(--success-color); color: #FFFFFF; }
[data-testid="stSidebar"] .stDownloadButton > button:hover { background-color: #157347; border-color: #146c43; color: #FFFFFF; }
[data-testid="stSidebar"] .stDownloadButton > button:focus { box-shadow: 0 0 0 0.2rem rgba(25, 135, 84, 0.5); outline: none; }

/* --- Widgets --- General Appearance --- */
/* Buttons */
.stButton > button { background-color: var(--accent-color); color: #FFFFFF; border: 1px solid var(--accent-color); padding: 0.4rem 1rem; border-radius: var(--border-radius); font-weight: 400; transition: background-color 0.2s ease, border-color 0.2s ease; }
.stButton > button:hover { background-color: var(--accent-hover-color); border-color: var(--accent-hover-color); color: #FFFFFF; }
.stButton > button:focus { outline: none; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); }
.stButton > button:disabled { background-color: #ced4da; border-color: #ced4da; }

/* Text Input, Number Input, Date Input */
.stTextInput input,
.stNumberInput input,
.stDateInput input {
    background-color: var(--widget-bg-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: 0.4rem 0.7rem;
    transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
    width: 100%;
    box-sizing: border-box;
    font-size: 1em; /* Use em for relative sizing */
    line-height: 1.5; /* Ensure consistent line height */
    min-height: calc(1.5em + 0.8rem + 2px); /* Match approx height of selectbox */
}
.stTextInput input:focus,
.stNumberInput input:focus,
.stDateInput input:focus {
    border-color: var(--border-focus-color);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    outline: none;
}
/* Style the container for DateInput for consistency */
[data-testid="stDateInput"] > div:first-child {
     background-color: var(--widget-bg-color);
     border: 1px solid var(--border-color);
     border-radius: var(--border-radius);
     overflow: hidden; /* Prevents internal parts from breaking border radius */
}
[data-testid="stDateInput"] > div:first-child:has(input:focus) {
    border-color: var(--border-focus-color);
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

/* Selectbox, Multiselect */
.stSelectbox > div[data-baseweb="select"],
.stMultiSelect > div[role="listbox"] {
    background-color: var(--widget-bg-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: var(--border-radius) !important;
    color: var(--text-color) !important;
    overflow: hidden !important;
    min-height: calc(1.5em + 0.8rem + 2px); /* Match input height */
    display: flex;
    align-items: center;
}
.stMultiSelect input { /* Text typed into multiselect */
    color: var(--text-color) !important;
    background-color: transparent !important;
}
/* Focus state for Selectbox/Multiselect */
.stSelectbox > div[aria-expanded="true"],
.stMultiSelect > div[aria-expanded="true"] {
    border-color: var(--border-focus-color) !important;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25) !important;
}
/* Dropdown menu styling */
div[data-baseweb="popover"] > div[data-baseweb="menu"] { background-color: var(--primary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius); box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15); overflow: hidden; z-index: 1000; }
div[data-baseweb="popover"] ul li { color: var(--text-color); padding: 0.4rem 1rem; }
div[data-baseweb="popover"] ul li:hover { background-color: var(--secondary-bg-color); }
div[data-baseweb="popover"] ul li[aria-selected="true"] { background-color: var(--accent-color); color: #FFFFFF; }

/* --- Forms & Expanders --- */
[data-testid="stForm"] {
    padding: 1.5rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    margin-bottom: 1.5rem;
    background-color: var(--primary-bg-color); /* Ensure background is white */
}
[data-testid="stExpander"] {
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    margin-bottom: 1rem;
    overflow: hidden;
}
[data-testid="stExpander"] summary { font-weight: 500; padding: 0.6rem 1rem; color: var(--text-color); border-bottom: 1px solid var(--border-color); }
[data-testid="stExpander"] summary:hover { color: var(--accent-color); }
[data-testid="stExpander"] div[role="button"] svg { fill: var(--text-color); }
[data-testid="stExpander"] .streamlit-expanderContent { padding: 1rem; background-color: var(--primary-bg-color); }

/* --- Widget Labels (General) --- */
label {
    color: var(--text-color);
    font-weight: 500;
    display: block;
    margin-bottom: 0.3rem; /* Consistent spacing below labels */
    font-size: 0.95em; /* Slightly smaller label font */
}

/* --- Dataframe / Table --- */
.stDataFrame { border: 1px solid var(--border-color); border-radius: var(--border-radius); overflow: hidden; }
.stDataFrame > div { border-radius: inherit; overflow: hidden; } /* Ensures content respects border radius */
.stDataFrame thead th { background-color: var(--secondary-bg-color); color: var(--text-color); font-weight: 600; border-bottom: 2px solid var(--border-color); text-align: left; padding: 0.6rem 0.8rem; }
.stDataFrame tbody tr:nth-child(even) { background-color: var(--secondary-bg-color); }
.stDataFrame tbody tr:nth-child(odd) { background-color: var(--primary-bg-color); }
.stDataFrame tbody td { color: var(--text-color); border-bottom: none; padding: 0.5rem 0.8rem; border-right: 1px solid var(--border-color); vertical-align: middle; } /* Align text vertically middle */
.stDataFrame tbody td:last-child { border-right: none; }
.stDataFrame tbody tr:hover td { background-color: #E9ECEF; } /* Hover effect */

/* --- Alerts / Messages --- */
[data-testid="stAlert"] { border-radius: var(--border-radius); border: 1px solid transparent; padding: 0.8rem 1rem; margin-bottom: 1rem; }
[data-testid="stAlert"][data-baseweb="notification-positive"] { background-color: var(--success-bg-color); border-color: var(--success-color); color: #0f5132; }
[data-testid="stAlert"][data-baseweb="notification-warning"] { background-color: var(--warning-bg-color); border-color: var(--warning-color); color: #664d03; }
[data-testid="stAlert"][data-baseweb="notification-negative"] { background-color: var(--error-bg-color); border-color: var(--error-color); color: #842029; }
[data-testid="stToast"] { border-radius: var(--border-radius); font-weight: 500; } /* Style toasts */

/* --- Legend Toggle Alignment Fix (Visuals Tab) --- */
/* This seems specific to expanders in visuals.py, keep if needed */
div[data-testid="stExpander"] div[data-testid="stVerticalBlock"] > div[data-testid="stHorizontalBlock"] {
    align-items: center; margin: -0.5rem 0;
}
div[data-testid="stExpander"] div[data-testid="stVerticalBlock"] > div[data-testid="stHorizontalBlock"] > div:first-child { padding-right: 0.5rem; }
div[data-testid="stExpander"] div[data-testid="stVerticalBlock"] > div[data-testid="stHorizontalBlock"] > div:last-child { padding-left: 0; margin-top: -0.2rem; }

/* --- 💅 ADD EXPENSE FORM ALIGNMENT --- */

/* Target the columns specifically within the Add Expense form (key="expense_form") */
/* We target the container Streamlit creates for each column */
form[data-testid="stForm"] div[data-testid="stHorizontalBlock"] > div[data-testid="stVerticalBlock"] {
    /* Use flexbox to align items vertically */
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* Align items to the top */
    height: 100%; /* Allow vertical stretching if needed */
}

/* Target the container holding each widget (label + input) */
form[data-testid="stForm"] div[data-testid="element-container"] {
    margin-bottom: 1rem; /* Consistent spacing between widget rows */
    /* Ensure elements stretch to container width */
    width: 100%;
}

/* Ensure labels have consistent bottom margin */
form[data-testid="stForm"] label {
    margin-bottom: 0.3rem;
    display: block; /* Make sure label is block */
}

/* Add specific top margin ONLY to the second row of widgets for vertical spacing */
/* Target widgets by their data-testid within the form columns */
form[data-testid="stForm"] div[data-testid="stSelectbox"][key="add_sub_category"],
form[data-testid="stForm"] div[data-testid="stNumberInput"][key="add_amount"] {
    margin-top: 1.1rem; /* Adjust this value to visually align with first row */
                     /* This assumes the first row (Account/Type) doesn't need extra top margin */
}
"""

File: style_utils.py
Location: streamlit\style_utils.py
Summary: The script `style_utils.py` in Streamlit loads CSS styling from a `styles.css` file located in the same directory. It uses `pathlib` for path handling and logs errors if the file cannot be read or is missing, displaying an error message in the Streamlit app if loading fails.
Code: """
# streamlit/style_utils.py
import streamlit as st
import logging
from pathlib import Path # Use pathlib for robust path handling

# --- Assume styles.css is in the same directory as this script ---
CSS_FILE = Path(__file__).parent / "styles.css"

def load_css():
    """Loads CSS from the styles.css file located in the same directory."""
    if CSS_FILE.is_file():
        try:
            with open(CSS_FILE, "r") as f:
                css = f.read()
            st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)
            # logging.info(f"Successfully loaded CSS from {CSS_FILE}") # Optional: for debugging
        except Exception as e:
            logging.error(f"Error reading CSS file {CSS_FILE}: {e}")
            st.error("Failed to load page styles.")
    else:
        logging.warning(f"CSS file not found at expected location: {CSS_FILE}")
        # st.warning("Page styling may be incomplete (CSS not found).")
"""

File: __init__.py
Location: streamlit\__init__.py
Summary: Please provide the content of the file you would like summarized.
Code: """

"""

File: add_expense.py
Location: streamlit\tabs\add_expense.py
Summary: The `add_expense.py` file defines a Streamlit application page for adding expenses. It loads metadata, validates user input, and inserts new expense entries into a database. The page includes form fields for date, category, account, and amount, and displays the last 10 expenses added. Error handling and logging are implemented.
Code: """
# streamlit/tabs/add_expense.py
import streamlit as st
import pandas as pd
from db_utils import insert_expense, fetch_last_expenses # Use direct import based on previous findings
import json
import datetime
from typing import Dict, Any, Optional
import logging
import time
from pathlib import Path

# Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
    """Loads metadata from the project's metadata directory."""
    if not METADATA_FILE_PATH.is_file():
        logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
        st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
        return None
    try:
        with open(METADATA_FILE_PATH, "r") as f:
            metadata = json.load(f)
            logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
            return metadata
    except json.JSONDecodeError as e:
        logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
        st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted.")
        return None
    except Exception as e:
        logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
        st.error("Critical application error: An unexpected error occurred while loading metadata.")
        return None

def render():
    """Renders the Add Expense page."""
    if "trigger_rerun" in st.session_state and time.time() > st.session_state["trigger_rerun"]:
        st.session_state.pop("trigger_rerun", None)
        st.rerun()

    st.subheader("Add New Expense")

    metadata = load_metadata()
    if metadata is None:
        return

    # Extract metadata components safely
    all_accounts = metadata.get("Account", [])
    category_map = metadata.get("categories", {})
    all_categories = sorted(list(category_map.keys()))
    user_map = metadata.get("User", {})

    if not all_accounts or not all_categories or not category_map or not user_map:
        st.error("Metadata structure is invalid or incomplete. Cannot proceed.")
        logging.error("Invalid metadata structure detected after loading.")
        return

    # --- Inputs outside the form ---
    expense_date = st.date_input("Date of Expense", value=datetime.date.today(), key="add_date")
    selected_category = st.selectbox("Category", options=all_categories, index=0, key="add_category")
    available_subcategories = sorted(category_map.get(selected_category, []))

    # --- Input Form ---
    with st.form("expense_form", clear_on_submit=True):
        # Use columns for side-by-side layout
        col1, col2 = st.columns(2)

        # --- Widgets in Columns ---
        # It's important that the order matches visually top-to-bottom
        with col1:
            selected_account = st.selectbox("Account", options=all_accounts, key="add_account")
            subcat_disabled = not bool(available_subcategories)
            selected_sub_category = st.selectbox(
                "Sub-category",
                options=available_subcategories,
                key="add_sub_category", # Key remains the same
                disabled=subcat_disabled,
                help="Select a sub-category if applicable." if not subcat_disabled else "No sub-categories for this category."
            )

        with col2:
            expense_type = st.text_input("Type (Description)", max_chars=60, key="add_type", help="Enter a brief description of the expense.")
            expense_amount = st.number_input("Amount (INR)", min_value=0.01, format="%.2f", step=10.0, key="add_amount") # Key remains the same

        # --- Form Submission Button ---
        submitted = st.form_submit_button("Add Expense")

        # --- Submission Logic ---
        if submitted:
            is_valid = True
            expense_user = user_map.get(selected_account, "Unknown") # Derive user here
            if not expense_type.strip():
                st.toast("⚠️ Please enter a Type/Description.", icon="⚠️"); is_valid = False
            if expense_amount <= 0:
                 st.toast("⚠️ Amount must be greater than zero.", icon="⚠️"); is_valid = False
            if available_subcategories and not selected_sub_category:
                st.toast("⚠️ Please select a Sub-category.", icon="⚠️"); is_valid = False

            if is_valid:
                final_sub_category = selected_sub_category if available_subcategories else ""
                dt = pd.to_datetime(expense_date)
                expense_data = {
                    "date": dt.strftime("%Y-%m-%d"), "year": dt.year,
                    "month": dt.to_period("M").strftime("%Y-%m"), "week": dt.strftime("%G-W%V"),
                    "day_of_week": dt.day_name(), "account": selected_account,
                    "category": selected_category, "sub_category": final_sub_category,
                    "type": expense_type.strip(), "user": expense_user, "amount": expense_amount
                }
                success = insert_expense(expense_data)
                if success:
                    st.toast("✅ Expense added successfully!", icon="✅")
                    st.session_state["last_added"] = expense_data
                    st.session_state["highlight_time"] = time.time()
                else:
                    st.toast("❌ Failed to save expense to the database.", icon="❌")

    # --- Display Recent Entries ---
    if "last_added" in st.session_state and "highlight_time" in st.session_state:
         # Check if highlight time has expired
         if time.time() - st.session_state["highlight_time"] <= 5:
              st.success("Entry saved successfully!") # Show success message briefly
         else:
              # Clear state after timeout
              st.session_state.pop("last_added", None)
              st.session_state.pop("highlight_time", None)

    st.markdown("---")
    st.subheader("Last 10 Expenses Added")
    try:
        df = fetch_last_expenses(10)
        if df.empty:
            st.info("No recent expenses recorded yet.")
        else:
            highlight_index = None
            last_added_data = st.session_state.get("last_added")
            highlight_start_time = st.session_state.get("highlight_time")

            if highlight_start_time and (time.time() - highlight_start_time > 5):
                 st.session_state.pop("last_added", None)
                 st.session_state.pop("highlight_time", None)
                 last_added_data = None

            if last_added_data:
                match = df[
                    (df["date"].dt.strftime('%Y-%m-%d') == last_added_data["date"]) &
                    (df["account"] == last_added_data["account"]) &
                    (df["category"] == last_added_data["category"]) &
                    (df["sub_category"].fillna("") == last_added_data["sub_category"]) &
                    (df["type"] == last_added_data["type"]) &
                    (df["user"] == last_added_data["user"]) &
                    (df["amount"].round(2) == round(float(last_added_data["amount"]), 2))
                ]
                if not match.empty:
                    highlight_index = match.index[0]

            display_df = df.drop(columns=["id", "year", "month", "week", "day_of_week"], errors="ignore").rename(columns={
                "date": "Date", "account": "Account", "category": "Category",
                "sub_category": "Sub Category", "type": "Type", "user": "User", "amount": "Amount (INR)"
            })

            def highlight_row_conditionally(row):
                is_highlighted = row.name == highlight_index
                return ['background-color: #d1ffd6' if is_highlighted else '' for _ in row]

            st.dataframe(
                display_df.style
                    .format({"Date": "{:%Y-%m-%d}", "Amount (INR)": "₹{:.2f}"})
                    .apply(highlight_row_conditionally, axis=1),
                use_container_width=True, height=380, hide_index=True
            )
    except Exception as e:
        logging.exception("Failed to display recent expenses table")
        st.error(f"Error loading recent expenses: {e}")
"""

File: reports.py
Location: streamlit\tabs\reports.py
Summary: This Streamlit module manages an expense report page, including viewing, editing, and deleting expenses. It loads metadata, fetches expenses from a database, and provides filtering options. Users can edit or delete expenses and download filtered data as CSV. It handles errors and logs operations for debugging.
Code: """
# streamlit/tabs/reports.py
import streamlit as st
import pandas as pd
import datetime
import json
import logging
from typing import Dict, Any, Optional
# Assuming db_utils is importable from streamlit/
from db_utils import fetch_all_expenses, fetch_expense_by_id, update_expense, delete_expense
from pathlib import Path
import time # Keep for short sleep after successful edit/delete

# Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

# Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
    """Loads metadata from the project's metadata directory."""
    if not METADATA_FILE_PATH.is_file():
        logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
        st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
        return None
    try:
        with open(METADATA_FILE_PATH, "r") as f:
            metadata = json.load(f)
            logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
            return metadata
    except json.JSONDecodeError as e:
        logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
        st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted. Please check its format.")
        return None
    except Exception as e:
        logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
        st.error("Critical application error: An unexpected error occurred while loading metadata.")
        return None

@st.cache_data
def convert_df_to_csv(df: pd.DataFrame) -> bytes:
    """Converts a DataFrame to CSV bytes."""
    try:
        if 'Date' in df.columns and pd.api.types.is_datetime64_any_dtype(df['Date']):
             df_copy = df.copy()
             df_copy['Date'] = df_copy['Date'].dt.strftime('%Y-%m-%d')
             return df_copy.to_csv(index=False).encode("utf-8")
        else:
             return df.to_csv(index=False).encode("utf-8")
    except Exception as e:
        logging.error(f"CSV conversion failed: {e}")
        st.error("Failed to generate CSV data.")
        return b""

# ==============================================================================
# Main Rendering Function
# ==============================================================================
def render():
    """Renders the Reports page, handling view, edit, and delete modes."""
    st.session_state.setdefault("edit_mode", False)
    st.session_state.setdefault("delete_confirm", False)
    st.session_state.setdefault("selected_expense_id", None)
    st.session_state.setdefault("force_refresh", False)

    metadata = load_metadata()
    if metadata is None:
        return

    # --- ✅ Handle Refresh Request at the Top ---
    # If flag is set from previous run (e.g., after edit/delete/button press)
    if st.session_state.get("force_refresh", False):
        st.session_state["force_refresh"] = False # Reset the flag immediately
        st.cache_data.clear() # Clear cache to ensure fresh data fetch
        # No explicit message needed, just let the page reload below
        # The rerun itself is triggered by button clicks or state changes that set the flag

    # --- Mode Handling ---
    if st.session_state.edit_mode:
        if st.session_state.selected_expense_id:
            expense = fetch_expense_by_id(st.session_state.selected_expense_id)
            if expense:
                display_edit_form(expense, metadata)
            else:
                st.error(f"Could not load expense with ID {st.session_state.selected_expense_id} to edit.")
                st.session_state.edit_mode = False
                st.session_state.selected_expense_id = None
                if st.button("Back to Report"): st.rerun()
            return

    elif st.session_state.delete_confirm:
        if st.session_state.selected_expense_id:
            expense = fetch_expense_by_id(st.session_state.selected_expense_id)
            if expense:
                display_delete_confirmation(expense)
            else:
                st.error(f"Could not load expense with ID {st.session_state.selected_expense_id} to delete.")
                st.session_state.delete_confirm = False
                st.session_state.selected_expense_id = None
                if st.button("Back to Report"): st.rerun()
            return

    # --- Default Mode: Render Report View ---
    render_report_view(metadata)

# ==============================================================================
# Report View Rendering Function
# ==============================================================================
def render_report_view(metadata: Dict[str, Any]):
    """Displays the main report view with filters and data table."""
    st.subheader("Expense Report")

    # --- Fetch Data ---
    # This fetch happens on initial load or after a rerun triggered by refresh/edit/delete
    df_all = fetch_all_expenses()

    if df_all.empty:
        st.info("No expense data available to display.")
        return

    # --- Prepare Data and Filter Options ---
    try:
        if not pd.api.types.is_datetime64_any_dtype(df_all['date']):
             df_all['date'] = pd.to_datetime(df_all['date'], errors='coerce')
             df_all.dropna(subset=['date'], inplace=True)

        if 'month' not in df_all.columns and 'date' in df_all.columns:
             df_all['month'] = df_all['date'].dt.strftime('%Y-%m')

        required_cols = ['date', 'month', 'account', 'category', 'sub_category', 'user', 'amount', 'id', 'type']
        if not all(col in df_all.columns for col in required_cols):
             missing = [col for col in required_cols if col not in df_all.columns]
             st.error(f"Database is missing required columns: {', '.join(missing)}. Cannot generate report.")
             logging.error(f"Missing columns in fetched data: {missing}")
             return

        all_months = ["All"] + sorted(df_all['month'].unique(), reverse=True)
        all_accounts = ["All"] + sorted(metadata.get("Account", []))
        all_categories = ["All"] + sorted(list(metadata.get("categories", {}).keys()))
        all_users = ["All"] + sorted(list(set(metadata.get("User", {}).values())))
        category_map = metadata.get("categories", {})
    except Exception as e:
         st.error(f"Error preparing data or filter options: {e}")
         logging.exception("Error during data preparation in reports tab.")
         return


    # --- Filter UI ---
    st.markdown("#### Filter Options")
    month_selected = st.selectbox(
        "Filter by Month", options=all_months, index=0, key="report_month_filter"
    )

    filter_col1, filter_col2 = st.columns(2)
    with filter_col1:
        accounts_selected = st.multiselect("Filter by Account(s)", options=all_accounts, default=["All"], key="report_account_filter")
        users_selected = st.multiselect("Filter by User(s)", options=all_users, default=["All"], key="report_user_filter")
    with filter_col2:
        categories_selected = st.multiselect("Filter by Category(s)", options=all_categories, default=["All"], key="report_category_filter")
        subcats_available = set()
        if "All" in categories_selected:
            for sublist in category_map.values(): subcats_available.update(sublist)
        else:
            for cat in categories_selected: subcats_available.update(category_map.get(cat, []))
        all_subcategories_options = ["All"] + sorted(list(subcats_available))
        subcategory_selected = st.selectbox(
            "Filter by Sub-category", options=all_subcategories_options, index=0, key="report_subcategory_filter",
            help="Available sub-categories depend on selected Categories."
        )

    # --- Apply Filters ---
    try:
        df_filtered = df_all.copy()
        if month_selected != "All": df_filtered = df_filtered[df_filtered['month'] == month_selected]
        if "All" not in accounts_selected: df_filtered = df_filtered[df_filtered['account'].isin(accounts_selected)]
        if "All" not in categories_selected: df_filtered = df_filtered[df_filtered['category'].isin(categories_selected)]
        if subcategory_selected != "All": df_filtered = df_filtered[df_filtered['sub_category'] == subcategory_selected]
        if "All" not in users_selected: df_filtered = df_filtered[df_filtered['user'].isin(users_selected)]
    except Exception as e:
         st.error(f"Error applying filters: {e}")
         logging.exception("Error occurred while filtering DataFrame.")
         df_filtered = pd.DataFrame()


    # --- Display Summary ---
    st.markdown("---")
    total_filtered_expense = df_filtered['amount'].sum() if not df_filtered.empty else 0
    st.markdown(f"### Total Expense (Filtered): ₹{total_filtered_expense:,.2f}")

    if not df_filtered.empty:
        st.markdown("#### Summary Statistics (Filtered)")
        num_transactions = len(df_filtered)
        avg_transaction_amount = df_filtered['amount'].mean()
        top_category_series = df_filtered.groupby("category")["amount"].sum().nlargest(1)
        top_category_display = "N/A"
        if not top_category_series.empty:
             top_category_display = f"{top_category_series.index[0]} (₹{top_category_series.values[0]:,.0f})"
        stat_col1, stat_col2, stat_col3 = st.columns(3)
        stat_col1.metric("Transactions", f"{num_transactions:,}")
        stat_col2.metric("Avg. Transaction", f"₹{avg_transaction_amount:,.2f}")
        stat_col3.metric("Top Category", top_category_display)
    elif not df_all.empty:
        st.info("No transactions match the current filter criteria.")


    # --- Detailed Transactions Table ---
    st.markdown("---")
    col_title, col_refresh = st.columns([4, 1])
    with col_title:
         st.markdown("### Detailed Transactions (Filtered)")
    with col_refresh:
        # --- Refresh Button just sets the flag and triggers rerun ---
        if st.button("🔄 Refresh Data", key="report_refresh_btn", help="Click to reload data from database"):
            st.session_state["force_refresh"] = True
            st.rerun() # Trigger rerun, flag will be checked at the top

    if not df_filtered.empty:
        display_columns = ["date", "account", "category", "sub_category", "type", "user", "amount"]
        existing_display_cols = [col for col in display_columns if col in df_filtered.columns]
        display_df = df_filtered[existing_display_cols + ['id']].copy()
        display_df = display_df.rename(columns={
            "date": "Date", "account": "Account", "category": "Category",
            "sub_category": "Sub Category", "type": "Type", "user": "User", "amount": "Amount (INR)"
        }).sort_values("Date", ascending=False)

        st.dataframe(
            display_df.drop(columns=['id']),
            column_config={
                 "Date": st.column_config.DateColumn("Date", format="YYYY-MM-DD"),
                 "Amount (INR)": st.column_config.NumberColumn("Amount (INR)", format="₹%.2f")
            },
            use_container_width=True, height=400, hide_index=True
        )

        # --- Edit / Delete Controls ---
        st.markdown("---")
        st.markdown("#### Edit / Delete Expense")
        df_selectable = display_df.copy().head(500)

        def create_display_label(row):
             date_str = row['Date'].strftime('%Y-%m-%d') if pd.notna(row['Date']) else 'N/A'
             amt_str = f"₹{row['Amount (INR)']:.0f}"
             return f"{date_str} | {row['Category']} | {row.get('Sub Category', '')[:15]} | {row.get('Type', '')[:20]} | {amt_str}"

        selector_map = {"-- Select expense to modify --": None}
        for idx, row in df_selectable.iterrows():
             label = create_display_label(row)
             unique_label = f"{label} (ID: ...{row['id'][-6:]})"
             selector_map[unique_label] = row['id']

        selected_label = st.selectbox("Select Expense", options=list(selector_map.keys()), key="report_select_expense")
        selected_id = selector_map.get(selected_label)

        edit_col, delete_col = st.columns([1, 1])
        edit_disabled = selected_id is None
        delete_disabled = selected_id is None
        with edit_col:
            if st.button("Edit Selected", key="report_edit_btn", disabled=edit_disabled):
                st.session_state.selected_expense_id = selected_id
                st.session_state.edit_mode = True
                st.rerun()
        with delete_col:
            if st.button("Delete Selected", key="report_delete_btn", disabled=delete_disabled):
                st.session_state.selected_expense_id = selected_id
                st.session_state.delete_confirm = True
                st.rerun()

        # --- CSV Download Button ---
        st.markdown("---")
        csv_export_df = display_df.drop(columns=['id'])
        csv_data = convert_df_to_csv(csv_export_df)
        if csv_data:
            st.download_button(
                label="📥 Download Filtered Data (.csv)", data=csv_data,
                file_name="filtered_expenses.csv", mime="text/csv", key="report_download_csv"
            )
    # No final else needed here

# ==============================================================================
# Edit Form Display Function
# ==============================================================================
def display_edit_form(expense_data: Dict[str, Any], metadata: Dict[str, Any]):
    """Displays the form for editing a selected expense with dynamic sub-categories and rearranged layout."""
    expense_id = expense_data.get("id", "UNKNOWN")
    expense_id_short = f"...{expense_id[-6:]}" if expense_id != "UNKNOWN" else "N/A"
    st.subheader(f"Edit Expense (ID: {expense_id_short})")

    all_categories = sorted(metadata.get("categories", {}).keys())
    all_accounts = metadata.get("Account", [])
    user_map = metadata.get("User", {})
    category_map = metadata.get("categories", {})

    # --- Session State Initialization (as before) ---
    session_key_category = f"edit_category_{expense_id}"
    session_key_subcat_options = f"edit_subcat_options_{expense_id}"
    session_key_subcat_index = f"edit_subcat_index_{expense_id}"
    if session_key_category not in st.session_state:
        st.session_state[session_key_category] = expense_data.get("category", all_categories[0] if all_categories else None)

    # --- Callback (as before) ---
    def category_change_callback():
        new_category = st.session_state[f"edit_category_widget_{expense_id}"]
        st.session_state[session_key_category] = new_category
        new_subcat_options = sorted(category_map.get(new_category, []))
        st.session_state[session_key_subcat_options] = new_subcat_options
        st.session_state[session_key_subcat_index] = 0 # Reset index on category change

    # --- Get current state (as before) ---
    current_edit_category = st.session_state[session_key_category]
    current_subcat_options = st.session_state.get(session_key_subcat_options, sorted(category_map.get(current_edit_category, [])))

    try:
        # --- Pre-populate initial values (as before) ---
        default_date = pd.to_datetime(expense_data["date"]).date()
        default_account_index = all_accounts.index(expense_data["account"]) if expense_data["account"] in all_accounts else 0
        initial_category_index = all_categories.index(current_edit_category) if current_edit_category in all_categories else 0
        initial_subcat = expense_data.get("sub_category", "")
        initial_subcat_index = 0
        if initial_subcat and initial_subcat in current_subcat_options:
             initial_subcat_index = current_subcat_options.index(initial_subcat)
        if session_key_subcat_index not in st.session_state:
             st.session_state[session_key_subcat_index] = initial_subcat_index
        default_type = expense_data.get("type", "")
        default_amount = float(expense_data.get("amount", 0.01))

        # --- Widgets ABOVE the Form ---
        st.markdown("---") # Separator
        # --- ✅ Date Moved Here ---
        new_date_input = st.date_input("Date", value=default_date, key="edit_date_outside")
        # --- Category (triggers callback, stays outside form) ---
        st.selectbox(
            "Category",
            options=all_categories,
            index=initial_category_index,
            key=f"edit_category_widget_{expense_id}",
            on_change=category_change_callback
        )
        st.markdown("---") # Separator

        # --- Main Edit Form ---
        with st.form("edit_expense_form"):
            st.markdown("#### Modify Remaining Details")

            # --- ✅ Row 1: Account & Type ---
            row1_col1, row1_col2 = st.columns(2)
            with row1_col1:
                new_account_input = st.selectbox( # Changed variable name
                    "Account",
                    options=all_accounts,
                    index=default_account_index,
                    key="edit_account"
                )
            with row1_col2:
                new_type_input = st.text_input( # Changed variable name
                    "Type",
                    value=default_type,
                    key="edit_type",
                    max_chars=60
                )

            # --- ✅ Row 2: Sub-category & Amount ---
            row2_col1, row2_col2 = st.columns(2)
            with row2_col1:
                 subcat_disabled = not bool(current_subcat_options)
                 current_subcat_idx = st.session_state.get(session_key_subcat_index, 0)
                 if current_subcat_idx >= len(current_subcat_options): current_subcat_idx = 0
                 new_subcat_input = st.selectbox( # Changed variable name
                      "Sub-category",
                      options=current_subcat_options,
                      index=current_subcat_idx,
                      key="edit_subcat_widget",
                      disabled=subcat_disabled,
                      help="Options update based on Category selected above."
                 )
            with row2_col2:
                 new_amount_input = st.number_input( # Changed variable name
                     "Amount (INR)",
                     value=default_amount,
                     min_value=0.01,
                     format="%.2f",
                     key="edit_amount"
                 )

            # --- User Display (Optional, Placed After Grid) ---
            derived_user = user_map.get(new_account_input, "Unknown")
            st.text(f"User: {derived_user}") # Display derived user

            # --- Form Submission Buttons ---
            submit_col, cancel_col = st.columns([1, 1])
            with submit_col: save_changes = st.form_submit_button("Save Changes")
            with cancel_col: cancel_edit = st.form_submit_button("Cancel")

            # --- Submission Logic ---
            if save_changes:
                # --- Read final values from widgets/state ---
                final_category = st.session_state[session_key_category]
                final_subcat_options = sorted(category_map.get(final_category, []))
                final_subcat_selection = new_subcat_input # Read from widget
                final_date = new_date_input # Read from widget outside form
                final_account = new_account_input # Read from widget
                final_type = new_type_input # Read from widget
                final_amount = new_amount_input # Read from widget

                # Validation
                is_valid = True
                if not final_type.strip(): st.warning("Type cannot be empty."); is_valid = False
                if final_amount <= 0: st.warning("Amount must be positive."); is_valid = False
                if final_subcat_options and not final_subcat_selection:
                    st.warning(f"Sub-category required for '{final_category}'."); is_valid = False
                if final_subcat_selection and final_subcat_selection not in final_subcat_options:
                     st.warning(f"'{final_subcat_selection}' is not valid for '{final_category}'."); is_valid = False

                if is_valid:
                     final_dt = pd.to_datetime(final_date)
                     updated_data = {
                        "date": final_dt.strftime("%Y-%m-%d"), "year": final_dt.year,
                        "month": final_dt.strftime("%Y-%m"), "week": final_dt.strftime("%G-W%V"),
                        "day_of_week": final_dt.day_name(), "account": final_account,
                        "category": final_category,
                        "sub_category": final_subcat_selection if final_subcat_options else "",
                        "type": final_type.strip(), "user": derived_user, "amount": final_amount
                     }
                     success = update_expense(expense_data["id"], updated_data)
                     if success:
                        st.success("Expense updated successfully!")
                        # Clean up state
                        for key in [session_key_category, session_key_subcat_options, session_key_subcat_index, f"edit_category_widget_{expense_id}"]:
                            if key in st.session_state: del st.session_state[key]
                        st.session_state.edit_mode = False
                        st.session_state.selected_expense_id = None
                        st.session_state["force_refresh"] = True
                        time.sleep(0.5)
                        st.rerun()
                     else:
                         st.error("Failed to update expense in the database.")

            elif cancel_edit:
                 # Clean up state
                 for key in [session_key_category, session_key_subcat_options, session_key_subcat_index, f"edit_category_widget_{expense_id}"]:
                     if key in st.session_state: del st.session_state[key]
                 st.session_state.edit_mode = False
                 st.session_state.selected_expense_id = None
                 st.rerun()

    except (ValueError, IndexError, KeyError, TypeError) as e:
         st.error(f"Error preparing edit form: {e}. Data might be inconsistent or type mismatch.")
         logging.exception(f"Error preparing edit form for ID {expense_id}: {e}")
         if st.button("Back to Report"):
              st.session_state.edit_mode = False; st.session_state.selected_expense_id = None; st.rerun()

# ==============================================================================
# Delete Confirmation Display Function
# ==============================================================================
def display_delete_confirmation(expense_data: Dict[str, Any]):
    """Displays the confirmation dialog for deleting an expense."""
    st.subheader("Confirm Deletion")
    st.warning(f"⚠️ Are you sure you want to permanently delete this expense?")

    details = {
        "Date": expense_data.get('date'), "Category": expense_data.get('category'),
        "Sub Category": expense_data.get('sub_category'), "Type": expense_data.get('type'),
        "Amount": f"₹{expense_data.get('amount', 0):,.2f}", "User": expense_data.get('user'),
        "Account": expense_data.get('account'), "ID": f"...{expense_data.get('id', '')[-6:]}"
    }
    st.json(details, expanded=True)

    confirm_col, cancel_col = st.columns(2)
    with confirm_col:
        if st.button("Yes, Delete Permanently", key="confirm_delete", type="primary"):
            success = delete_expense(expense_data["id"])
            if success:
                st.success("Expense deleted successfully.")
                st.session_state.delete_confirm = False
                st.session_state.selected_expense_id = None
                st.session_state["force_refresh"] = True # Trigger refresh
                time.sleep(0.5) # Brief pause
                st.rerun() # Rerun to show updated report
            else:
                 st.error("Failed to delete expense from the database.")
    with cancel_col:
        if st.button("Cancel", key="cancel_delete"):
            st.session_state.delete_confirm = False
            st.session_state.selected_expense_id = None
            st.rerun() # Go back to the report view
"""

File: visuals.py
Location: streamlit\tabs\visuals.py
Summary: This Streamlit module visualizes expense data using Plotly charts. It loads metadata, fetches expenses, and prepares data for visualization. It provides a 2x2 grid of charts: pie (category proportion), bar (category totals), line (spending trend), and horizontal bar (top expense types). Filters and toggles enhance interactivity.
Code: """
# streamlit/tabs/visuals.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import json
import datetime
# Assuming db_utils is importable from streamlit/
from db_utils import fetch_all_expenses
from typing import Dict, Any, Optional
import logging
from pathlib import Path

# Define Metadata Path relative to the project root
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
METADATA_FILE_PATH = PROJECT_ROOT / "metadata" / "expense_metadata.json"

# Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

@st.cache_data
def load_metadata() -> Optional[Dict[str, Any]]:
    """Loads metadata from the project's metadata directory."""
    if not METADATA_FILE_PATH.is_file():
        logging.error(f"Metadata file not found at: {METADATA_FILE_PATH}")
        st.error(f"Critical application error: Metadata configuration file not found at {METADATA_FILE_PATH}. Please ensure it exists.")
        return None
    try:
        with open(METADATA_FILE_PATH, "r") as f:
            metadata = json.load(f)
            logging.info(f"Metadata loaded successfully from {METADATA_FILE_PATH}")
            return metadata
    except json.JSONDecodeError as e:
        logging.error(f"Error decoding JSON from {METADATA_FILE_PATH}: {e}", exc_info=True)
        st.error(f"Critical application error: Metadata file ({METADATA_FILE_PATH.name}) seems corrupted.")
        return None
    except Exception as e:
        logging.exception(f"Failed to load or parse metadata from {METADATA_FILE_PATH}: {e}")
        st.error("Critical application error: An unexpected error occurred while loading metadata.")
        return None

def get_common_layout_args(chart_title: str, show_legend: bool = False) -> Dict[str, Any]:
    """Generates common layout arguments for Plotly charts."""
    return {
        "title_text": chart_title,
        "title_font_size": 16, "title_x": 0.5,
        "margin": dict(l=20, r=20, t=50, b=80 if show_legend else 40),
        "legend": dict(orientation="h", yanchor="bottom", y=-0.3, xanchor="center", x=0.5),
        "hovermode": "closest",
        "showlegend": show_legend
    }

def render():
    """Renders the 'Visualizations' page with a 2x2 grid of charts."""
    st.subheader("Expense Visualizations")

    metadata = load_metadata()
    if metadata is None: return

    # --- Fetch Data ---
    df_all = fetch_all_expenses()
    if df_all.empty:
        st.info("No expense data available for visualization.")
        return

    # --- Prepare Data ---
    try:
        if not pd.api.types.is_datetime64_any_dtype(df_all['date']):
             df_all['date'] = pd.to_datetime(df_all['date'], errors='coerce')
             df_all.dropna(subset=['date'], inplace=True)

        if 'month' not in df_all.columns and 'date' in df_all.columns:
             df_all['month'] = df_all['date'].dt.strftime('%Y-%m') # Use 'month' consistently

        # Rename 'month' to 'YearMonth' for clarity if preferred, or just use 'month'
        if 'month' in df_all.columns and 'YearMonth' not in df_all.columns:
             df_all['YearMonth'] = df_all['month']

        # Check for required columns
        required_cols = ['YearMonth', 'category', 'amount', 'date', 'account', 'user', 'type', 'sub_category']
        if not all(col in df_all.columns for col in ['YearMonth', 'category', 'amount', 'date', 'account', 'user', 'type']):
             missing = [col for col in required_cols if col not in df_all.columns]
             st.error(f"Required columns missing for visualizations: {missing}")
             return

        min_date = df_all['date'].min().date()
        max_date = df_all['date'].max().date()
        all_months = ["All"] + sorted(df_all['YearMonth'].unique(), reverse=True)
        all_categories = ["All"] + sorted(list(metadata.get("categories", {}).keys()))
        all_users = ["All"] + sorted(list(set(metadata.get("User", {}).values())))
        all_accounts = ["All"] + sorted(metadata.get("Account", []))
    except Exception as e:
        st.error(f"Error preparing data or filter options: {e}")
        logging.exception("Error during data preparation in visuals tab.")
        return

    # --- Initialize Session State for Legends ---
    if 'legends' not in st.session_state:
        st.session_state.legends = {'pie': False, 'bar': False, 'line': False, 'top': False}

    # --- Layout for Charts ---
    st.markdown("#### Overview Charts")
    row1_col1, row1_col2 = st.columns(2)
    row2_col1, row2_col2 = st.columns(2)

    # --- Chart 1: Pie Chart ---
    with row1_col1:
        st.markdown("###### By Category (Proportion)")
        # --- ✅ Updated Expander Label ---
        with st.expander("Pie Chart Filters", expanded=False):
            pie_month = st.selectbox("Month", all_months, 0, key="pie_month_filter")
            pie_cats = st.multiselect("Category", all_categories, ["All"], key="pie_cat_filter")
            pie_accounts = st.multiselect("Account", all_accounts, ["All"], key="pie_account_filter")
            pie_users = st.multiselect("User", all_users, ["All"], key="pie_user_filter")

        if st.button("Toggle Legend - Pie", key="pie_legend_btn"):
            st.session_state.legends['pie'] = not st.session_state.legends['pie']

        # Filter Data
        pie_df = df_all.copy()
        if pie_month != "All": pie_df = pie_df[pie_df['YearMonth'] == pie_month]
        if "All" not in pie_cats: pie_df = pie_df[pie_df['category'].isin(pie_cats)]
        if "All" not in pie_accounts: pie_df = pie_df[pie_df['account'].isin(pie_accounts)]
        if "All" not in pie_users: pie_df = pie_df[pie_df['user'].isin(pie_users)]

        # Aggregate and Plot
        pie_data = pie_df.groupby('category')['amount'].sum().reset_index()
        if not pie_data.empty and pie_data['amount'].sum() > 0:
            fig_pie = px.pie(pie_data, values='amount', names='category', hole=0.4)
            fig_pie.update_traces(textposition='inside', textinfo='percent+label', hoverinfo='label+percent+value')
            fig_pie.update_layout(**get_common_layout_args("Spending by Category", st.session_state.legends['pie']))
            st.plotly_chart(fig_pie, use_container_width=True)
        elif not pie_df.empty:
             st.info("No spending in selected categories/filters for Pie Chart.")
        else:
             st.info("No data matches filters for Pie Chart.")

    # --- Chart 2: Bar Chart ---
    with row1_col2:
        st.markdown("###### By Category (Absolute)")
        with st.expander("Bar Chart Filters", expanded=False):
            # ... (Filter widgets remain the same) ...
            bar_start = st.date_input("Start Date", min_date, key="bar_start_filter")
            bar_end = st.date_input("End Date", max_date, key="bar_end_filter")
            bar_accounts = st.multiselect("Account", all_accounts, ["All"], key="bar_account_filter")
            bar_users = st.multiselect("User", all_users, ["All"], key="bar_user_filter")


        if st.button("Toggle Legend - Bar", key="bar_legend_btn"):
            st.session_state.legends['bar'] = not st.session_state.legends['bar']

        # Filter Data (Remains the same)
        if bar_start > bar_end:
            st.warning("Start date cannot be after end date for Bar Chart.")
            bar_df = pd.DataFrame()
        else:
             bar_df = df_all[(df_all['date'].dt.date >= bar_start) & (df_all['date'].dt.date <= bar_end)]
             if "All" not in bar_accounts: bar_df = bar_df[bar_df['account'].isin(bar_accounts)]
             if "All" not in bar_users: bar_df = bar_df[bar_df['user'].isin(bar_users)]

        # Aggregate and Plot
        bar_data = bar_df.groupby('category')['amount'].sum().reset_index()
        if not bar_data.empty and bar_data['amount'].sum() > 0:
            fig_bar = px.bar(bar_data, x='category', y='amount', color='category', text_auto='.2s')

            # --- ✅ Modify Layout Update ---
            layout_bar = get_common_layout_args("Total Spending by Category", st.session_state.legends['bar'])
            layout_bar["yaxis_title"] = "Amount (INR)"
            layout_bar["xaxis_title"] = "Category"
            layout_bar["xaxis"] = dict(
                categoryorder='total descending',
                tickangle=-90  # Force vertical labels
            )
            fig_bar.update_layout(**layout_bar)
            # --- End of Modification ---

            fig_bar.update_traces(textposition='outside')
            st.plotly_chart(fig_bar, use_container_width=True)
        elif not bar_df.empty:
             st.info("No spending in selected categories/filters for Bar Chart.")
        else:
             st.info("No data matches filters for Bar Chart (check dates?).")


    # --- Chart 3: Line Chart ---
    with row2_col1:
        st.markdown("###### Trend Over Time")
        # --- ✅ Updated Expander Label ---
        with st.expander("Line Chart Filters", expanded=False):
            line_start = st.date_input("Start Date", min_date, key="line_start_filter")
            line_end = st.date_input("End Date", max_date, key="line_end_filter")
            line_cats = st.multiselect("Category", all_categories, ["All"], key="line_cat_filter")
            line_accounts = st.multiselect("Account", all_accounts, ["All"], key="line_account_filter")
            line_users = st.multiselect("User", all_users, ["All"], key="line_user_filter")
            line_mode = st.radio("View", ["Daily", "Cumulative"], 0, horizontal=True, key="line_mode_filter")

        if st.button("Toggle Legend - Line", key="line_legend_btn"):
            st.session_state.legends['line'] = not st.session_state.legends['line']

        # Filter Data
        if line_start > line_end:
             st.warning("Start date cannot be after end date for Line Chart.")
             line_df = pd.DataFrame()
        else:
            line_df = df_all[(df_all['date'].dt.date >= line_start) & (df_all['date'].dt.date <= line_end)]
            if "All" not in line_cats: line_df = line_df[line_df['category'].isin(line_cats)]
            if "All" not in line_accounts: line_df = line_df[line_df['account'].isin(line_accounts)]
            if "All" not in line_users: line_df = line_df[line_df['user'].isin(line_users)]

        # Aggregate and Plot
        trend_data = line_df.groupby('date')['amount'].sum().reset_index().sort_values('date')
        fig_line = go.Figure()
        trace_added = False
        if not trend_data.empty:
            if line_mode == "Daily":
                fig_line.add_trace(go.Scatter(x=trend_data['date'], y=trend_data['amount'], mode='lines+markers', name='Daily Spend'))
                trace_added = True
            elif line_mode == "Cumulative":
                trend_data['cumulative'] = trend_data['amount'].cumsum()
                fig_line.add_trace(go.Scatter(x=trend_data['date'], y=trend_data['cumulative'], mode='lines+markers', name='Cumulative Spend', line=dict(dash='dot')))
                trace_added = True

        if trace_added:
             layout_line = get_common_layout_args(f"{line_mode} Spending Trend", st.session_state.legends['line'])
             layout_line["yaxis_title"] = "Amount (INR)"
             layout_line["xaxis_title"] = "Date"
             layout_line["xaxis"] = dict(rangeslider=dict(visible=True), type="date")
             layout_line["hovermode"] = "x unified"
             fig_line.update_layout(**layout_line)
             st.plotly_chart(fig_line, use_container_width=True)
        elif not line_df.empty:
             st.info("No spending in selected categories/filters for Line Chart.")
        else:
             st.info("No data matches filters for Line Chart (check dates?).")

    # --- Chart 4: Top 10 Expense Types (Horizontal Bar) ---
    with row2_col2:
        st.markdown("###### Top 10 Expense Types")
        # --- ✅ Updated Expander Label ---
        with st.expander("Top Expenses Filters", expanded=False): # Renamed for clarity
            top_start = st.date_input("Start Date", min_date, key="top_start_filter")
            top_end = st.date_input("End Date", max_date, key="top_end_filter")
            top_cats = st.multiselect("Category", all_categories, ["All"], key="top_cat_filter")
            top_accounts = st.multiselect("Account", all_accounts, ["All"], key="top_account_filter")
            top_users = st.multiselect("User", all_users, ["All"], key="top_user_filter")

        # Toggle Button (Optional, maybe less useful here)
        # if st.button("Toggle Legend##Top", key="top_legend_btn"):
        #    st.session_state.legends['top'] = not st.session_state.legends['top']

        # Filter Data
        if top_start > top_end:
             st.warning("Start date cannot be after end date for Top Expenses.")
             top_df = pd.DataFrame()
        else:
            top_df = df_all[(df_all['date'].dt.date >= top_start) & (df_all['date'].dt.date <= top_end)]
            if "All" not in top_cats: top_df = top_df[top_df['category'].isin(top_cats)]
            if "All" not in top_accounts: top_df = top_df[top_df['account'].isin(top_accounts)]
            if "All" not in top_users: top_df = top_df[top_df['user'].isin(top_users)]

        # Aggregate by 'Type' and get top 10
        if not top_df.empty and 'type' in top_df.columns:
             # Handle potential NaN/empty types before grouping
            top_df_cleaned = top_df.dropna(subset=['type'])
            top_df_cleaned = top_df_cleaned[top_df_cleaned['type'].str.strip() != '']
            if not top_df_cleaned.empty:
                top_data = top_df_cleaned.groupby('type')['amount'].sum().reset_index().nlargest(10, 'amount').sort_values('amount', ascending=True)
                if not top_data.empty:
                    fig_top = px.bar(top_data, y='type', x='amount', orientation='h', text='amount', color='type', color_discrete_sequence=px.colors.qualitative.Pastel) # Example color sequence
                    layout_top = get_common_layout_args("Top 10 Expense Types by Amount", show_legend=False)
                    layout_top["xaxis_title"] = "Total Amount (INR)"
                    layout_top["yaxis_title"] = ""
                    layout_top["yaxis"] = {'categoryorder':'total ascending'}
                    fig_top.update_layout(**layout_top)
                    fig_top.update_traces(texttemplate="₹%{x:,.0f}", textposition="outside")
                    st.plotly_chart(fig_top, use_container_width=True)
                else:
                     st.info("No spending data found for 'Type' aggregation with current filters.")
            else:
                 st.info("No valid 'Type' entries found after cleaning filters.")
        elif not top_df.empty:
             st.info("No 'type' column found or no data after filtering for Top Expenses.")
        else:
             st.info("No data matches filters for Top Expenses (check dates?).")
"""

File: __init__.py
Location: streamlit\tabs\__init__.py
Summary: Please provide the content of the file you would like summarized.
Code: """

"""

