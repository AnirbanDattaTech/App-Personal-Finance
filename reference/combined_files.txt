# Contents of create_db.py
import sqlite3
import pandas as pd
import uuid

# Load CSV
df = pd.read_csv("dummy_expenses.csv")

# Normalize column names
df.columns = (
    df.columns
    .str.strip()
    .str.lower()
    .str.replace("-", "_")
    .str.replace(" ", "_")
)

# Validate and format date
df['date'] = pd.to_datetime(df['date'], errors='coerce').dt.strftime('%Y-%m-%d')

# Add UUID for each row
df['id'] = [str(uuid.uuid4()) for _ in range(len(df))]

# Save to SQLite
conn = sqlite3.connect("expenses.db")
df.to_sql("expenses", conn, if_exists="replace", index=False)
conn.close()

print("✅ Database 'expenses.db' created from CSV!")


# Contents of db_utils.py
# db_utils.py
import sqlite3
import pandas as pd
from uuid import uuid4

DB_NAME = "expenses.db"

def get_connection():
    return sqlite3.connect(DB_NAME, check_same_thread=False)

def fetch_all_expenses():
    conn = get_connection()
    df = pd.read_sql("SELECT * FROM expenses", conn)
    conn.close()
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    return df

def insert_expense(data):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
    INSERT INTO expenses (id, date, account, category, sub_category, type, user, amount)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
""", (str(uuid4()), data['date'], data['account'], data['category'], data['sub_category'],
      data['type'], data['user'], data['amount']))
    conn.commit()
    conn.close()

def fetch_last_expenses(n=10):
    conn = get_connection()
    df = pd.read_sql(f"SELECT * FROM expenses ORDER BY date DESC LIMIT {n}", conn)
    conn.close()
    df['date'] = pd.to_datetime(df['date'], errors='coerce')
    return df


# Contents of main.py
# main.py
import streamlit as st
from tabs import add_expense, reports, visuals
from style_utils import load_css
import os # Import os for file path checking

st.set_page_config(
    layout="wide",
    page_title="Personal Expense Tracker",
    page_icon="💰"
)

# Load CSS styles
load_css()

# Navigation in sidebar
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to",
    ["Add Expenses", "Reports", "Visualizations"],
    label_visibility="collapsed"
)

st.sidebar.markdown("---") # Add a separator

# --- Add Data Backup Button ---
st.sidebar.header("Data Management")
DB_FILE = "expenses.db"
if os.path.exists(DB_FILE):
    with open(DB_FILE, "rb") as fp:
        st.sidebar.download_button(
            label="Download Data Backup (.db)",
            data=fp,
            file_name="expenses_backup.db",
            mime="application/octet-stream",
            help="Download the entire SQLite database file."
        )
else:
    st.sidebar.warning("Database file not found.")
# --- End Data Backup Button ---


# Render selected page
if page == "Add Expenses":
    add_expense.render()
elif page == "Reports":
    reports.render()
elif page == "Visualizations":
    visuals.render()

# Contents of style_utils.py
# style_utils.py
import streamlit as st

def load_css(file_path: str = "styles.css"):
    with open(file_path, "r") as f:
        css = f.read()
        st.markdown(f"<style>{css}</style>", unsafe_allow_html=True)


# Contents of reference/plotly_charts.py
# --- Import Libraries ---
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.io as pio

# --- Configuration (Optional) ---
pio.templates.default = "plotly_white"

print("--- Generating Sample Data ---")
# --- Generate Sample Data ---
dates = pd.date_range(start='2023-01-01', end='2023-01-31', freq='D')
# Using a different seed just to show it works, can revert to 42
np.random.seed(101)
values = np.random.randint(50, 150, size=len(dates))
df = pd.DataFrame({'Date': dates, 'DailyValue': values})

print("--- Calculating Cumulative Values ---")
# --- Calculate Cumulative Values ---
df['CumulativeValue'] = df['DailyValue'].cumsum()

print("\nSample Data with Cumulative Values (First 5 Rows):")
print(df.head())
print("\n" + "="*40 + "\n")

# --- Create Figure with Secondary Y-axis ---
print("--- Creating Combined Chart with Dual Y-Axes ---")

# Initialize figure
fig = go.Figure()

# --- Add Trace 1: Daily Value (Primary Y-axis - Left) ---
fig.add_trace(go.Scatter(
    x=df['Date'],
    y=df['DailyValue'],
    name='Daily Value',
    mode='lines+markers',
    marker=dict(size=5),
    line=dict(width=2),
    yaxis='y1' # Assign to primary y-axis
))

# --- Add Trace 2: Cumulative Value (Secondary Y-axis - Right) ---
fig.add_trace(go.Scatter(
    x=df['Date'],
    y=df['CumulativeValue'],
    name='Cumulative Value',
    mode='lines+markers',
    marker=dict(size=5),
    line=dict(width=2, dash='dash'),
    yaxis='y2' # Assign to secondary y-axis
))

# --- Update Layout for Dual Axes ---
fig.update_layout(
    title_text="Daily and Cumulative Values Over Time",
    xaxis_title="Date",

    # Configure Primary Y-axis (Left)
    yaxis=dict(
        # CORRECTED: title is a dict, font settings go inside 'font' key
        title=dict(
            text="Daily Value",
            font=dict(color="#1f77b4") # Color applied to title font
        ),
        tickfont=dict(color="#1f77b4"), # Tick labels color
        side='left'
    ),

    # Configure Secondary Y-axis (Right)
    yaxis2=dict(
        # CORRECTED: title is a dict, font settings go inside 'font' key
        title=dict(
            text="Cumulative Value",
            font=dict(color="#ff7f0e") # Color applied to title font
        ),
        tickfont=dict(color="#ff7f0e"), # Tick labels color
        side='right',
        overlaying='y',
        showgrid=False,
    ),

    legend_title_text="Metric",
    legend=dict(
        orientation="h",
        yanchor="bottom",
        y=1.02,
        xanchor="right",
        x=1
    )
)

print("Displaying Combined Chart... (Check your browser)")
fig.show() # Display interactively

# --- Saving Static Image using Kaleido ---
print("\n--- Attempting to save combined chart as static PNG (using Kaleido) ---")
try:
    combined_chart_filename = "combined_daily_cumulative_chart.png"
    fig.write_image(combined_chart_filename, width=1000, height=500)
    print(f"Successfully saved: {combined_chart_filename}")

except ValueError as e:
     print(f"\nERROR: Could not save PNG image.")
     print(f"Please ensure Kaleido is installed correctly: pip install -U kaleido")
     print(f"Error details: {e}")
except Exception as e:
    print(f"\nAn unexpected error occurred during image saving: {e}")

print("\n--- Script Finished ---")

# Contents of reference/vis_backup.py
# tabs/visuals.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from db_utils import fetch_all_expenses
import json
import datetime # Import datetime for date calculations

def load_metadata():
    """Loads metadata from the JSON file."""
    try:
        with open("expense_metadata.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        st.error("Error: expense_metadata.json not found. Please ensure the file exists.")
        return None
    except json.JSONDecodeError:
        st.error("Error: Could not decode expense_metadata.json. Please check its format.")
        return None

def render():
    """Renders the Visualizations tab."""
    metadata = load_metadata()
    if metadata is None:
        return

    df_all = fetch_all_expenses() # Load all data once
    if df_all.empty:
        st.warning("No expense data found to display visualizations.")
        return

    # Ensure 'date' is datetime and get overall date range
    df_all['date'] = pd.to_datetime(df_all['date'])
    min_date_overall = df_all['date'].min().date() # Get date part
    max_date_overall = df_all['date'].max().date() # Get date part

    # Add 'month' column for Pie Chart filtering
    df_all['month'] = df_all['date'].dt.strftime('%Y-%m')

    st.subheader("Expense Visualizations")

    # ----- PIE CHART -----
    st.markdown("### Category-wise Expense Distribution")
    with st.expander("Pie Chart Filters", expanded=True):
        # --- Use separate column sets for alignment ---
        # Row 1 of filters
        col_pie_r1_1, col_pie_r1_2 = st.columns(2)
        with col_pie_r1_1:
            pie_month = st.selectbox(
                "Select Month",
                ["All"] + sorted(df_all['month'].unique(), reverse=True),
                index=0,
                key="pie_month_select",
                help="Filter expenses by month for the pie chart."
            )
        with col_pie_r1_2:
            pie_accounts = st.multiselect(
                "Filter by Account",
                ["All"] + metadata["Account"],
                default=["All"],
                key="pie_account_select"
            )

        # Row 2 of filters
        col_pie_r2_1, col_pie_r2_2 = st.columns(2)
        with col_pie_r2_1:
            pie_categories = st.multiselect(
                "Filter by Category",
                ["All"] + list(metadata["categories"].keys()),
                default=["All"],
                key="pie_category_select"
            )
        with col_pie_r2_2:
            pie_users = st.multiselect(
                "Filter by User",
                ["All"] + list(set(metadata["User"].values())),
                default=["All"],
                key="pie_user_select"
            )
        # --- End separate column sets ---

        # Checkbox remains below the filter grid
        show_pie_legend = st.checkbox(
            "Show Pie Chart Legend",
            value=True,
            key="show_pie_legend_cb",
            help="Toggle the visibility of the category legend."
        )

    # Filter data for pie chart (logic remains the same)
    pie_df = df_all.copy()
    if pie_month != "All":
        pie_df = pie_df[pie_df['month'] == pie_month]
    if "All" not in pie_accounts:
        pie_df = pie_df[pie_df['account'].isin(pie_accounts)]
    if "All" not in pie_categories:
        pie_df = pie_df[pie_df['category'].isin(pie_categories)]
    if "All" not in pie_users:
        pie_df = pie_df[pie_df['user'].isin(pie_users)]

    if pie_df.empty:
        st.warning("No data matches the selected filters for the Pie Chart.")
    else:
        pie_data = pie_df.groupby('category')['amount'].sum().reset_index()
        fig1 = px.pie(
            pie_data, values='amount', names='category',
            title=f"Expenses by Category ({pie_month})", hole=0.4,
            labels={'amount': 'Total Amount', 'category': 'Category'}
        )
        fig1.update_traces(
            textposition='inside', textinfo='percent+label',
            hovertemplate="<b>%{label}</b><br>Amount: ₹%{value:,.2f}<br>Percentage: %{percent}<extra></extra>"
        )
        fig1.update_layout(
            showlegend=show_pie_legend, legend_title_text='Categories',
            legend=dict(orientation="h", yanchor="bottom", y=-0.2, xanchor="center", x=0.5)
        )
        st.plotly_chart(fig1, use_container_width=True)


    # ----- LINE CHART -----
    # (Line Chart section remains unchanged)
    st.markdown("---")
    st.markdown("### Expense Trend Over Time")
    with st.expander("Line Chart Filters", expanded=True):
        col_date1, col_date2 = st.columns(2)
        with col_date1:
            start_date = st.date_input(
                "Start Date", value=min_date_overall,
                min_value=min_date_overall, max_value=max_date_overall,
                key="line_start_date"
            )
        with col_date2:
            end_date = st.date_input(
                "End Date", value=max_date_overall,
                min_value=min_date_overall, max_value=max_date_overall,
                key="line_end_date"
            )

        if start_date > end_date:
            st.error("Error: Start date cannot be after end date.")
            line_df_filtered = pd.DataFrame()
        else:
            line_df_filtered = df_all[
                (df_all['date'].dt.date >= start_date) &
                (df_all['date'].dt.date <= end_date)
            ].copy()

            col_filter1, col_filter2, col_filter3 = st.columns(3)
            with col_filter1:
                line_accounts = st.multiselect(
                    "Filter by Account ", ["All"] + metadata["Account"], default=["All"], key="line_account_select"
                )
            with col_filter2:
                line_categories = st.multiselect(
                    "Filter by Category ", ["All"] + list(metadata["categories"].keys()), default=["All"], key="line_category_select"
                )
            with col_filter3:
                 line_users = st.multiselect(
                    "Filter by User ", ["All"] + list(set(metadata["User"].values())), default=["All"], key="line_user_select"
                )

            if "All" not in line_accounts:
                line_df_filtered = line_df_filtered[line_df_filtered['account'].isin(line_accounts)]
            if "All" not in line_categories:
                line_df_filtered = line_df_filtered[line_df_filtered['category'].isin(line_categories)]
            if "All" not in line_users:
                line_df_filtered = line_df_filtered[line_df_filtered['user'].isin(line_users)]

        chart_mode = st.radio(
            "Select Trend View", ["Daily", "Cumulative"], index=0,
            key="chart_mode_select", horizontal=True,
            help="Choose to view daily spending or cumulative spending."
        )

    if line_df_filtered.empty:
        st.warning("No data matches the selected date range and filters for the Line Chart.")
    else:
        trend_data = line_df_filtered.groupby('date')['amount'].sum().reset_index().sort_values('date')
        fig2 = go.Figure()
        chart_title = f'{chart_mode} Expense Trend ({start_date.strftime("%d %b %Y")} to {end_date.strftime("%d %b %Y")})'

        if chart_mode == "Daily":
            fig2.add_trace(go.Scatter(
                x=trend_data['date'], y=trend_data['amount'], name='Daily Expenses', mode='lines+markers',
                line=dict(color='#1f77b4', width=2), marker=dict(size=4),
                hovertemplate="<b>%{x|%Y-%m-%d}</b><br>Daily: ₹%{y:,.2f}<extra></extra>"
            ))
            yaxis_title = 'Daily Amount (INR)'
        elif chart_mode == "Cumulative":
            trend_data['cumulative_amount'] = trend_data['amount'].cumsum()
            fig2.add_trace(go.Scatter(
                x=trend_data['date'], y=trend_data['cumulative_amount'], name='Cumulative Expenses', mode='lines+markers',
                line=dict(color='#ff7f0e', width=2, dash='dot'), marker=dict(size=4),
                hovertemplate="<b>%{x|%Y-%m-%d}</b><br>Cumulative: ₹%{y:,.2f}<extra></extra>"
            ))
            yaxis_title = 'Cumulative Amount (INR)'

        fig2.update_layout(
            title=chart_title, xaxis_title='Date', yaxis_title=yaxis_title,
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            margin=dict(l=40, r=40, t=60, b=40),
            xaxis=dict(rangeslider=dict(visible=True), type="date")
        )
        st.plotly_chart(fig2, use_container_width=True)

# Contents of tabs/add_expense.py
# tabs/add_expense.py
import streamlit as st
import pandas as pd
from db_utils import insert_expense, fetch_last_expenses
import json
import datetime # Import datetime

def load_metadata():
    # ... (load_metadata function remains the same) ...
     with open("expense_metadata.json", "r") as f:
        return json.load(f)

def render():
    metadata = load_metadata()
    st.subheader("Add New Expense")

    # --- Default to Today's Date ---
    date = st.date_input(
        "Date of Expense",
        value=datetime.date.today(), # Set default value to today
        help="Format: YYYY-MM-DD"
    )
    # --- End Default Date ---

    # Get category first
    all_categories = sorted(list(metadata["categories"].keys()))
    category = st.selectbox("Category", all_categories)
    available_subcategories = sorted(metadata["categories"].get(category, [])) # Ensure sorted

    # Expense form
    with st.form("expense_form", clear_on_submit=True): # Clear form after successful submission
        col1, col2 = st.columns(2)

        with col1:
            account = st.selectbox("Account", metadata["Account"])
            sub_category = st.selectbox("Sub-category", available_subcategories) # Uses dynamic options

        with col2:
            type_ = st.text_input("Type (Description)", max_chars=60) # Increased chars slightly
            user = metadata["User"].get(account, "Unknown") # Use .get for safety
            amount = st.number_input("Amount (INR)", min_value=0.01, format="%.2f", step=10.0) # Min 0.01, added step

        submitted = st.form_submit_button("Add Expense")
        if submitted:
            # --- Use st.toast for feedback ---
            if not type_:
                st.toast("⚠️ Please enter a valid 'Type' (Description).", icon="⚠️")
            elif amount <= 0.0:
                st.toast("⚠️ Amount must be greater than zero.", icon="⚠️")
            # Ensure sub_category is valid for the selected category (redundant check, but safe)
            elif sub_category not in metadata["categories"].get(category, []):
                 st.toast(f"❌ Error: '{sub_category}' is not a valid sub-category for '{category}'.", icon="❌")
            else:
                try:
                    insert_expense({
                        "date": date.strftime("%Y-%m-%d"),
                        "account": account,
                        "category": category,
                        "sub_category": sub_category,
                        "type": type_,
                        "user": user,
                        "amount": amount
                    })
                    st.toast(f"✅ Expense added successfully!", icon="✅")
                    # Don't clear form manually, clear_on_submit=True handles it
                except Exception as e:
                    st.toast(f"❌ Error adding expense: {e}", icon="❌")
            # --- End st.toast ---

    # Show recent entries section
    st.markdown("---")
    st.subheader("Last 10 Expenses")
    try:
        df_recent = fetch_last_expenses(10)
        if df_recent.empty:
            st.info("No recent expenses to display.")
        else:
            display_df_recent = df_recent.drop(columns=["id"]).rename(columns={
                "date": "Date", "account": "Account", "category": "Category",
                "sub_category": "Sub Category", "type": "Type", "user": "User", "amount": "Amount"
            })
            st.dataframe(
                display_df_recent.style.format({'Date': '{:%Y-%m-%d}', 'Amount': '₹{:.2f}'}), # Format date
                use_container_width=True,
                height=380, # Adjusted height slightly
                hide_index=True
            )
    except Exception as e:
        st.error(f"Error loading recent expenses: {e}")

# Contents of tabs/reports.py
# tabs/reports.py
import streamlit as st
import pandas as pd
from db_utils import fetch_all_expenses
import json

def load_metadata():
    # ... (load_metadata function remains the same) ...
    with open("expense_metadata.json", "r") as f:
        return json.load(f)

@st.cache_data # Cache the conversion to prevent re-running on every interaction
def convert_df_to_csv(df):
  # IMPORTANT: Cache the conversion to prevent computation on every rerun
  return df.to_csv(index=False).encode('utf-8')

def render():
    metadata = load_metadata()
    df_all = fetch_all_expenses()
    if df_all.empty:
        st.warning("No expense data available.")
        return # Exit early if no data

    df_all['date'] = pd.to_datetime(df_all['date']) # Ensure date is datetime
    df_all['month'] = df_all['date'].dt.strftime('%Y-%m')

    st.subheader("Expense Report")

    with st.expander("Filter Options", expanded=True):
        # ... (filtering widgets remain the same) ...
        col1, col2, col3 = st.columns(3)
        with col1:
            months = st.multiselect("Month", ["All"] + sorted(df_all['month'].unique(), reverse=True), default=["All"])
            accounts = st.multiselect("Account", ["All"] + metadata["Account"], default=["All"])
        with col2:
            categories = st.multiselect("Category", ["All"] + sorted(list(metadata["categories"].keys())), default=["All"])
            users = st.multiselect("User", ["All"] + sorted(list(set(metadata["User"].values()))), default=["All"])
        with col3:
            if "All" in categories:
                sub_cats_options = sorted(list(set(sub for subs in metadata["categories"].values() for sub in subs)))
            else:
                sub_cats_options = sorted(list(set(sub for cat in categories for sub in metadata["categories"].get(cat, []))))
            subcategories = st.selectbox("Sub-category", ["All"] + sub_cats_options, key="report_subcat_select")

    # Apply filters
    df_filtered = df_all.copy()
    if "All" not in months: df_filtered = df_filtered[df_filtered['month'].isin(months)]
    if "All" not in accounts: df_filtered = df_filtered[df_filtered['account'].isin(accounts)]
    if "All" not in categories: df_filtered = df_filtered[df_filtered['category'].isin(categories)]
    if subcategories != "All": df_filtered = df_filtered[df_filtered['sub_category'] == subcategories]
    if "All" not in users: df_filtered = df_filtered[df_filtered['user'].isin(users)]

    total = df_filtered['amount'].sum()
    st.markdown(f"### Total Expense (Filtered): ₹{total:,.2f}")
    st.markdown("---") # Add a separator before the table

    # Prepare dataframe for display (sort before displaying)
    display_df = df_filtered.drop(columns=["id", "month"], errors='ignore').rename(columns={
        "date": "Date", "account": "Account", "category": "Category",
        "sub_category": "Sub Category", "type": "Type", "user": "User", "amount": "Amount"
    }).sort_values("Date", ascending=False)

    # Display the filtered data table
    if not display_df.empty:
        st.dataframe(
            display_df.style.format({'Date': '{:%Y-%m-%d}', 'Amount': '₹{:.2f}'}),
            use_container_width=True,
            height=400,
            hide_index=True
        )
    else:
        st.info("No data matches the current filters.") # Show info if table is empty

    # --- Add Export Button BELOW table ---
    if not display_df.empty:
        st.markdown("---") # Optional separator above button
        csv_data = convert_df_to_csv(display_df) # Use the cached function

        st.download_button(
            label="Export Filtered Data to CSV",
            data=csv_data,
            file_name='filtered_expenses.csv',
            mime='text/csv',
            help="Download the currently filtered expense report as a CSV file."
        )
    # --- End Export Button ---

# Contents of tabs/visuals.py
# tabs/visuals.py
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import json
import datetime

# Ensure fetch_all_expenses is imported
from db_utils import fetch_all_expenses

def load_metadata():
    """Loads metadata from the JSON file."""
    try:
        with open("expense_metadata.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        st.error("Error: expense_metadata.json not found. Please ensure the file exists.")
        return None
    except json.JSONDecodeError:
        st.error("Error: Could not decode expense_metadata.json. Please check its format.")
        return None

def render():
    """Renders the Visualizations tab."""
    st.subheader("Expense Visualizations")

    metadata = load_metadata()
    if metadata is None:
        st.error("Metadata could not be loaded. Cannot display visualizations.")
        return

    df_all = fetch_all_expenses()
    if df_all.empty:
        st.warning("No expense data found to display visualizations.")
        return

    # --- Data Preprocessing ---
    df_all['date'] = pd.to_datetime(df_all['date'])
    df_all['YearMonth'] = df_all['date'].dt.strftime('%Y-%m') # For monthly grouping/filtering

    # Prepare lists for filters, handle empty df case
    if df_all.empty:
         min_date_overall = datetime.date.today()
         max_date_overall = datetime.date.today()
         all_months = []
         all_categories = []
         all_users = list(set(metadata.get("User", {}).values())) if metadata.get("User") else []
         all_accounts = metadata.get("Account", [])
    else:
        min_date_overall = df_all['date'].min().date()
        max_date_overall = df_all['date'].max().date()
        all_months = sorted(df_all['YearMonth'].unique(), reverse=True)
        all_categories = sorted(list(metadata.get("categories", {}).keys())) # Sort categories alphabetically
        all_users = sorted(list(set(metadata.get("User", {}).values())))
        all_accounts = metadata.get("Account", [])

    # --- Create 2x2 Grid ---
    col1, col2 = st.columns(2)
    col3, col4 = st.columns(2)

    # --- Chart 1: Pie Chart (Top-Left) ---
    with col1:
        st.markdown("#### By Category (Proportion)")
        # FIXED Expander Label
        with st.expander("Filters", expanded=False): # Label is just "Filters"
            # Filters organized in grid within expander
            f_col1, f_col2 = st.columns(2)
            with f_col1:
                pie_month = st.selectbox(
                    "Month", ["All"] + all_months, index=0, key="pie_month_select",
                    help="Filter expenses by month for this chart."
                )
                pie_categories = st.multiselect(
                    "Category", ["All"] + all_categories, default=["All"], key="pie_category_select",
                     help="Filter expenses by category for this chart."
                )
            with f_col2:
                pie_accounts = st.multiselect(
                    "Account", ["All"] + all_accounts, default=["All"], key="pie_account_select",
                     help="Filter expenses by account for this chart."
                )
                pie_users = st.multiselect(
                    "User", ["All"] + all_users, default=["All"], key="pie_user_select",
                    help="Filter expenses by user for this chart."
                )
            # Removed the legend checkbox

        # Filter data specifically for Pie Chart
        pie_df = df_all.copy()
        if pie_month != "All": pie_df = pie_df[pie_df['YearMonth'] == pie_month]
        if "All" not in pie_accounts: pie_df = pie_df[pie_df['account'].isin(pie_accounts)]
        if "All" not in pie_categories: pie_df = pie_df[pie_df['category'].isin(pie_categories)]
        if "All" not in pie_users: pie_df = pie_df[pie_df['user'].isin(pie_users)]

        if pie_df.empty:
            st.info("No data for selected Pie Chart filters.", icon="ℹ️") # Changed to info
        else:
            pie_data = pie_df.groupby('category')['amount'].sum().reset_index()
            # Filter out zero/negative amounts if any, as they break pie charts
            pie_data = pie_data[pie_data['amount'] > 0]
            if pie_data.empty:
                st.info("No positive spending data for selected Pie Chart filters.", icon="ℹ️")
            else:
                fig1 = px.pie(
                    pie_data, values='amount', names='category',
                    title=f"Category Spend ({pie_month})", hole=0.4,
                    labels={'amount': 'Total', 'category': 'Category'}
                )
                fig1.update_traces(
                    textposition='inside',
                    textinfo='percent+label', # Show label and percent inside
                    hovertemplate="<b>%{label}</b><br>Amount: ₹%{value:,.0f}<br>(%{percent})<extra></extra>",
                    insidetextorientation='radial' # Adjust text orientation
                )
                fig1.update_layout(
                    showlegend=False, # REMOVED Legend
                    margin=dict(l=10, r=10, t=40, b=10), # Adjusted top margin slightly
                    title_font_size=16,
                    title_x=0.5
                )
                st.plotly_chart(fig1, use_container_width=True)

    # --- Chart 2: Category Bar Chart (Top-Right) ---
    with col2:
        st.markdown("#### By Category (Absolute)")
        # FIXED Expander Label
        with st.expander("Filters", expanded=False):
             f_col1, f_col2 = st.columns(2)
             with f_col1:
                 cat_bar_start_date = st.date_input(
                    "Start Date", value=min_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                    key="cat_bar_start_date"
                 )
                 cat_bar_accounts = st.multiselect(
                    "Account", ["All"] + all_accounts, default=["All"], key="cat_bar_account_select"
                 )
             with f_col2:
                 cat_bar_end_date = st.date_input(
                    "End Date", value=max_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                    key="cat_bar_end_date"
                 )
                 cat_bar_users = st.multiselect(
                    "User", ["All"] + all_users, default=["All"], key="cat_bar_user_select"
                 )

        # Filter data specifically for Category Bar Chart
        cat_bar_df = df_all.copy()
        if cat_bar_start_date <= cat_bar_end_date:
            cat_bar_df = cat_bar_df[
                (cat_bar_df['date'].dt.date >= cat_bar_start_date) &
                (cat_bar_df['date'].dt.date <= cat_bar_end_date)
            ]
            if "All" not in cat_bar_accounts: cat_bar_df = cat_bar_df[cat_bar_df['account'].isin(cat_bar_accounts)]
            if "All" not in cat_bar_users: cat_bar_df = cat_bar_df[cat_bar_df['user'].isin(cat_bar_users)]
        else:
            st.warning("Invalid date range selected for Category Bar Chart.", icon="⚠️")
            cat_bar_df = pd.DataFrame()

        if cat_bar_df.empty:
            st.info("No data for selected Category Bar filters.", icon="ℹ️")
        else:
            cat_bar_data = cat_bar_df.groupby('category')['amount'].sum().reset_index()
            # Filter out zero/negative amounts
            cat_bar_data = cat_bar_data[cat_bar_data['amount'] > 0].sort_values('amount', ascending=False)
            if cat_bar_data.empty:
                st.info("No positive spending data for selected Category Bar filters.", icon="ℹ️")
            else:
                fig2 = px.bar(
                    cat_bar_data,
                    x='category',
                    y='amount',
                    color='category', # ADDED Color mapping for multicolour
                    title=f"Category Totals ({cat_bar_start_date.strftime('%d%b')} - {cat_bar_end_date.strftime('%d%b%y')})",
                    labels={'amount': 'Total Amount (INR)', 'category': 'Category'}
                )
                fig2.update_layout(
                    showlegend=False, # Hide legend as colors match x-axis labels
                    xaxis_title=None, yaxis_title="Total (INR)",
                    margin=dict(l=10, r=10, t=40, b=10),
                    title_font_size=16, title_x=0.5,
                    xaxis={'categoryorder':'total descending'}
                )
                fig2.update_traces(
                    hovertemplate="<b>%{x}</b><br>Total: ₹%{y:,.0f}<extra></extra>"
                )
                st.plotly_chart(fig2, use_container_width=True)

    # --- Chart 3: Line Chart (Bottom-Left) ---
    with col3:
        st.markdown("#### Trend Over Time")
        # FIXED Expander Label
        with st.expander("Filters", expanded=False):
            f_col1, f_col2 = st.columns(2)
            with f_col1:
                line_start_date = st.date_input(
                    "Start Date", value=min_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                    key="line_start_date"
                )
                line_categories = st.multiselect(
                    "Category", ["All"] + all_categories, default=["All"], key="line_category_select"
                )
                line_chart_mode = st.radio(
                     "View", ["Daily", "Cumulative"], index=0, key="line_chart_mode_select", horizontal=True
                )
            with f_col2:
                line_end_date = st.date_input(
                    "End Date", value=max_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                    key="line_end_date"
                )
                line_accounts = st.multiselect(
                    "Account", ["All"] + all_accounts, default=["All"], key="line_account_select"
                )
                line_users = st.multiselect(
                    "User", ["All"] + all_users, default=["All"], key="line_user_select"
                )

        # Filter data specifically for Line Chart
        line_df_filtered = pd.DataFrame()
        if line_start_date > line_end_date:
            st.error("Error: Start date cannot be after end date for Line Chart.", icon="🚨")
        else:
            line_df_filtered = df_all[
                (df_all['date'].dt.date >= line_start_date) &
                (df_all['date'].dt.date <= line_end_date)
            ].copy()

            if not line_df_filtered.empty:
                if "All" not in line_accounts: line_df_filtered = line_df_filtered[line_df_filtered['account'].isin(line_accounts)]
                if "All" not in line_categories: line_df_filtered = line_df_filtered[line_df_filtered['category'].isin(line_categories)]
                if "All" not in line_users: line_df_filtered = line_df_filtered[line_df_filtered['user'].isin(line_users)]

        if line_df_filtered.empty:
             if line_start_date <= line_end_date: # Only show warning if date range was valid
                 st.info("No data for selected Line Chart filters.", icon="ℹ️")
        else:
            trend_data = line_df_filtered.groupby('date')['amount'].sum().reset_index().sort_values('date')
            # Ensure no zero/negative days affect cumulative sum if needed (usually okay for line)
            # trend_data = trend_data[trend_data['amount'] > 0] # Optional: only plot days with spending
            if trend_data.empty:
                 st.info("No spending data for selected Line Chart filters.", icon="ℹ️")
            else:
                fig3 = go.Figure()
                chart_title = f'{line_chart_mode} Trend ({line_start_date.strftime("%d%b")} - {line_end_date.strftime("%d%b%y")})'
                yaxis_title = f'{line_chart_mode} Amount (INR)'

                if line_chart_mode == "Daily":
                    fig3.add_trace(go.Scatter(
                        x=trend_data['date'], y=trend_data['amount'], name='Daily', mode='lines+markers',
                        line=dict(width=2), marker=dict(size=4),
                        hovertemplate="<b>%{x|%d %b %Y}</b><br>Daily: ₹%{y:,.0f}<extra></extra>"
                    ))
                elif line_chart_mode == "Cumulative":
                    trend_data['cumulative_amount'] = trend_data['amount'].cumsum()
                    fig3.add_trace(go.Scatter(
                        x=trend_data['date'], y=trend_data['cumulative_amount'], name='Cumulative', mode='lines+markers',
                        line=dict(width=2, dash='dot'), marker=dict(size=4),
                        hovertemplate="<b>%{x|%d %b %Y}</b><br>Cumulative: ₹%{y:,.0f}<extra></extra>"
                    ))

                fig3.update_layout(
                    title=chart_title, title_font_size=16, title_x=0.5,
                    xaxis_title=None, yaxis_title=yaxis_title,
                    hovermode="x unified", showlegend=False,
                    margin=dict(l=10, r=10, t=40, b=10),
                    xaxis=dict(rangeslider=dict(visible=True), type="date")
                )
                st.plotly_chart(fig3, use_container_width=True)

    # --- Chart 4: Sub-category Treemap (Bottom-Right) ---
    with col4:
        st.markdown("#### Sub-Category Breakdown")
        # FIXED Expander Label
        with st.expander("Filters", expanded=False):
            # Filter for the parent category (REQUIRED for this chart)
            treemap_parent_category = st.selectbox(
                "Select Category to Break Down",
                all_categories, # Must select one category
                index=all_categories.index("Grocery") if "Grocery" in all_categories else 0, # Default to Grocery or first category
                key="treemap_parent_select"
            )
            st.markdown("---") # Separator

            # Other standard filters
            f_col1, f_col2 = st.columns(2)
            with f_col1:
                treemap_start_date = st.date_input(
                   "Start Date", value=min_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                   key="treemap_start_date"
                )
                treemap_accounts = st.multiselect(
                   "Account", ["All"] + all_accounts, default=["All"], key="treemap_account_select"
                )
            with f_col2:
                treemap_end_date = st.date_input(
                   "End Date", value=max_date_overall, min_value=min_date_overall, max_value=max_date_overall,
                   key="treemap_end_date"
                )
                treemap_users = st.multiselect(
                   "User", ["All"] + all_users, default=["All"], key="treemap_user_select"
                )

        # Filter data specifically for Treemap
        treemap_df = df_all.copy()
        # Apply parent category filter first
        treemap_df = treemap_df[treemap_df['category'] == treemap_parent_category]

        # Apply other filters
        if treemap_start_date <= treemap_end_date:
            treemap_df = treemap_df[
                (treemap_df['date'].dt.date >= treemap_start_date) &
                (treemap_df['date'].dt.date <= treemap_end_date)
            ]
            if "All" not in treemap_accounts: treemap_df = treemap_df[treemap_df['account'].isin(treemap_accounts)]
            if "All" not in treemap_users: treemap_df = treemap_df[treemap_df['user'].isin(treemap_users)]
        else:
            st.warning("Invalid date range selected for Treemap.", icon="⚠️")
            treemap_df = pd.DataFrame()

        if treemap_df.empty:
            st.info(f"No '{treemap_parent_category}' data for selected Treemap filters.", icon="ℹ️")
        else:
            treemap_data = treemap_df.groupby('sub_category')['amount'].sum().reset_index()
            treemap_data = treemap_data[treemap_data['amount'] > 0] # Filter out zero/negative amounts

            if treemap_data.empty:
                st.info(f"No positive spending data for '{treemap_parent_category}' sub-categories.", icon="ℹ️")
            else:
                fig4 = px.treemap(
                    treemap_data,
                    # Path defines hierarchy: show parent category then sub-categories within it
                    path=[px.Constant(treemap_parent_category), 'sub_category'],
                    values='amount',
                    color='sub_category', # Color by sub-category for multicolour
                    title=f"Breakdown for '{treemap_parent_category}' ({treemap_start_date.strftime('%d%b')} - {treemap_end_date.strftime('%d%b%y')})",
                    # Custom data for hover template needs amount included explicitly if not in path/values/color
                    custom_data=['amount']
                )
                fig4.update_traces(
                     # Display sub-category label and its value/percentage on hover
                    hovertemplate='<b>%{label}</b><br>Amount: ₹%{customdata[0]:,.0f}<br>Percentage of Parent: %{percentParent:.1%}<extra></extra>',
                    # Display sub-category label and value inside the tile if space allows
                    textinfo='label+value',
                    insidetextfont=dict(size=12) # Adjust font size if needed
                )
                fig4.update_layout(
                    margin=dict(l=10, r=10, t=40, b=10),
                    title_font_size=16, title_x=0.5
                )
                st.plotly_chart(fig4, use_container_width=True)

